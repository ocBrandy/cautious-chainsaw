; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\segger_rtt.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\segger_rtt.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\FatFS\src -I..\..\User\Mass_Storage\inc -I..\..\User\LCD_Driver -I..\..\User\SYSTEM\sys -I..\..\User\Debugprintf -I..\..\User\LogDebug -I..\..\User\app\inc -I..\..\User\app\src -I..\..\User\bsp\inc -I..\..\User\bsp\src -I.\RTE\_Flash -ID:\Keil_v5\ARM\Packs\ARM\CMSIS\5.5.1\CMSIS\Core\Include -ID:\Keil_v5\ARM\Packs\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=527 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\segger_rtt.crf ..\..\User\Debugprintf\SEGGER_RTT.c]
                          THUMB

                          AREA ||i.SEGGER_RTT_AllocDownBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_AllocDownBuffer PROC
;;;1519   */
;;;1520   int SEGGER_RTT_AllocDownBuffer(const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;1521     int BufferIndex;
;;;1522   
;;;1523     INIT();
00000c  bf00              NOP      
00000e  482b              LDR      r0,|L1.188|
000010  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
000012  b908              CBNZ     r0,|L1.24|
000014  f7fffffe          BL       _DoInit
                  |L1.24|
000018  bf00              NOP      
;;;1524     SEGGER_RTT_LOCK();
00001a  f3ef8111          MRS      r1,BASEPRI
00001e  4608              MOV      r0,r1
000020  2120              MOVS     r1,#0x20
000022  f3818811          MSR      BASEPRI,r1
000026  bf00              NOP      
000028  bf00              NOP      
;;;1525     BufferIndex = 0;
00002a  2400              MOVS     r4,#0
;;;1526     do {
00002c  bf00              NOP      
                  |L1.46|
;;;1527       if (_SEGGER_RTT.aDown[BufferIndex].pBuffer == NULL) {
00002e  eb040244          ADD      r2,r4,r4,LSL #1
000032  4922              LDR      r1,|L1.188|
000034  3160              ADDS     r1,r1,#0x60
000036  eb0101c2          ADD      r1,r1,r2,LSL #3
00003a  6849              LDR      r1,[r1,#4]
00003c  b901              CBNZ     r1,|L1.64|
;;;1528         break;
00003e  e004              B        |L1.74|
                  |L1.64|
;;;1529       }
;;;1530       BufferIndex++;
000040  1c64              ADDS     r4,r4,#1
;;;1531     } while (BufferIndex < _SEGGER_RTT.MaxNumDownBuffers);
000042  491e              LDR      r1,|L1.188|
000044  6949              LDR      r1,[r1,#0x14]  ; _SEGGER_RTT
000046  42a1              CMP      r1,r4
000048  dcf1              BGT      |L1.46|
                  |L1.74|
00004a  bf00              NOP                            ;1528
;;;1532     if (BufferIndex < _SEGGER_RTT.MaxNumDownBuffers) {
00004c  491b              LDR      r1,|L1.188|
00004e  6949              LDR      r1,[r1,#0x14]  ; _SEGGER_RTT
000050  42a1              CMP      r1,r4
000052  dd29              BLE      |L1.168|
;;;1533       _SEGGER_RTT.aDown[BufferIndex].sName        = sName;
000054  eb040244          ADD      r2,r4,r4,LSL #1
000058  4918              LDR      r1,|L1.188|
00005a  3160              ADDS     r1,r1,#0x60
00005c  f8415032          STR      r5,[r1,r2,LSL #3]
;;;1534       _SEGGER_RTT.aDown[BufferIndex].pBuffer      = (char*)pBuffer;
000060  eb040244          ADD      r2,r4,r4,LSL #1
000064  eb0101c2          ADD      r1,r1,r2,LSL #3
000068  604e              STR      r6,[r1,#4]
;;;1535       _SEGGER_RTT.aDown[BufferIndex].SizeOfBuffer = BufferSize;
00006a  eb040244          ADD      r2,r4,r4,LSL #1
00006e  4913              LDR      r1,|L1.188|
000070  3160              ADDS     r1,r1,#0x60
000072  eb0101c2          ADD      r1,r1,r2,LSL #3
000076  608f              STR      r7,[r1,#8]
;;;1536       _SEGGER_RTT.aDown[BufferIndex].RdOff        = 0u;
000078  2200              MOVS     r2,#0
00007a  eb040344          ADD      r3,r4,r4,LSL #1
00007e  490f              LDR      r1,|L1.188|
000080  3160              ADDS     r1,r1,#0x60
000082  eb0101c3          ADD      r1,r1,r3,LSL #3
000086  610a              STR      r2,[r1,#0x10]
;;;1537       _SEGGER_RTT.aDown[BufferIndex].WrOff        = 0u;
000088  eb040344          ADD      r3,r4,r4,LSL #1
00008c  490b              LDR      r1,|L1.188|
00008e  3160              ADDS     r1,r1,#0x60
000090  eb0101c3          ADD      r1,r1,r3,LSL #3
000094  60ca              STR      r2,[r1,#0xc]
;;;1538       _SEGGER_RTT.aDown[BufferIndex].Flags        = Flags;
000096  eb040244          ADD      r2,r4,r4,LSL #1
00009a  4908              LDR      r1,|L1.188|
00009c  3160              ADDS     r1,r1,#0x60
00009e  eb0101c2          ADD      r1,r1,r2,LSL #3
0000a2  f8c18014          STR      r8,[r1,#0x14]
0000a6  e001              B        |L1.172|
                  |L1.168|
;;;1539     } else {
;;;1540       BufferIndex = -1;
0000a8  f04f34ff          MOV      r4,#0xffffffff
                  |L1.172|
;;;1541     }
;;;1542     SEGGER_RTT_UNLOCK();
0000ac  b2c1              UXTB     r1,r0
0000ae  f3818811          MSR      BASEPRI,r1
0000b2  bf00              NOP      
0000b4  bf00              NOP      
;;;1543     return BufferIndex;
0000b6  4620              MOV      r0,r4
;;;1544   }
0000b8  e8bd81f0          POP      {r4-r8,pc}
;;;1545   
                          ENDP

                  |L1.188|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_AllocUpBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_AllocUpBuffer PROC
;;;1564   */
;;;1565   int SEGGER_RTT_AllocUpBuffer(const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;1566     int BufferIndex;
;;;1567   
;;;1568     INIT();
00000c  bf00              NOP      
00000e  482b              LDR      r0,|L2.188|
000010  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
000012  b908              CBNZ     r0,|L2.24|
000014  f7fffffe          BL       _DoInit
                  |L2.24|
000018  bf00              NOP      
;;;1569     SEGGER_RTT_LOCK();
00001a  f3ef8111          MRS      r1,BASEPRI
00001e  4608              MOV      r0,r1
000020  2120              MOVS     r1,#0x20
000022  f3818811          MSR      BASEPRI,r1
000026  bf00              NOP      
000028  bf00              NOP      
;;;1570     BufferIndex = 0;
00002a  2400              MOVS     r4,#0
;;;1571     do {
00002c  bf00              NOP      
                  |L2.46|
;;;1572       if (_SEGGER_RTT.aUp[BufferIndex].pBuffer == NULL) {
00002e  eb040244          ADD      r2,r4,r4,LSL #1
000032  4922              LDR      r1,|L2.188|
000034  3118              ADDS     r1,r1,#0x18
000036  eb0101c2          ADD      r1,r1,r2,LSL #3
00003a  6849              LDR      r1,[r1,#4]
00003c  b901              CBNZ     r1,|L2.64|
;;;1573         break;
00003e  e004              B        |L2.74|
                  |L2.64|
;;;1574       }
;;;1575       BufferIndex++;
000040  1c64              ADDS     r4,r4,#1
;;;1576     } while (BufferIndex < _SEGGER_RTT.MaxNumUpBuffers);
000042  491e              LDR      r1,|L2.188|
000044  6909              LDR      r1,[r1,#0x10]  ; _SEGGER_RTT
000046  42a1              CMP      r1,r4
000048  dcf1              BGT      |L2.46|
                  |L2.74|
00004a  bf00              NOP                            ;1573
;;;1577     if (BufferIndex < _SEGGER_RTT.MaxNumUpBuffers) {
00004c  491b              LDR      r1,|L2.188|
00004e  6909              LDR      r1,[r1,#0x10]  ; _SEGGER_RTT
000050  42a1              CMP      r1,r4
000052  dd29              BLE      |L2.168|
;;;1578       _SEGGER_RTT.aUp[BufferIndex].sName        = sName;
000054  eb040244          ADD      r2,r4,r4,LSL #1
000058  4918              LDR      r1,|L2.188|
00005a  3118              ADDS     r1,r1,#0x18
00005c  f8415032          STR      r5,[r1,r2,LSL #3]
;;;1579       _SEGGER_RTT.aUp[BufferIndex].pBuffer      = (char*)pBuffer;
000060  eb040244          ADD      r2,r4,r4,LSL #1
000064  eb0101c2          ADD      r1,r1,r2,LSL #3
000068  604e              STR      r6,[r1,#4]
;;;1580       _SEGGER_RTT.aUp[BufferIndex].SizeOfBuffer = BufferSize;
00006a  eb040244          ADD      r2,r4,r4,LSL #1
00006e  4913              LDR      r1,|L2.188|
000070  3118              ADDS     r1,r1,#0x18
000072  eb0101c2          ADD      r1,r1,r2,LSL #3
000076  608f              STR      r7,[r1,#8]
;;;1581       _SEGGER_RTT.aUp[BufferIndex].RdOff        = 0u;
000078  2200              MOVS     r2,#0
00007a  eb040344          ADD      r3,r4,r4,LSL #1
00007e  490f              LDR      r1,|L2.188|
000080  3118              ADDS     r1,r1,#0x18
000082  eb0101c3          ADD      r1,r1,r3,LSL #3
000086  610a              STR      r2,[r1,#0x10]
;;;1582       _SEGGER_RTT.aUp[BufferIndex].WrOff        = 0u;
000088  eb040344          ADD      r3,r4,r4,LSL #1
00008c  490b              LDR      r1,|L2.188|
00008e  3118              ADDS     r1,r1,#0x18
000090  eb0101c3          ADD      r1,r1,r3,LSL #3
000094  60ca              STR      r2,[r1,#0xc]
;;;1583       _SEGGER_RTT.aUp[BufferIndex].Flags        = Flags;
000096  eb040244          ADD      r2,r4,r4,LSL #1
00009a  4908              LDR      r1,|L2.188|
00009c  3118              ADDS     r1,r1,#0x18
00009e  eb0101c2          ADD      r1,r1,r2,LSL #3
0000a2  f8c18014          STR      r8,[r1,#0x14]
0000a6  e001              B        |L2.172|
                  |L2.168|
;;;1584     } else {
;;;1585       BufferIndex = -1;
0000a8  f04f34ff          MOV      r4,#0xffffffff
                  |L2.172|
;;;1586     }
;;;1587     SEGGER_RTT_UNLOCK();
0000ac  b2c1              UXTB     r1,r0
0000ae  f3818811          MSR      BASEPRI,r1
0000b2  bf00              NOP      
0000b4  bf00              NOP      
;;;1588     return BufferIndex;
0000b6  4620              MOV      r0,r4
;;;1589   }
0000b8  e8bd81f0          POP      {r4-r8,pc}
;;;1590   
                          ENDP

                  |L2.188|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_ConfigDownBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_ConfigDownBuffer PROC
;;;1662   */
;;;1663   int SEGGER_RTT_ConfigDownBuffer(unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  f8dd9020          LDR      r9,[sp,#0x20]
;;;1664     int r;
;;;1665   
;;;1666     INIT();
000010  bf00              NOP      
000012  4824              LDR      r0,|L3.164|
000014  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
000016  b908              CBNZ     r0,|L3.28|
000018  f7fffffe          BL       _DoInit
                  |L3.28|
00001c  bf00              NOP      
;;;1667     if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumDownBuffers) {
00001e  4821              LDR      r0,|L3.164|
000020  6940              LDR      r0,[r0,#0x14]  ; _SEGGER_RTT
000022  42a0              CMP      r0,r4
000024  d939              BLS      |L3.154|
;;;1668       SEGGER_RTT_LOCK();
000026  f3ef8111          MRS      r1,BASEPRI
00002a  4608              MOV      r0,r1
00002c  2120              MOVS     r1,#0x20
00002e  f3818811          MSR      BASEPRI,r1
000032  bf00              NOP      
000034  bf00              NOP      
;;;1669       if (BufferIndex > 0u) {
000036  b30c              CBZ      r4,|L3.124|
;;;1670         _SEGGER_RTT.aDown[BufferIndex].sName        = sName;
000038  eb040244          ADD      r2,r4,r4,LSL #1
00003c  4919              LDR      r1,|L3.164|
00003e  3160              ADDS     r1,r1,#0x60
000040  f8416032          STR      r6,[r1,r2,LSL #3]
;;;1671         _SEGGER_RTT.aDown[BufferIndex].pBuffer      = (char*)pBuffer;
000044  eb040244          ADD      r2,r4,r4,LSL #1
000048  eb0101c2          ADD      r1,r1,r2,LSL #3
00004c  604f              STR      r7,[r1,#4]
;;;1672         _SEGGER_RTT.aDown[BufferIndex].SizeOfBuffer = BufferSize;
00004e  eb040244          ADD      r2,r4,r4,LSL #1
000052  4914              LDR      r1,|L3.164|
000054  3160              ADDS     r1,r1,#0x60
000056  eb0101c2          ADD      r1,r1,r2,LSL #3
00005a  f8c18008          STR      r8,[r1,#8]
;;;1673         _SEGGER_RTT.aDown[BufferIndex].RdOff        = 0u;
00005e  2200              MOVS     r2,#0
000060  eb040344          ADD      r3,r4,r4,LSL #1
000064  490f              LDR      r1,|L3.164|
000066  3160              ADDS     r1,r1,#0x60
000068  eb0101c3          ADD      r1,r1,r3,LSL #3
00006c  610a              STR      r2,[r1,#0x10]
;;;1674         _SEGGER_RTT.aDown[BufferIndex].WrOff        = 0u;
00006e  eb040344          ADD      r3,r4,r4,LSL #1
000072  490c              LDR      r1,|L3.164|
000074  3160              ADDS     r1,r1,#0x60
000076  eb0101c3          ADD      r1,r1,r3,LSL #3
00007a  60ca              STR      r2,[r1,#0xc]
                  |L3.124|
;;;1675       }
;;;1676       _SEGGER_RTT.aDown[BufferIndex].Flags          = Flags;
00007c  eb040244          ADD      r2,r4,r4,LSL #1
000080  4908              LDR      r1,|L3.164|
000082  3160              ADDS     r1,r1,#0x60
000084  eb0101c2          ADD      r1,r1,r2,LSL #3
000088  f8c19014          STR      r9,[r1,#0x14]
;;;1677       SEGGER_RTT_UNLOCK();
00008c  b2c1              UXTB     r1,r0
00008e  f3818811          MSR      BASEPRI,r1
000092  bf00              NOP      
000094  bf00              NOP      
;;;1678       r =  0;
000096  2500              MOVS     r5,#0
000098  e001              B        |L3.158|
                  |L3.154|
;;;1679     } else {
;;;1680       r = -1;
00009a  f04f35ff          MOV      r5,#0xffffffff
                  |L3.158|
;;;1681     }
;;;1682     return r;
00009e  4628              MOV      r0,r5
;;;1683   }
0000a0  e8bd87f0          POP      {r4-r10,pc}
;;;1684   
                          ENDP

                  |L3.164|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_ConfigUpBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_ConfigUpBuffer PROC
;;;1615   */
;;;1616   int SEGGER_RTT_ConfigUpBuffer(unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  f8dd9020          LDR      r9,[sp,#0x20]
;;;1617     int r;
;;;1618   
;;;1619     INIT();
000010  bf00              NOP      
000012  4824              LDR      r0,|L4.164|
000014  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
000016  b908              CBNZ     r0,|L4.28|
000018  f7fffffe          BL       _DoInit
                  |L4.28|
00001c  bf00              NOP      
;;;1620     if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumUpBuffers) {
00001e  4821              LDR      r0,|L4.164|
000020  6900              LDR      r0,[r0,#0x10]  ; _SEGGER_RTT
000022  42a0              CMP      r0,r4
000024  d939              BLS      |L4.154|
;;;1621       SEGGER_RTT_LOCK();
000026  f3ef8111          MRS      r1,BASEPRI
00002a  4608              MOV      r0,r1
00002c  2120              MOVS     r1,#0x20
00002e  f3818811          MSR      BASEPRI,r1
000032  bf00              NOP      
000034  bf00              NOP      
;;;1622       if (BufferIndex > 0u) {
000036  b30c              CBZ      r4,|L4.124|
;;;1623         _SEGGER_RTT.aUp[BufferIndex].sName        = sName;
000038  eb040244          ADD      r2,r4,r4,LSL #1
00003c  4919              LDR      r1,|L4.164|
00003e  3118              ADDS     r1,r1,#0x18
000040  f8416032          STR      r6,[r1,r2,LSL #3]
;;;1624         _SEGGER_RTT.aUp[BufferIndex].pBuffer      = (char*)pBuffer;
000044  eb040244          ADD      r2,r4,r4,LSL #1
000048  eb0101c2          ADD      r1,r1,r2,LSL #3
00004c  604f              STR      r7,[r1,#4]
;;;1625         _SEGGER_RTT.aUp[BufferIndex].SizeOfBuffer = BufferSize;
00004e  eb040244          ADD      r2,r4,r4,LSL #1
000052  4914              LDR      r1,|L4.164|
000054  3118              ADDS     r1,r1,#0x18
000056  eb0101c2          ADD      r1,r1,r2,LSL #3
00005a  f8c18008          STR      r8,[r1,#8]
;;;1626         _SEGGER_RTT.aUp[BufferIndex].RdOff        = 0u;
00005e  2200              MOVS     r2,#0
000060  eb040344          ADD      r3,r4,r4,LSL #1
000064  490f              LDR      r1,|L4.164|
000066  3118              ADDS     r1,r1,#0x18
000068  eb0101c3          ADD      r1,r1,r3,LSL #3
00006c  610a              STR      r2,[r1,#0x10]
;;;1627         _SEGGER_RTT.aUp[BufferIndex].WrOff        = 0u;
00006e  eb040344          ADD      r3,r4,r4,LSL #1
000072  490c              LDR      r1,|L4.164|
000074  3118              ADDS     r1,r1,#0x18
000076  eb0101c3          ADD      r1,r1,r3,LSL #3
00007a  60ca              STR      r2,[r1,#0xc]
                  |L4.124|
;;;1628       }
;;;1629       _SEGGER_RTT.aUp[BufferIndex].Flags          = Flags;
00007c  eb040244          ADD      r2,r4,r4,LSL #1
000080  4908              LDR      r1,|L4.164|
000082  3118              ADDS     r1,r1,#0x18
000084  eb0101c2          ADD      r1,r1,r2,LSL #3
000088  f8c19014          STR      r9,[r1,#0x14]
;;;1630       SEGGER_RTT_UNLOCK();
00008c  b2c1              UXTB     r1,r0
00008e  f3818811          MSR      BASEPRI,r1
000092  bf00              NOP      
000094  bf00              NOP      
;;;1631       r =  0;
000096  2500              MOVS     r5,#0
000098  e001              B        |L4.158|
                  |L4.154|
;;;1632     } else {
;;;1633       r = -1;
00009a  f04f35ff          MOV      r5,#0xffffffff
                  |L4.158|
;;;1634     }
;;;1635     return r;
00009e  4628              MOV      r0,r5
;;;1636   }
0000a0  e8bd87f0          POP      {r4-r10,pc}
;;;1637   
                          ENDP

                  |L4.164|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_GetAvailWriteSpace||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_GetAvailWriteSpace PROC
;;;1973   */
;;;1974   unsigned SEGGER_RTT_GetAvailWriteSpace (unsigned BufferIndex){
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;1975     return _GetAvailWriteSpace(&_SEGGER_RTT.aUp[BufferIndex]);
000004  eb040244          ADD      r2,r4,r4,LSL #1
000008  4902              LDR      r1,|L5.20|
00000a  eb0100c2          ADD      r0,r1,r2,LSL #3
00000e  f7fffffe          BL       _GetAvailWriteSpace
;;;1976   }
000012  bd10              POP      {r4,pc}
;;;1977   
                          ENDP

                  |L5.20|
                          DCD      _SEGGER_RTT+0x18

                          AREA ||i.SEGGER_RTT_GetBytesInBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_GetBytesInBuffer PROC
;;;1991   */
;;;1992   unsigned SEGGER_RTT_GetBytesInBuffer(unsigned BufferIndex) {
000000  b530              PUSH     {r4,r5,lr}
000002  4601              MOV      r1,r0
;;;1993     unsigned RdOff;
;;;1994     unsigned WrOff;
;;;1995     unsigned r;
;;;1996     //
;;;1997     // Avoid warnings regarding volatile access order.  It's not a problem
;;;1998     // in this case, but dampen compiler enthusiasm.
;;;1999     //
;;;2000     RdOff = _SEGGER_RTT.aUp[BufferIndex].RdOff;
000004  eb010541          ADD      r5,r1,r1,LSL #1
000008  4c0b              LDR      r4,|L6.56|
00000a  eb0404c5          ADD      r4,r4,r5,LSL #3
00000e  6922              LDR      r2,[r4,#0x10]
;;;2001     WrOff = _SEGGER_RTT.aUp[BufferIndex].WrOff;
000010  eb010541          ADD      r5,r1,r1,LSL #1
000014  4c08              LDR      r4,|L6.56|
000016  eb0404c5          ADD      r4,r4,r5,LSL #3
00001a  68e3              LDR      r3,[r4,#0xc]
;;;2002     if (RdOff <= WrOff) {
00001c  429a              CMP      r2,r3
00001e  d801              BHI      |L6.36|
;;;2003       r = WrOff - RdOff;
000020  1a98              SUBS     r0,r3,r2
000022  e007              B        |L6.52|
                  |L6.36|
;;;2004     } else {
;;;2005       r = _SEGGER_RTT.aUp[BufferIndex].SizeOfBuffer - (WrOff - RdOff);
000024  eb010541          ADD      r5,r1,r1,LSL #1
000028  4c03              LDR      r4,|L6.56|
00002a  eb0404c5          ADD      r4,r4,r5,LSL #3
00002e  68a4              LDR      r4,[r4,#8]
000030  1a9d              SUBS     r5,r3,r2
000032  1b60              SUBS     r0,r4,r5
                  |L6.52|
;;;2006     }
;;;2007     return r;
;;;2008   }
000034  bd30              POP      {r4,r5,pc}
;;;2009   
                          ENDP

000036  0000              DCW      0x0000
                  |L6.56|
                          DCD      _SEGGER_RTT+0x18

                          AREA ||i.SEGGER_RTT_GetKey||, CODE, READONLY, ALIGN=1

                  SEGGER_RTT_GetKey PROC
;;;1393   */
;;;1394   int SEGGER_RTT_GetKey(void) {
000000  b538              PUSH     {r3-r5,lr}
;;;1395     char c;
;;;1396     int r;
;;;1397   
;;;1398     r = (int)SEGGER_RTT_Read(0u, &c, 1u);
000002  2201              MOVS     r2,#1
000004  4669              MOV      r1,sp
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       SEGGER_RTT_Read
00000c  4604              MOV      r4,r0
;;;1399     if (r == 1) {
00000e  2c01              CMP      r4,#1
000010  d102              BNE      |L7.24|
;;;1400       r = (int)(unsigned char)c;
000012  f89d4000          LDRB     r4,[sp,#0]
000016  e001              B        |L7.28|
                  |L7.24|
;;;1401     } else {
;;;1402       r = -1;
000018  f04f34ff          MOV      r4,#0xffffffff
                  |L7.28|
;;;1403     }
;;;1404     return r;
00001c  4620              MOV      r0,r4
;;;1405   }
00001e  bd38              POP      {r3-r5,pc}
;;;1406   
                          ENDP


                          AREA ||i.SEGGER_RTT_HasData||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_HasData PROC
;;;1470   */
;;;1471   unsigned SEGGER_RTT_HasData(unsigned BufferIndex) {
000000  b510              PUSH     {r4,lr}
000002  4601              MOV      r1,r0
;;;1472     SEGGER_RTT_BUFFER_DOWN* pRing;
;;;1473     unsigned                v;
;;;1474   
;;;1475     pRing = &_SEGGER_RTT.aDown[BufferIndex];
000004  eb010441          ADD      r4,r1,r1,LSL #1
000008  4803              LDR      r0,|L8.24|
00000a  eb0002c4          ADD      r2,r0,r4,LSL #3
;;;1476     v = pRing->WrOff;
00000e  68d3              LDR      r3,[r2,#0xc]
;;;1477     return v - pRing->RdOff;
000010  6910              LDR      r0,[r2,#0x10]
000012  1a18              SUBS     r0,r3,r0
;;;1478   }
000014  bd10              POP      {r4,pc}
;;;1479   
                          ENDP

000016  0000              DCW      0x0000
                  |L8.24|
                          DCD      _SEGGER_RTT+0x60

                          AREA ||i.SEGGER_RTT_HasDataUp||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_HasDataUp PROC
;;;1491   */
;;;1492   unsigned SEGGER_RTT_HasDataUp(unsigned BufferIndex) {
000000  b510              PUSH     {r4,lr}
000002  4601              MOV      r1,r0
;;;1493     SEGGER_RTT_BUFFER_UP* pRing;
;;;1494     unsigned                v;
;;;1495   
;;;1496     pRing = &_SEGGER_RTT.aUp[BufferIndex];
000004  eb010441          ADD      r4,r1,r1,LSL #1
000008  4803              LDR      r0,|L9.24|
00000a  eb0002c4          ADD      r2,r0,r4,LSL #3
;;;1497     v = pRing->RdOff;
00000e  6913              LDR      r3,[r2,#0x10]
;;;1498     return pRing->WrOff - v;
000010  68d0              LDR      r0,[r2,#0xc]
000012  1ac0              SUBS     r0,r0,r3
;;;1499   }
000014  bd10              POP      {r4,pc}
;;;1500   
                          ENDP

000016  0000              DCW      0x0000
                  |L9.24|
                          DCD      _SEGGER_RTT+0x18

                          AREA ||i.SEGGER_RTT_HasKey||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_HasKey PROC
;;;1444   */
;;;1445   int SEGGER_RTT_HasKey(void) {
000000  b570              PUSH     {r4-r6,lr}
;;;1446     unsigned RdOff;
;;;1447     int r;
;;;1448   
;;;1449     INIT();
000002  bf00              NOP      
000004  4807              LDR      r0,|L10.36|
000006  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
000008  b908              CBNZ     r0,|L10.14|
00000a  f7fffffe          BL       _DoInit
                  |L10.14|
00000e  bf00              NOP      
;;;1450     RdOff = _SEGGER_RTT.aDown[0].RdOff;
000010  4804              LDR      r0,|L10.36|
000012  6f05              LDR      r5,[r0,#0x70]
;;;1451     if (RdOff != _SEGGER_RTT.aDown[0].WrOff) {
000014  6ec0              LDR      r0,[r0,#0x6c]
000016  42a8              CMP      r0,r5
000018  d001              BEQ      |L10.30|
;;;1452       r = 1;
00001a  2401              MOVS     r4,#1
00001c  e000              B        |L10.32|
                  |L10.30|
;;;1453     } else {
;;;1454       r = 0;
00001e  2400              MOVS     r4,#0
                  |L10.32|
;;;1455     }
;;;1456     return r;
000020  4620              MOV      r0,r4
;;;1457   }
000022  bd70              POP      {r4-r6,pc}
;;;1458   
                          ENDP

                  |L10.36|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_Init||, CODE, READONLY, ALIGN=1

                  SEGGER_RTT_Init PROC
;;;1817   */
;;;1818   void SEGGER_RTT_Init (void) {
000000  b510              PUSH     {r4,lr}
;;;1819     _DoInit();
000002  f7fffffe          BL       _DoInit
;;;1820   }
000006  bd10              POP      {r4,pc}
;;;1821   
                          ENDP


                          AREA ||i.SEGGER_RTT_PutChar||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_PutChar PROC
;;;1332   
;;;1333   unsigned SEGGER_RTT_PutChar(unsigned BufferIndex, char c) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
;;;1334     SEGGER_RTT_BUFFER_UP* pRing;
;;;1335     unsigned              WrOff;
;;;1336     unsigned              Status;
;;;1337     //
;;;1338     // Prepare
;;;1339     //
;;;1340     INIT();
000008  bf00              NOP      
00000a  481a              LDR      r0,|L12.116|
00000c  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000e  b908              CBNZ     r0,|L12.20|
000010  f7fffffe          BL       _DoInit
                  |L12.20|
000014  bf00              NOP      
;;;1341     SEGGER_RTT_LOCK();
000016  f3ef8111          MRS      r1,BASEPRI
00001a  4608              MOV      r0,r1
00001c  2120              MOVS     r1,#0x20
00001e  f3818811          MSR      BASEPRI,r1
000022  bf00              NOP      
000024  bf00              NOP      
;;;1342     //
;;;1343     // Get "to-host" ring buffer.
;;;1344     //
;;;1345     pRing = &_SEGGER_RTT.aUp[BufferIndex];
000026  eb070247          ADD      r2,r7,r7,LSL #1
00002a  4912              LDR      r1,|L12.116|
00002c  3118              ADDS     r1,r1,#0x18
00002e  eb0104c2          ADD      r4,r1,r2,LSL #3
;;;1346     //
;;;1347     // Get write position and handle wrap-around if necessary
;;;1348     //
;;;1349     WrOff = pRing->WrOff + 1;
000032  68e1              LDR      r1,[r4,#0xc]
000034  1c4d              ADDS     r5,r1,#1
;;;1350     if (WrOff == pRing->SizeOfBuffer) {
000036  68a1              LDR      r1,[r4,#8]
000038  42a9              CMP      r1,r5
00003a  d100              BNE      |L12.62|
;;;1351       WrOff = 0;
00003c  2500              MOVS     r5,#0
                  |L12.62|
;;;1352     }
;;;1353     //
;;;1354     // Wait for free space if mode is set to blocking
;;;1355     //
;;;1356     if (pRing->Flags == SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL) {
00003e  6961              LDR      r1,[r4,#0x14]
000040  2902              CMP      r1,#2
000042  d103              BNE      |L12.76|
;;;1357       while (WrOff == pRing->RdOff) {
000044  bf00              NOP      
                  |L12.70|
000046  6921              LDR      r1,[r4,#0x10]
000048  42a9              CMP      r1,r5
00004a  d0fc              BEQ      |L12.70|
                  |L12.76|
;;;1358         ;
;;;1359       }
;;;1360     }
;;;1361     //
;;;1362     // Output byte if free space is available
;;;1363     //
;;;1364     if (WrOff != pRing->RdOff) {
00004c  6921              LDR      r1,[r4,#0x10]
00004e  42a9              CMP      r1,r5
000050  d006              BEQ      |L12.96|
;;;1365       pRing->pBuffer[pRing->WrOff] = c;
000052  68e2              LDR      r2,[r4,#0xc]
000054  6861              LDR      r1,[r4,#4]
000056  f8018002          STRB     r8,[r1,r2]
;;;1366       pRing->WrOff = WrOff;
00005a  60e5              STR      r5,[r4,#0xc]
;;;1367       Status = 1;
00005c  2601              MOVS     r6,#1
00005e  e000              B        |L12.98|
                  |L12.96|
;;;1368     } else {
;;;1369       Status = 0;
000060  2600              MOVS     r6,#0
                  |L12.98|
;;;1370     }
;;;1371     //
;;;1372     // Finish up.
;;;1373     //
;;;1374     SEGGER_RTT_UNLOCK();
000062  b2c1              UXTB     r1,r0
000064  f3818811          MSR      BASEPRI,r1
000068  bf00              NOP      
00006a  bf00              NOP      
;;;1375     //
;;;1376     return Status;
00006c  4630              MOV      r0,r6
;;;1377   }
00006e  e8bd81f0          POP      {r4-r8,pc}
;;;1378   
                          ENDP

000072  0000              DCW      0x0000
                  |L12.116|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_PutCharSkip||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_PutCharSkip PROC
;;;1276   
;;;1277   unsigned SEGGER_RTT_PutCharSkip(unsigned BufferIndex, char c) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
;;;1278     SEGGER_RTT_BUFFER_UP* pRing;
;;;1279     unsigned              WrOff;
;;;1280     unsigned              Status;
;;;1281     //
;;;1282     // Prepare
;;;1283     //
;;;1284     INIT();
000008  bf00              NOP      
00000a  4816              LDR      r0,|L13.100|
00000c  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000e  b908              CBNZ     r0,|L13.20|
000010  f7fffffe          BL       _DoInit
                  |L13.20|
000014  bf00              NOP      
;;;1285     SEGGER_RTT_LOCK();
000016  f3ef8111          MRS      r1,BASEPRI
00001a  4608              MOV      r0,r1
00001c  2120              MOVS     r1,#0x20
00001e  f3818811          MSR      BASEPRI,r1
000022  bf00              NOP      
000024  bf00              NOP      
;;;1286     //
;;;1287     // Get "to-host" ring buffer.
;;;1288     //
;;;1289     pRing = &_SEGGER_RTT.aUp[BufferIndex];
000026  eb070247          ADD      r2,r7,r7,LSL #1
00002a  490e              LDR      r1,|L13.100|
00002c  3118              ADDS     r1,r1,#0x18
00002e  eb0104c2          ADD      r4,r1,r2,LSL #3
;;;1290     //
;;;1291     // Get write position and handle wrap-around if necessary
;;;1292     //
;;;1293     WrOff = pRing->WrOff + 1;
000032  68e1              LDR      r1,[r4,#0xc]
000034  1c4d              ADDS     r5,r1,#1
;;;1294     if (WrOff == pRing->SizeOfBuffer) {
000036  68a1              LDR      r1,[r4,#8]
000038  42a9              CMP      r1,r5
00003a  d100              BNE      |L13.62|
;;;1295       WrOff = 0;
00003c  2500              MOVS     r5,#0
                  |L13.62|
;;;1296     }
;;;1297     //
;;;1298     // Output byte if free space is available
;;;1299     //
;;;1300     if (WrOff != pRing->RdOff) {
00003e  6921              LDR      r1,[r4,#0x10]
000040  42a9              CMP      r1,r5
000042  d006              BEQ      |L13.82|
;;;1301       pRing->pBuffer[pRing->WrOff] = c;
000044  68e2              LDR      r2,[r4,#0xc]
000046  6861              LDR      r1,[r4,#4]
000048  f8018002          STRB     r8,[r1,r2]
;;;1302       pRing->WrOff = WrOff;
00004c  60e5              STR      r5,[r4,#0xc]
;;;1303       Status = 1;
00004e  2601              MOVS     r6,#1
000050  e000              B        |L13.84|
                  |L13.82|
;;;1304     } else {
;;;1305       Status = 0;
000052  2600              MOVS     r6,#0
                  |L13.84|
;;;1306     }
;;;1307     //
;;;1308     // Finish up.
;;;1309     //
;;;1310     SEGGER_RTT_UNLOCK();
000054  b2c1              UXTB     r1,r0
000056  f3818811          MSR      BASEPRI,r1
00005a  bf00              NOP      
00005c  bf00              NOP      
;;;1311     //
;;;1312     return Status;
00005e  4630              MOV      r0,r6
;;;1313   }
000060  e8bd81f0          POP      {r4-r8,pc}
;;;1314   
                          ENDP

                  |L13.100|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_PutCharSkipNoLock||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_PutCharSkipNoLock PROC
;;;1229   
;;;1230   unsigned SEGGER_RTT_PutCharSkipNoLock(unsigned BufferIndex, char c) {
000000  b570              PUSH     {r4-r6,lr}
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;1231     SEGGER_RTT_BUFFER_UP* pRing;
;;;1232     unsigned              WrOff;
;;;1233     unsigned              Status;
;;;1234     //
;;;1235     // Get "to-host" ring buffer.
;;;1236     //
;;;1237     pRing = &_SEGGER_RTT.aUp[BufferIndex];
000006  eb030643          ADD      r6,r3,r3,LSL #1
00000a  4d0a              LDR      r5,|L14.52|
00000c  eb0501c6          ADD      r1,r5,r6,LSL #3
;;;1238     //
;;;1239     // Get write position and handle wrap-around if necessary
;;;1240     //
;;;1241     WrOff = pRing->WrOff + 1;
000010  68cd              LDR      r5,[r1,#0xc]
000012  1c6a              ADDS     r2,r5,#1
;;;1242     if (WrOff == pRing->SizeOfBuffer) {
000014  688d              LDR      r5,[r1,#8]
000016  4295              CMP      r5,r2
000018  d100              BNE      |L14.28|
;;;1243       WrOff = 0;
00001a  2200              MOVS     r2,#0
                  |L14.28|
;;;1244     }
;;;1245     //
;;;1246     // Output byte if free space is available
;;;1247     //
;;;1248     if (WrOff != pRing->RdOff) {
00001c  690d              LDR      r5,[r1,#0x10]
00001e  4295              CMP      r5,r2
000020  d005              BEQ      |L14.46|
;;;1249       pRing->pBuffer[pRing->WrOff] = c;
000022  68ce              LDR      r6,[r1,#0xc]
000024  684d              LDR      r5,[r1,#4]
000026  55ac              STRB     r4,[r5,r6]
;;;1250       pRing->WrOff = WrOff;
000028  60ca              STR      r2,[r1,#0xc]
;;;1251       Status = 1;
00002a  2001              MOVS     r0,#1
00002c  e000              B        |L14.48|
                  |L14.46|
;;;1252     } else {
;;;1253       Status = 0;
00002e  2000              MOVS     r0,#0
                  |L14.48|
;;;1254     }
;;;1255     //
;;;1256     return Status;
;;;1257   }
000030  bd70              POP      {r4-r6,pc}
;;;1258   
                          ENDP

000032  0000              DCW      0x0000
                  |L14.52|
                          DCD      _SEGGER_RTT+0x18

                          AREA ||i.SEGGER_RTT_Read||, CODE, READONLY, ALIGN=1

                  SEGGER_RTT_Read PROC
;;;750    */
;;;751    unsigned SEGGER_RTT_Read(unsigned BufferIndex, void* pBuffer, unsigned BufferSize) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;752      unsigned NumBytesRead;
;;;753      //
;;;754      SEGGER_RTT_LOCK();
00000a  f3ef8011          MRS      r0,BASEPRI
00000e  4680              MOV      r8,r0
000010  2020              MOVS     r0,#0x20
000012  f3808811          MSR      BASEPRI,r0
000016  bf00              NOP      
000018  bf00              NOP      
;;;755      //
;;;756      // Call the non-locking read function
;;;757      //
;;;758      NumBytesRead = SEGGER_RTT_ReadNoLock(BufferIndex, pBuffer, BufferSize);
00001a  4632              MOV      r2,r6
00001c  4629              MOV      r1,r5
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       SEGGER_RTT_ReadNoLock
000024  4607              MOV      r7,r0
;;;759      //
;;;760      // Finish up.
;;;761      //
;;;762      SEGGER_RTT_UNLOCK();
000026  f00800ff          AND      r0,r8,#0xff
00002a  f3808811          MSR      BASEPRI,r0
00002e  bf00              NOP      
000030  bf00              NOP      
;;;763      //
;;;764      return NumBytesRead;
000032  4638              MOV      r0,r7
;;;765    }
000034  e8bd81f0          POP      {r4-r8,pc}
;;;766    
                          ENDP


                          AREA ||i.SEGGER_RTT_ReadNoLock||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_ReadNoLock PROC
;;;619    */
;;;620    unsigned SEGGER_RTT_ReadNoLock(unsigned BufferIndex, void* pData, unsigned BufferSize) {
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
000004  4683              MOV      r11,r0
000006  4617              MOV      r7,r2
;;;621      unsigned                NumBytesRem;
;;;622      unsigned                NumBytesRead;
;;;623      unsigned                RdOff;
;;;624      unsigned                WrOff;
;;;625      unsigned char*          pBuffer;
;;;626      SEGGER_RTT_BUFFER_DOWN* pRing;
;;;627    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;628      const char*             pSrc;
;;;629    #endif
;;;630      //
;;;631      INIT();
000008  bf00              NOP      
00000a  4822              LDR      r0,|L16.148|
00000c  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000e  b908              CBNZ     r0,|L16.20|
000010  f7fffffe          BL       _DoInit
                  |L16.20|
000014  bf00              NOP      
;;;632      pRing = &_SEGGER_RTT.aDown[BufferIndex];
000016  eb0b014b          ADD      r1,r11,r11,LSL #1
00001a  481e              LDR      r0,|L16.148|
00001c  3060              ADDS     r0,r0,#0x60
00001e  eb0006c1          ADD      r6,r0,r1,LSL #3
;;;633      pBuffer = (unsigned char*)pData;
000022  f8dd9004          LDR      r9,[sp,#4]
;;;634      RdOff = pRing->RdOff;
000026  6935              LDR      r5,[r6,#0x10]
;;;635      WrOff = pRing->WrOff;
000028  f8d6a00c          LDR      r10,[r6,#0xc]
;;;636      NumBytesRead = 0u;
00002c  f04f0800          MOV      r8,#0
;;;637      //
;;;638      // Read from current read position to wrap-around of buffer, first
;;;639      //
;;;640      if (RdOff > WrOff) {
000030  4555              CMP      r5,r10
000032  d915              BLS      |L16.96|
;;;641        NumBytesRem = pRing->SizeOfBuffer - RdOff;
000034  68b0              LDR      r0,[r6,#8]
000036  1b44              SUBS     r4,r0,r5
;;;642        NumBytesRem = MIN(NumBytesRem, BufferSize);
000038  42bc              CMP      r4,r7
00003a  d201              BCS      |L16.64|
00003c  4620              MOV      r0,r4
00003e  e000              B        |L16.66|
                  |L16.64|
000040  4638              MOV      r0,r7
                  |L16.66|
000042  4604              MOV      r4,r0
;;;643    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;644        pSrc = pRing->pBuffer + RdOff;
;;;645        NumBytesRead += NumBytesRem;
;;;646        BufferSize   -= NumBytesRem;
;;;647        RdOff        += NumBytesRem;
;;;648        while (NumBytesRem--) {
;;;649          *pBuffer++ = *pSrc++;
;;;650        };
;;;651    #else
;;;652        SEGGER_RTT_MEMCPY(pBuffer, pRing->pBuffer + RdOff, NumBytesRem);
000044  6870              LDR      r0,[r6,#4]
000046  1941              ADDS     r1,r0,r5
000048  4622              MOV      r2,r4
00004a  4648              MOV      r0,r9
00004c  f7fffffe          BL       __aeabi_memcpy
;;;653        NumBytesRead += NumBytesRem;
000050  44a0              ADD      r8,r8,r4
;;;654        pBuffer      += NumBytesRem;
000052  44a1              ADD      r9,r9,r4
;;;655        BufferSize   -= NumBytesRem;
000054  1b3f              SUBS     r7,r7,r4
;;;656        RdOff        += NumBytesRem;
000056  4425              ADD      r5,r5,r4
;;;657    #endif
;;;658        //
;;;659        // Handle wrap-around of buffer
;;;660        //
;;;661        if (RdOff == pRing->SizeOfBuffer) {
000058  68b0              LDR      r0,[r6,#8]
00005a  42a8              CMP      r0,r5
00005c  d100              BNE      |L16.96|
;;;662          RdOff = 0u;
00005e  2500              MOVS     r5,#0
                  |L16.96|
;;;663        }
;;;664      }
;;;665      //
;;;666      // Read remaining items of buffer
;;;667      //
;;;668      NumBytesRem = WrOff - RdOff;
000060  ebaa0405          SUB      r4,r10,r5
;;;669      NumBytesRem = MIN(NumBytesRem, BufferSize);
000064  42bc              CMP      r4,r7
000066  d201              BCS      |L16.108|
000068  4620              MOV      r0,r4
00006a  e000              B        |L16.110|
                  |L16.108|
00006c  4638              MOV      r0,r7
                  |L16.110|
00006e  4604              MOV      r4,r0
;;;670      if (NumBytesRem > 0u) {
000070  b14c              CBZ      r4,|L16.134|
;;;671    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;672        pSrc = pRing->pBuffer + RdOff;
;;;673        NumBytesRead += NumBytesRem;
;;;674        BufferSize   -= NumBytesRem;
;;;675        RdOff        += NumBytesRem;
;;;676        while (NumBytesRem--) {
;;;677          *pBuffer++ = *pSrc++;
;;;678        };
;;;679    #else
;;;680        SEGGER_RTT_MEMCPY(pBuffer, pRing->pBuffer + RdOff, NumBytesRem);
000072  6870              LDR      r0,[r6,#4]
000074  1941              ADDS     r1,r0,r5
000076  4622              MOV      r2,r4
000078  4648              MOV      r0,r9
00007a  f7fffffe          BL       __aeabi_memcpy
;;;681        NumBytesRead += NumBytesRem;
00007e  44a0              ADD      r8,r8,r4
;;;682        pBuffer      += NumBytesRem;
000080  44a1              ADD      r9,r9,r4
;;;683        BufferSize   -= NumBytesRem;
000082  1b3f              SUBS     r7,r7,r4
;;;684        RdOff        += NumBytesRem;
000084  4425              ADD      r5,r5,r4
                  |L16.134|
;;;685    #endif
;;;686      }
;;;687      if (NumBytesRead) {
000086  f1b80f00          CMP      r8,#0
00008a  d000              BEQ      |L16.142|
;;;688        pRing->RdOff = RdOff;
00008c  6135              STR      r5,[r6,#0x10]
                  |L16.142|
;;;689      }
;;;690      //
;;;691      return NumBytesRead;
00008e  4640              MOV      r0,r8
;;;692    }
000090  e8bd8ffe          POP      {r1-r11,pc}
;;;693    
                          ENDP

                  |L16.148|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_ReadUpBuffer||, CODE, READONLY, ALIGN=1

                  SEGGER_RTT_ReadUpBuffer PROC
;;;718    */
;;;719    unsigned SEGGER_RTT_ReadUpBuffer(unsigned BufferIndex, void* pBuffer, unsigned BufferSize) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;720      unsigned NumBytesRead;
;;;721      //
;;;722      SEGGER_RTT_LOCK();
00000a  f3ef8011          MRS      r0,BASEPRI
00000e  4680              MOV      r8,r0
000010  2020              MOVS     r0,#0x20
000012  f3808811          MSR      BASEPRI,r0
000016  bf00              NOP      
000018  bf00              NOP      
;;;723      //
;;;724      // Call the non-locking read function
;;;725      //
;;;726      NumBytesRead = SEGGER_RTT_ReadUpBufferNoLock(BufferIndex, pBuffer, BufferSize);
00001a  4632              MOV      r2,r6
00001c  4629              MOV      r1,r5
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       SEGGER_RTT_ReadUpBufferNoLock
000024  4607              MOV      r7,r0
;;;727      //
;;;728      // Finish up.
;;;729      //
;;;730      SEGGER_RTT_UNLOCK();
000026  f00800ff          AND      r0,r8,#0xff
00002a  f3808811          MSR      BASEPRI,r0
00002e  bf00              NOP      
000030  bf00              NOP      
;;;731      //
;;;732      return NumBytesRead;
000032  4638              MOV      r0,r7
;;;733    }
000034  e8bd81f0          POP      {r4-r8,pc}
;;;734    
                          ENDP


                          AREA ||i.SEGGER_RTT_ReadUpBufferNoLock||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_ReadUpBufferNoLock PROC
;;;525    */
;;;526    unsigned SEGGER_RTT_ReadUpBufferNoLock(unsigned BufferIndex, void* pData, unsigned BufferSize) {
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
000004  4683              MOV      r11,r0
000006  4617              MOV      r7,r2
;;;527      unsigned                NumBytesRem;
;;;528      unsigned                NumBytesRead;
;;;529      unsigned                RdOff;
;;;530      unsigned                WrOff;
;;;531      unsigned char*          pBuffer;
;;;532      SEGGER_RTT_BUFFER_UP*   pRing;
;;;533    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;534      const char*             pSrc;
;;;535    #endif
;;;536      //
;;;537      INIT();
000008  bf00              NOP      
00000a  4822              LDR      r0,|L18.148|
00000c  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000e  b908              CBNZ     r0,|L18.20|
000010  f7fffffe          BL       _DoInit
                  |L18.20|
000014  bf00              NOP      
;;;538      pRing = &_SEGGER_RTT.aUp[BufferIndex];
000016  eb0b014b          ADD      r1,r11,r11,LSL #1
00001a  481e              LDR      r0,|L18.148|
00001c  3018              ADDS     r0,r0,#0x18
00001e  eb0006c1          ADD      r6,r0,r1,LSL #3
;;;539      pBuffer = (unsigned char*)pData;
000022  f8dd9004          LDR      r9,[sp,#4]
;;;540      RdOff = pRing->RdOff;
000026  6935              LDR      r5,[r6,#0x10]
;;;541      WrOff = pRing->WrOff;
000028  f8d6a00c          LDR      r10,[r6,#0xc]
;;;542      NumBytesRead = 0u;
00002c  f04f0800          MOV      r8,#0
;;;543      //
;;;544      // Read from current read position to wrap-around of buffer, first
;;;545      //
;;;546      if (RdOff > WrOff) {
000030  4555              CMP      r5,r10
000032  d915              BLS      |L18.96|
;;;547        NumBytesRem = pRing->SizeOfBuffer - RdOff;
000034  68b0              LDR      r0,[r6,#8]
000036  1b44              SUBS     r4,r0,r5
;;;548        NumBytesRem = MIN(NumBytesRem, BufferSize);
000038  42bc              CMP      r4,r7
00003a  d201              BCS      |L18.64|
00003c  4620              MOV      r0,r4
00003e  e000              B        |L18.66|
                  |L18.64|
000040  4638              MOV      r0,r7
                  |L18.66|
000042  4604              MOV      r4,r0
;;;549    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;550        pSrc = pRing->pBuffer + RdOff;
;;;551        NumBytesRead += NumBytesRem;
;;;552        BufferSize   -= NumBytesRem;
;;;553        RdOff        += NumBytesRem;
;;;554        while (NumBytesRem--) {
;;;555          *pBuffer++ = *pSrc++;
;;;556        };
;;;557    #else
;;;558        SEGGER_RTT_MEMCPY(pBuffer, pRing->pBuffer + RdOff, NumBytesRem);
000044  6870              LDR      r0,[r6,#4]
000046  1941              ADDS     r1,r0,r5
000048  4622              MOV      r2,r4
00004a  4648              MOV      r0,r9
00004c  f7fffffe          BL       __aeabi_memcpy
;;;559        NumBytesRead += NumBytesRem;
000050  44a0              ADD      r8,r8,r4
;;;560        pBuffer      += NumBytesRem;
000052  44a1              ADD      r9,r9,r4
;;;561        BufferSize   -= NumBytesRem;
000054  1b3f              SUBS     r7,r7,r4
;;;562        RdOff        += NumBytesRem;
000056  4425              ADD      r5,r5,r4
;;;563    #endif
;;;564        //
;;;565        // Handle wrap-around of buffer
;;;566        //
;;;567        if (RdOff == pRing->SizeOfBuffer) {
000058  68b0              LDR      r0,[r6,#8]
00005a  42a8              CMP      r0,r5
00005c  d100              BNE      |L18.96|
;;;568          RdOff = 0u;
00005e  2500              MOVS     r5,#0
                  |L18.96|
;;;569        }
;;;570      }
;;;571      //
;;;572      // Read remaining items of buffer
;;;573      //
;;;574      NumBytesRem = WrOff - RdOff;
000060  ebaa0405          SUB      r4,r10,r5
;;;575      NumBytesRem = MIN(NumBytesRem, BufferSize);
000064  42bc              CMP      r4,r7
000066  d201              BCS      |L18.108|
000068  4620              MOV      r0,r4
00006a  e000              B        |L18.110|
                  |L18.108|
00006c  4638              MOV      r0,r7
                  |L18.110|
00006e  4604              MOV      r4,r0
;;;576      if (NumBytesRem > 0u) {
000070  b14c              CBZ      r4,|L18.134|
;;;577    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;578        pSrc = pRing->pBuffer + RdOff;
;;;579        NumBytesRead += NumBytesRem;
;;;580        BufferSize   -= NumBytesRem;
;;;581        RdOff        += NumBytesRem;
;;;582        while (NumBytesRem--) {
;;;583          *pBuffer++ = *pSrc++;
;;;584        };
;;;585    #else
;;;586        SEGGER_RTT_MEMCPY(pBuffer, pRing->pBuffer + RdOff, NumBytesRem);
000072  6870              LDR      r0,[r6,#4]
000074  1941              ADDS     r1,r0,r5
000076  4622              MOV      r2,r4
000078  4648              MOV      r0,r9
00007a  f7fffffe          BL       __aeabi_memcpy
;;;587        NumBytesRead += NumBytesRem;
00007e  44a0              ADD      r8,r8,r4
;;;588        pBuffer      += NumBytesRem;
000080  44a1              ADD      r9,r9,r4
;;;589        BufferSize   -= NumBytesRem;
000082  1b3f              SUBS     r7,r7,r4
;;;590        RdOff        += NumBytesRem;
000084  4425              ADD      r5,r5,r4
                  |L18.134|
;;;591    #endif
;;;592      }
;;;593      //
;;;594      // Update read offset of buffer
;;;595      //
;;;596      if (NumBytesRead) {
000086  f1b80f00          CMP      r8,#0
00008a  d000              BEQ      |L18.142|
;;;597        pRing->RdOff = RdOff;
00008c  6135              STR      r5,[r6,#0x10]
                  |L18.142|
;;;598      }
;;;599      //
;;;600      return NumBytesRead;
00008e  4640              MOV      r0,r8
;;;601    }
000090  e8bd8ffe          POP      {r1-r11,pc}
;;;602    
                          ENDP

                  |L18.148|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_SetFlagsDownBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_SetFlagsDownBuffer PROC
;;;1793   */
;;;1794   int SEGGER_RTT_SetFlagsDownBuffer(unsigned BufferIndex, unsigned Flags) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;1795     int r;
;;;1796   
;;;1797     INIT();
000006  bf00              NOP      
000008  4811              LDR      r0,|L19.80|
00000a  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000c  b908              CBNZ     r0,|L19.18|
00000e  f7fffffe          BL       _DoInit
                  |L19.18|
000012  bf00              NOP      
;;;1798     if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumDownBuffers) {
000014  480e              LDR      r0,|L19.80|
000016  6940              LDR      r0,[r0,#0x14]  ; _SEGGER_RTT
000018  42a0              CMP      r0,r4
00001a  d915              BLS      |L19.72|
;;;1799       SEGGER_RTT_LOCK();
00001c  f3ef8111          MRS      r1,BASEPRI
000020  4608              MOV      r0,r1
000022  2120              MOVS     r1,#0x20
000024  f3818811          MSR      BASEPRI,r1
000028  bf00              NOP      
00002a  bf00              NOP      
;;;1800       _SEGGER_RTT.aDown[BufferIndex].Flags = Flags;
00002c  eb040244          ADD      r2,r4,r4,LSL #1
000030  4907              LDR      r1,|L19.80|
000032  3160              ADDS     r1,r1,#0x60
000034  eb0101c2          ADD      r1,r1,r2,LSL #3
000038  614e              STR      r6,[r1,#0x14]
;;;1801       SEGGER_RTT_UNLOCK();
00003a  b2c1              UXTB     r1,r0
00003c  f3818811          MSR      BASEPRI,r1
000040  bf00              NOP      
000042  bf00              NOP      
;;;1802       r =  0;
000044  2500              MOVS     r5,#0
000046  e001              B        |L19.76|
                  |L19.72|
;;;1803     } else {
;;;1804       r = -1;
000048  f04f35ff          MOV      r5,#0xffffffff
                  |L19.76|
;;;1805     }
;;;1806     return r;
00004c  4628              MOV      r0,r5
;;;1807   }
00004e  bd70              POP      {r4-r6,pc}
;;;1808   
                          ENDP

                  |L19.80|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_SetFlagsUpBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_SetFlagsUpBuffer PROC
;;;1762   */
;;;1763   int SEGGER_RTT_SetFlagsUpBuffer(unsigned BufferIndex, unsigned Flags) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;1764     int r;
;;;1765   
;;;1766     INIT();
000006  bf00              NOP      
000008  4811              LDR      r0,|L20.80|
00000a  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000c  b908              CBNZ     r0,|L20.18|
00000e  f7fffffe          BL       _DoInit
                  |L20.18|
000012  bf00              NOP      
;;;1767     if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumUpBuffers) {
000014  480e              LDR      r0,|L20.80|
000016  6900              LDR      r0,[r0,#0x10]  ; _SEGGER_RTT
000018  42a0              CMP      r0,r4
00001a  d915              BLS      |L20.72|
;;;1768       SEGGER_RTT_LOCK();
00001c  f3ef8111          MRS      r1,BASEPRI
000020  4608              MOV      r0,r1
000022  2120              MOVS     r1,#0x20
000024  f3818811          MSR      BASEPRI,r1
000028  bf00              NOP      
00002a  bf00              NOP      
;;;1769       _SEGGER_RTT.aUp[BufferIndex].Flags = Flags;
00002c  eb040244          ADD      r2,r4,r4,LSL #1
000030  4907              LDR      r1,|L20.80|
000032  3118              ADDS     r1,r1,#0x18
000034  eb0101c2          ADD      r1,r1,r2,LSL #3
000038  614e              STR      r6,[r1,#0x14]
;;;1770       SEGGER_RTT_UNLOCK();
00003a  b2c1              UXTB     r1,r0
00003c  f3818811          MSR      BASEPRI,r1
000040  bf00              NOP      
000042  bf00              NOP      
;;;1771       r =  0;
000044  2500              MOVS     r5,#0
000046  e001              B        |L20.76|
                  |L20.72|
;;;1772     } else {
;;;1773       r = -1;
000048  f04f35ff          MOV      r5,#0xffffffff
                  |L20.76|
;;;1774     }
;;;1775     return r;
00004c  4628              MOV      r0,r5
;;;1776   }
00004e  bd70              POP      {r4-r6,pc}
;;;1777   
                          ENDP

                  |L20.80|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_SetNameDownBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_SetNameDownBuffer PROC
;;;1731   */
;;;1732   int SEGGER_RTT_SetNameDownBuffer(unsigned BufferIndex, const char* sName) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;1733     int r;
;;;1734   
;;;1735     INIT();
000006  bf00              NOP      
000008  4811              LDR      r0,|L21.80|
00000a  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000c  b908              CBNZ     r0,|L21.18|
00000e  f7fffffe          BL       _DoInit
                  |L21.18|
000012  bf00              NOP      
;;;1736     if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumDownBuffers) {
000014  480e              LDR      r0,|L21.80|
000016  6940              LDR      r0,[r0,#0x14]  ; _SEGGER_RTT
000018  42a0              CMP      r0,r4
00001a  d914              BLS      |L21.70|
;;;1737       SEGGER_RTT_LOCK();
00001c  f3ef8111          MRS      r1,BASEPRI
000020  4608              MOV      r0,r1
000022  2120              MOVS     r1,#0x20
000024  f3818811          MSR      BASEPRI,r1
000028  bf00              NOP      
00002a  bf00              NOP      
;;;1738       _SEGGER_RTT.aDown[BufferIndex].sName = sName;
00002c  eb040244          ADD      r2,r4,r4,LSL #1
000030  4907              LDR      r1,|L21.80|
000032  3160              ADDS     r1,r1,#0x60
000034  f8416032          STR      r6,[r1,r2,LSL #3]
;;;1739       SEGGER_RTT_UNLOCK();
000038  b2c1              UXTB     r1,r0
00003a  f3818811          MSR      BASEPRI,r1
00003e  bf00              NOP      
000040  bf00              NOP      
;;;1740       r =  0;
000042  2500              MOVS     r5,#0
000044  e001              B        |L21.74|
                  |L21.70|
;;;1741     } else {
;;;1742       r = -1;
000046  f04f35ff          MOV      r5,#0xffffffff
                  |L21.74|
;;;1743     }
;;;1744     return r;
00004a  4628              MOV      r0,r5
;;;1745   }
00004c  bd70              POP      {r4-r6,pc}
;;;1746   
                          ENDP

00004e  0000              DCW      0x0000
                  |L21.80|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_SetNameUpBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_SetNameUpBuffer PROC
;;;1700   */
;;;1701   int SEGGER_RTT_SetNameUpBuffer(unsigned BufferIndex, const char* sName) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;1702     int r;
;;;1703   
;;;1704     INIT();
000006  bf00              NOP      
000008  4811              LDR      r0,|L22.80|
00000a  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000c  b908              CBNZ     r0,|L22.18|
00000e  f7fffffe          BL       _DoInit
                  |L22.18|
000012  bf00              NOP      
;;;1705     if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumUpBuffers) {
000014  480e              LDR      r0,|L22.80|
000016  6900              LDR      r0,[r0,#0x10]  ; _SEGGER_RTT
000018  42a0              CMP      r0,r4
00001a  d914              BLS      |L22.70|
;;;1706       SEGGER_RTT_LOCK();
00001c  f3ef8111          MRS      r1,BASEPRI
000020  4608              MOV      r0,r1
000022  2120              MOVS     r1,#0x20
000024  f3818811          MSR      BASEPRI,r1
000028  bf00              NOP      
00002a  bf00              NOP      
;;;1707       _SEGGER_RTT.aUp[BufferIndex].sName = sName;
00002c  eb040244          ADD      r2,r4,r4,LSL #1
000030  4907              LDR      r1,|L22.80|
000032  3118              ADDS     r1,r1,#0x18
000034  f8416032          STR      r6,[r1,r2,LSL #3]
;;;1708       SEGGER_RTT_UNLOCK();
000038  b2c1              UXTB     r1,r0
00003a  f3818811          MSR      BASEPRI,r1
00003e  bf00              NOP      
000040  bf00              NOP      
;;;1709       r =  0;
000042  2500              MOVS     r5,#0
000044  e001              B        |L22.74|
                  |L22.70|
;;;1710     } else {
;;;1711       r = -1;
000046  f04f35ff          MOV      r5,#0xffffffff
                  |L22.74|
;;;1712     }
;;;1713     return r;
00004a  4628              MOV      r0,r5
;;;1714   }
00004c  bd70              POP      {r4-r6,pc}
;;;1715   
                          ENDP

00004e  0000              DCW      0x0000
                  |L22.80|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_SetTerminal||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_SetTerminal PROC
;;;1835   */
;;;1836   int SEGGER_RTT_SetTerminal (unsigned char TerminalId) {
000000  e92d43f8          PUSH     {r3-r9,lr}
000004  4604              MOV      r4,r0
;;;1837     unsigned char         ac[2];
;;;1838     SEGGER_RTT_BUFFER_UP* pRing;
;;;1839     unsigned Avail;
;;;1840     int r;
;;;1841     //
;;;1842     INIT();
000006  bf00              NOP      
000008  4821              LDR      r0,|L23.144|
00000a  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000c  b908              CBNZ     r0,|L23.18|
00000e  f7fffffe          BL       _DoInit
                  |L23.18|
000012  bf00              NOP      
;;;1843     //
;;;1844     r = 0;
000014  2700              MOVS     r7,#0
;;;1845     ac[0] = 0xFFu;
000016  20ff              MOVS     r0,#0xff
000018  f88d0000          STRB     r0,[sp,#0]
;;;1846     if (TerminalId < sizeof(_aTerminalId)) { // We only support a certain number of channels
00001c  2c10              CMP      r4,#0x10
00001e  d231              BCS      |L23.132|
;;;1847       ac[1] = _aTerminalId[TerminalId];
000020  481c              LDR      r0,|L23.148|
000022  5d00              LDRB     r0,[r0,r4]
000024  f88d0001          STRB     r0,[sp,#1]
;;;1848       pRing = &_SEGGER_RTT.aUp[0];    // Buffer 0 is always reserved for terminal I/O, so we can use index 0 here, fixed
000028  4d19              LDR      r5,|L23.144|
00002a  3518              ADDS     r5,r5,#0x18
;;;1849       SEGGER_RTT_LOCK();    // Lock to make sure that no other task is writing into buffer, while we are and number of free bytes in buffer does not change downwards after checking and before writing
00002c  f3ef8011          MRS      r0,BASEPRI
000030  4680              MOV      r8,r0
000032  2020              MOVS     r0,#0x20
000034  f3808811          MSR      BASEPRI,r0
000038  bf00              NOP      
00003a  bf00              NOP      
;;;1850       if ((pRing->Flags & SEGGER_RTT_MODE_MASK) == SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL) {
00003c  7d28              LDRB     r0,[r5,#0x14]
00003e  f0000003          AND      r0,r0,#3
000042  2802              CMP      r0,#2
000044  d107              BNE      |L23.86|
;;;1851         _ActiveTerminal = TerminalId;
000046  4814              LDR      r0,|L23.152|
000048  7004              STRB     r4,[r0,#0]
;;;1852         _WriteBlocking(pRing, (const char*)ac, 2u);
00004a  2202              MOVS     r2,#2
00004c  4669              MOV      r1,sp
00004e  4628              MOV      r0,r5
000050  f7fffffe          BL       _WriteBlocking
000054  e00f              B        |L23.118|
                  |L23.86|
;;;1853       } else {                                                                            // Skipping mode or trim mode? => We cannot trim this command so handling is the same for both modes
;;;1854         Avail = _GetAvailWriteSpace(pRing);
000056  4628              MOV      r0,r5
000058  f7fffffe          BL       _GetAvailWriteSpace
00005c  4606              MOV      r6,r0
;;;1855         if (Avail >= 2) {
00005e  2e02              CMP      r6,#2
000060  d307              BCC      |L23.114|
;;;1856           _ActiveTerminal = TerminalId;    // Only change active terminal in case of success
000062  480d              LDR      r0,|L23.152|
000064  7004              STRB     r4,[r0,#0]
;;;1857           _WriteNoCheck(pRing, (const char*)ac, 2u);
000066  2202              MOVS     r2,#2
000068  4669              MOV      r1,sp
00006a  4628              MOV      r0,r5
00006c  f7fffffe          BL       _WriteNoCheck
000070  e001              B        |L23.118|
                  |L23.114|
;;;1858         } else {
;;;1859           r = -1;
000072  f04f37ff          MOV      r7,#0xffffffff
                  |L23.118|
;;;1860         }
;;;1861       }
;;;1862       SEGGER_RTT_UNLOCK();
000076  f00800ff          AND      r0,r8,#0xff
00007a  f3808811          MSR      BASEPRI,r0
00007e  bf00              NOP      
000080  bf00              NOP      
000082  e001              B        |L23.136|
                  |L23.132|
;;;1863     } else {
;;;1864       r = -1;
000084  f04f37ff          MOV      r7,#0xffffffff
                  |L23.136|
;;;1865     }
;;;1866     return r;
000088  4638              MOV      r0,r7
;;;1867   }
00008a  e8bd83f8          POP      {r3-r9,pc}
;;;1868   
                          ENDP

00008e  0000              DCW      0x0000
                  |L23.144|
                          DCD      _SEGGER_RTT
                  |L23.148|
                          DCD      _aTerminalId
                  |L23.152|
                          DCD      _ActiveTerminal

                          AREA ||i.SEGGER_RTT_TerminalOut||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_TerminalOut PROC
;;;1885   */
;;;1886   int SEGGER_RTT_TerminalOut (unsigned char TerminalId, const char* s) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4607              MOV      r7,r0
000006  4689              MOV      r9,r1
;;;1887     int                   Status;
;;;1888     unsigned              FragLen;
;;;1889     unsigned              Avail;
;;;1890     SEGGER_RTT_BUFFER_UP* pRing;
;;;1891     //
;;;1892     INIT();
000008  bf00              NOP      
00000a  483b              LDR      r0,|L24.248|
00000c  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000e  b908              CBNZ     r0,|L24.20|
000010  f7fffffe          BL       _DoInit
                  |L24.20|
000014  bf00              NOP      
;;;1893     //
;;;1894     // Validate terminal ID.
;;;1895     //
;;;1896     if (TerminalId < (char)sizeof(_aTerminalId)) { // We only support a certain number of channels
000016  2f10              CMP      r7,#0x10
000018  da68              BGE      |L24.236|
;;;1897       //
;;;1898       // Get "to-host" ring buffer.
;;;1899       //
;;;1900       pRing = &_SEGGER_RTT.aUp[0];
00001a  f8df80dc          LDR      r8,|L24.248|
00001e  f1080818          ADD      r8,r8,#0x18
;;;1901       //
;;;1902       // Need to be able to change terminal, write data, change back.
;;;1903       // Compute the fixed and variable sizes.
;;;1904       //
;;;1905       FragLen = STRLEN(s);
000022  4648              MOV      r0,r9
000024  f7fffffe          BL       strlen
000028  4606              MOV      r6,r0
;;;1906       //
;;;1907       // How we output depends upon the mode...
;;;1908       //
;;;1909       SEGGER_RTT_LOCK();
00002a  f3ef8011          MRS      r0,BASEPRI
00002e  4682              MOV      r10,r0
000030  2020              MOVS     r0,#0x20
000032  f3808811          MSR      BASEPRI,r0
000036  bf00              NOP      
000038  bf00              NOP      
;;;1910       Avail = _GetAvailWriteSpace(pRing);
00003a  4640              MOV      r0,r8
00003c  f7fffffe          BL       _GetAvailWriteSpace
000040  4605              MOV      r5,r0
;;;1911       switch (pRing->Flags & SEGGER_RTT_MODE_MASK) {
000042  f8980014          LDRB     r0,[r8,#0x14]
000046  f0000003          AND      r0,r0,#3
00004a  b120              CBZ      r0,|L24.86|
00004c  2801              CMP      r0,#1
00004e  d017              BEQ      |L24.128|
000050  2802              CMP      r0,#2
000052  d140              BNE      |L24.214|
000054  e02f              B        |L24.182|
                  |L24.86|
;;;1912       case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
;;;1913         //
;;;1914         // If we are in skip mode and there is no space for the whole
;;;1915         // of this output, don't bother switching terminals at all.
;;;1916         //
;;;1917         if (Avail < (FragLen + 4u)) {
000056  1d30              ADDS     r0,r6,#4
000058  4285              CMP      r5,r0
00005a  d201              BCS      |L24.96|
;;;1918           Status = 0;
00005c  2400              MOVS     r4,#0
00005e  e00e              B        |L24.126|
                  |L24.96|
;;;1919         } else {
;;;1920           _PostTerminalSwitch(pRing, TerminalId);
000060  4639              MOV      r1,r7
000062  4640              MOV      r0,r8
000064  f7fffffe          BL       _PostTerminalSwitch
;;;1921           Status = (int)_WriteBlocking(pRing, s, FragLen);
000068  4632              MOV      r2,r6
00006a  4649              MOV      r1,r9
00006c  4640              MOV      r0,r8
00006e  f7fffffe          BL       _WriteBlocking
000072  4604              MOV      r4,r0
;;;1922           _PostTerminalSwitch(pRing, _ActiveTerminal);
000074  4821              LDR      r0,|L24.252|
000076  7801              LDRB     r1,[r0,#0]  ; _ActiveTerminal
000078  4640              MOV      r0,r8
00007a  f7fffffe          BL       _PostTerminalSwitch
                  |L24.126|
;;;1923         }
;;;1924         break;
00007e  e02d              B        |L24.220|
                  |L24.128|
;;;1925       case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
;;;1926         //
;;;1927         // If we are in trim mode and there is not enough space for everything,
;;;1928         // trim the output but always include the terminal switch.  If no room
;;;1929         // for terminal switch, skip that totally.
;;;1930         //
;;;1931         if (Avail < 4u) {
000080  2d04              CMP      r5,#4
000082  d202              BCS      |L24.138|
;;;1932           Status = -1;
000084  f04f34ff          MOV      r4,#0xffffffff
000088  e014              B        |L24.180|
                  |L24.138|
;;;1933         } else {
;;;1934           _PostTerminalSwitch(pRing, TerminalId);
00008a  4639              MOV      r1,r7
00008c  4640              MOV      r0,r8
00008e  f7fffffe          BL       _PostTerminalSwitch
;;;1935           Status = (int)_WriteBlocking(pRing, s, (FragLen < (Avail - 4u)) ? FragLen : (Avail - 4u));
000092  1f28              SUBS     r0,r5,#4
000094  42b0              CMP      r0,r6
000096  d901              BLS      |L24.156|
000098  4630              MOV      r0,r6
00009a  e000              B        |L24.158|
                  |L24.156|
00009c  1f28              SUBS     r0,r5,#4
                  |L24.158|
00009e  4602              MOV      r2,r0
0000a0  4649              MOV      r1,r9
0000a2  4640              MOV      r0,r8
0000a4  f7fffffe          BL       _WriteBlocking
0000a8  4604              MOV      r4,r0
;;;1936           _PostTerminalSwitch(pRing, _ActiveTerminal);
0000aa  4814              LDR      r0,|L24.252|
0000ac  7801              LDRB     r1,[r0,#0]  ; _ActiveTerminal
0000ae  4640              MOV      r0,r8
0000b0  f7fffffe          BL       _PostTerminalSwitch
                  |L24.180|
;;;1937         }
;;;1938         break;
0000b4  e012              B        |L24.220|
                  |L24.182|
;;;1939       case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
;;;1940         //
;;;1941         // If we are in blocking mode, output everything.
;;;1942         //
;;;1943         _PostTerminalSwitch(pRing, TerminalId);
0000b6  4639              MOV      r1,r7
0000b8  4640              MOV      r0,r8
0000ba  f7fffffe          BL       _PostTerminalSwitch
;;;1944         Status = (int)_WriteBlocking(pRing, s, FragLen);
0000be  4632              MOV      r2,r6
0000c0  4649              MOV      r1,r9
0000c2  4640              MOV      r0,r8
0000c4  f7fffffe          BL       _WriteBlocking
0000c8  4604              MOV      r4,r0
;;;1945         _PostTerminalSwitch(pRing, _ActiveTerminal);
0000ca  480c              LDR      r0,|L24.252|
0000cc  7801              LDRB     r1,[r0,#0]  ; _ActiveTerminal
0000ce  4640              MOV      r0,r8
0000d0  f7fffffe          BL       _PostTerminalSwitch
;;;1946         break;
0000d4  e002              B        |L24.220|
                  |L24.214|
;;;1947       default:
;;;1948         Status = -1;
0000d6  f04f34ff          MOV      r4,#0xffffffff
;;;1949         break;
0000da  bf00              NOP      
                  |L24.220|
0000dc  bf00              NOP                            ;1924
;;;1950       }
;;;1951       //
;;;1952       // Finish up.
;;;1953       //
;;;1954       SEGGER_RTT_UNLOCK();
0000de  f00a00ff          AND      r0,r10,#0xff
0000e2  f3808811          MSR      BASEPRI,r0
0000e6  bf00              NOP      
0000e8  bf00              NOP      
0000ea  e001              B        |L24.240|
                  |L24.236|
;;;1955     } else {
;;;1956       Status = -1;
0000ec  f04f34ff          MOV      r4,#0xffffffff
                  |L24.240|
;;;1957     }
;;;1958     return Status;
0000f0  4620              MOV      r0,r4
;;;1959   }
0000f2  e8bd87f0          POP      {r4-r10,pc}
;;;1960   
                          ENDP

0000f6  0000              DCW      0x0000
                  |L24.248|
                          DCD      _SEGGER_RTT
                  |L24.252|
                          DCD      _ActiveTerminal

                          AREA ||i.SEGGER_RTT_WaitKey||, CODE, READONLY, ALIGN=1

                  SEGGER_RTT_WaitKey PROC
;;;1421   */
;;;1422   int SEGGER_RTT_WaitKey(void) {
000000  b510              PUSH     {r4,lr}
;;;1423     int r;
;;;1424   
;;;1425     do {
000002  bf00              NOP      
                  |L25.4|
;;;1426       r = SEGGER_RTT_GetKey();
000004  f7fffffe          BL       SEGGER_RTT_GetKey
;;;1427     } while (r < 0);
000008  2800              CMP      r0,#0
00000a  dbfb              BLT      |L25.4|
;;;1428     return r;
;;;1429   }
00000c  bd10              POP      {r4,pc}
;;;1430   
                          ENDP


                          AREA ||i.SEGGER_RTT_Write||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_Write PROC
;;;1162   */
;;;1163   unsigned SEGGER_RTT_Write(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;1164     unsigned Status;
;;;1165     //
;;;1166     INIT();
00000a  bf00              NOP      
00000c  480d              LDR      r0,|L26.68|
00000e  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
000010  b908              CBNZ     r0,|L26.22|
000012  f7fffffe          BL       _DoInit
                  |L26.22|
000016  bf00              NOP      
;;;1167     SEGGER_RTT_LOCK();
000018  f3ef8011          MRS      r0,BASEPRI
00001c  4607              MOV      r7,r0
00001e  2020              MOVS     r0,#0x20
000020  f3808811          MSR      BASEPRI,r0
000024  bf00              NOP      
000026  bf00              NOP      
;;;1168     //
;;;1169     // Call the non-locking write function
;;;1170     //
;;;1171     Status = SEGGER_RTT_WriteNoLock(BufferIndex, pBuffer, NumBytes);
000028  4632              MOV      r2,r6
00002a  4629              MOV      r1,r5
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       SEGGER_RTT_WriteNoLock
000032  4680              MOV      r8,r0
;;;1172     //
;;;1173     // Finish up.
;;;1174     //
;;;1175     SEGGER_RTT_UNLOCK();
000034  b2f8              UXTB     r0,r7
000036  f3808811          MSR      BASEPRI,r0
00003a  bf00              NOP      
00003c  bf00              NOP      
;;;1176     //
;;;1177     return Status;
00003e  4640              MOV      r0,r8
;;;1178   }
000040  e8bd81f0          POP      {r4-r8,pc}
;;;1179   
                          ENDP

                  |L26.68|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_WriteDownBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_WriteDownBuffer PROC
;;;1126   */
;;;1127   unsigned SEGGER_RTT_WriteDownBuffer(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;1128     unsigned Status;
;;;1129     //
;;;1130     INIT();
00000a  bf00              NOP      
00000c  480d              LDR      r0,|L27.68|
00000e  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
000010  b908              CBNZ     r0,|L27.22|
000012  f7fffffe          BL       _DoInit
                  |L27.22|
000016  bf00              NOP      
;;;1131     SEGGER_RTT_LOCK();
000018  f3ef8011          MRS      r0,BASEPRI
00001c  4607              MOV      r7,r0
00001e  2020              MOVS     r0,#0x20
000020  f3808811          MSR      BASEPRI,r0
000024  bf00              NOP      
000026  bf00              NOP      
;;;1132     //
;;;1133     // Call the non-locking write function
;;;1134     //
;;;1135     Status = SEGGER_RTT_WriteDownBufferNoLock(BufferIndex, pBuffer, NumBytes);
000028  4632              MOV      r2,r6
00002a  4629              MOV      r1,r5
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       SEGGER_RTT_WriteDownBufferNoLock
000032  4680              MOV      r8,r0
;;;1136     //
;;;1137     // Finish up.
;;;1138     //
;;;1139     SEGGER_RTT_UNLOCK();
000034  b2f8              UXTB     r0,r7
000036  f3808811          MSR      BASEPRI,r0
00003a  bf00              NOP      
00003c  bf00              NOP      
;;;1140     //
;;;1141     return Status;
00003e  4640              MOV      r0,r8
;;;1142   }
000040  e8bd81f0          POP      {r4-r8,pc}
;;;1143   
                          ENDP

                  |L27.68|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_WriteDownBufferNoLock||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_WriteDownBufferNoLock PROC
;;;973    */
;;;974    unsigned SEGGER_RTT_WriteDownBufferNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
;;;975      unsigned                Status;
;;;976      unsigned                Avail;
;;;977      const char*             pData;
;;;978      SEGGER_RTT_BUFFER_UP*   pRing;
;;;979    
;;;980      pData = (const char *)pBuffer;
00000a  46c2              MOV      r10,r8
;;;981      //
;;;982      // Get "to-target" ring buffer.
;;;983      // It is save to cast that to a "to-host" buffer. Up and Down buffer differ in volatility of offsets that might be modified by J-Link.
;;;984      //
;;;985      pRing = (SEGGER_RTT_BUFFER_UP*)&_SEGGER_RTT.aDown[BufferIndex];
00000c  eb070147          ADD      r1,r7,r7,LSL #1
000010  481b              LDR      r0,|L28.128|
000012  eb0009c1          ADD      r9,r0,r1,LSL #3
;;;986      //
;;;987      // How we output depends upon the mode...
;;;988      //
;;;989      switch (pRing->Flags) {
000016  f8d90014          LDR      r0,[r9,#0x14]
00001a  b120              CBZ      r0,|L28.38|
00001c  2801              CMP      r0,#1
00001e  d011              BEQ      |L28.68|
000020  2802              CMP      r0,#2
000022  d126              BNE      |L28.114|
000024  e01e              B        |L28.100|
                  |L28.38|
;;;990      case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
;;;991        //
;;;992        // If we are in skip mode and there is no space for the whole
;;;993        // of this output, don't bother.
;;;994        //
;;;995        Avail = _GetAvailWriteSpace(pRing);
000026  4648              MOV      r0,r9
000028  f7fffffe          BL       _GetAvailWriteSpace
00002c  4605              MOV      r5,r0
;;;996        if (Avail < NumBytes) {
00002e  42b5              CMP      r5,r6
000030  d201              BCS      |L28.54|
;;;997          Status = 0u;
000032  2400              MOVS     r4,#0
000034  e005              B        |L28.66|
                  |L28.54|
;;;998        } else {
;;;999          Status = NumBytes;
000036  4634              MOV      r4,r6
;;;1000         _WriteNoCheck(pRing, pData, NumBytes);
000038  4632              MOV      r2,r6
00003a  4651              MOV      r1,r10
00003c  4648              MOV      r0,r9
00003e  f7fffffe          BL       _WriteNoCheck
                  |L28.66|
;;;1001       }
;;;1002       break;
000042  e018              B        |L28.118|
                  |L28.68|
;;;1003     case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
;;;1004       //
;;;1005       // If we are in trim mode, trim to what we can output without blocking.
;;;1006       //
;;;1007       Avail = _GetAvailWriteSpace(pRing);
000044  4648              MOV      r0,r9
000046  f7fffffe          BL       _GetAvailWriteSpace
00004a  4605              MOV      r5,r0
;;;1008       Status = Avail < NumBytes ? Avail : NumBytes;
00004c  42b5              CMP      r5,r6
00004e  d201              BCS      |L28.84|
000050  4628              MOV      r0,r5
000052  e000              B        |L28.86|
                  |L28.84|
000054  4630              MOV      r0,r6
                  |L28.86|
000056  4604              MOV      r4,r0
;;;1009       _WriteNoCheck(pRing, pData, Status);
000058  4622              MOV      r2,r4
00005a  4651              MOV      r1,r10
00005c  4648              MOV      r0,r9
00005e  f7fffffe          BL       _WriteNoCheck
;;;1010       break;
000062  e008              B        |L28.118|
                  |L28.100|
;;;1011     case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
;;;1012       //
;;;1013       // If we are in blocking mode, output everything.
;;;1014       //
;;;1015       Status = _WriteBlocking(pRing, pData, NumBytes);
000064  4632              MOV      r2,r6
000066  4651              MOV      r1,r10
000068  4648              MOV      r0,r9
00006a  f7fffffe          BL       _WriteBlocking
00006e  4604              MOV      r4,r0
;;;1016       break;
000070  e001              B        |L28.118|
                  |L28.114|
;;;1017     default:
;;;1018       Status = 0u;
000072  2400              MOVS     r4,#0
;;;1019       break;
000074  bf00              NOP      
                  |L28.118|
000076  bf00              NOP                            ;1002
;;;1020     }
;;;1021     //
;;;1022     // Finish up.
;;;1023     //
;;;1024     return Status;
000078  4620              MOV      r0,r4
;;;1025   }
00007a  e8bd87f0          POP      {r4-r10,pc}
;;;1026   
                          ENDP

00007e  0000              DCW      0x0000
                  |L28.128|
                          DCD      _SEGGER_RTT+0x60

                          AREA ||i.SEGGER_RTT_WriteNoLock||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_WriteNoLock PROC
;;;1049   */
;;;1050   unsigned SEGGER_RTT_WriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
;;;1051     unsigned              Status;
;;;1052     unsigned              Avail;
;;;1053     const char*           pData;
;;;1054     SEGGER_RTT_BUFFER_UP* pRing;
;;;1055   
;;;1056     pData = (const char *)pBuffer;
00000a  46c2              MOV      r10,r8
;;;1057     //
;;;1058     // Get "to-host" ring buffer.
;;;1059     //
;;;1060     pRing = &_SEGGER_RTT.aUp[BufferIndex];
00000c  eb070147          ADD      r1,r7,r7,LSL #1
000010  481b              LDR      r0,|L29.128|
000012  eb0009c1          ADD      r9,r0,r1,LSL #3
;;;1061     //
;;;1062     // How we output depends upon the mode...
;;;1063     //
;;;1064     switch (pRing->Flags) {
000016  f8d90014          LDR      r0,[r9,#0x14]
00001a  b120              CBZ      r0,|L29.38|
00001c  2801              CMP      r0,#1
00001e  d011              BEQ      |L29.68|
000020  2802              CMP      r0,#2
000022  d126              BNE      |L29.114|
000024  e01e              B        |L29.100|
                  |L29.38|
;;;1065     case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
;;;1066       //
;;;1067       // If we are in skip mode and there is no space for the whole
;;;1068       // of this output, don't bother.
;;;1069       //
;;;1070       Avail = _GetAvailWriteSpace(pRing);
000026  4648              MOV      r0,r9
000028  f7fffffe          BL       _GetAvailWriteSpace
00002c  4605              MOV      r5,r0
;;;1071       if (Avail < NumBytes) {
00002e  42b5              CMP      r5,r6
000030  d201              BCS      |L29.54|
;;;1072         Status = 0u;
000032  2400              MOVS     r4,#0
000034  e005              B        |L29.66|
                  |L29.54|
;;;1073       } else {
;;;1074         Status = NumBytes;
000036  4634              MOV      r4,r6
;;;1075         _WriteNoCheck(pRing, pData, NumBytes);
000038  4632              MOV      r2,r6
00003a  4651              MOV      r1,r10
00003c  4648              MOV      r0,r9
00003e  f7fffffe          BL       _WriteNoCheck
                  |L29.66|
;;;1076       }
;;;1077       break;
000042  e018              B        |L29.118|
                  |L29.68|
;;;1078     case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
;;;1079       //
;;;1080       // If we are in trim mode, trim to what we can output without blocking.
;;;1081       //
;;;1082       Avail = _GetAvailWriteSpace(pRing);
000044  4648              MOV      r0,r9
000046  f7fffffe          BL       _GetAvailWriteSpace
00004a  4605              MOV      r5,r0
;;;1083       Status = Avail < NumBytes ? Avail : NumBytes;
00004c  42b5              CMP      r5,r6
00004e  d201              BCS      |L29.84|
000050  4628              MOV      r0,r5
000052  e000              B        |L29.86|
                  |L29.84|
000054  4630              MOV      r0,r6
                  |L29.86|
000056  4604              MOV      r4,r0
;;;1084       _WriteNoCheck(pRing, pData, Status);
000058  4622              MOV      r2,r4
00005a  4651              MOV      r1,r10
00005c  4648              MOV      r0,r9
00005e  f7fffffe          BL       _WriteNoCheck
;;;1085       break;
000062  e008              B        |L29.118|
                  |L29.100|
;;;1086     case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
;;;1087       //
;;;1088       // If we are in blocking mode, output everything.
;;;1089       //
;;;1090       Status = _WriteBlocking(pRing, pData, NumBytes);
000064  4632              MOV      r2,r6
000066  4651              MOV      r1,r10
000068  4648              MOV      r0,r9
00006a  f7fffffe          BL       _WriteBlocking
00006e  4604              MOV      r4,r0
;;;1091       break;
000070  e001              B        |L29.118|
                  |L29.114|
;;;1092     default:
;;;1093       Status = 0u;
000072  2400              MOVS     r4,#0
;;;1094       break;
000074  bf00              NOP      
                  |L29.118|
000076  bf00              NOP                            ;1077
;;;1095     }
;;;1096     //
;;;1097     // Finish up.
;;;1098     //
;;;1099     return Status;
000078  4620              MOV      r0,r4
;;;1100   }
00007a  e8bd87f0          POP      {r4-r10,pc}
;;;1101   
                          ENDP

00007e  0000              DCW      0x0000
                  |L29.128|
                          DCD      _SEGGER_RTT+0x18

                          AREA ||i.SEGGER_RTT_WriteSkipNoLock||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_WriteSkipNoLock PROC
;;;889    #if (RTT_USE_ASM == 0)
;;;890    unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
000000  e92d4ff8          PUSH     {r3-r11,lr}
000004  4682              MOV      r10,r0
000006  468b              MOV      r11,r1
000008  4615              MOV      r5,r2
;;;891      const char*           pData;
;;;892      SEGGER_RTT_BUFFER_UP* pRing;
;;;893      unsigned              Avail;
;;;894      unsigned              RdOff;
;;;895      unsigned              WrOff;
;;;896      unsigned              Rem;
;;;897      //
;;;898      // Cases:
;;;899      //   1) RdOff <= WrOff => Space until wrap-around is sufficient
;;;900      //   2) RdOff <= WrOff => Space after wrap-around needed (copy in 2 chunks)
;;;901      //   3) RdOff <  WrOff => No space in buf
;;;902      //   4) RdOff >  WrOff => Space is sufficient
;;;903      //   5) RdOff >  WrOff => No space in buf
;;;904      //
;;;905      // 1) is the most common case for large buffers and assuming that J-Link reads the data fast enough
;;;906      //
;;;907      pData = (const char *)pBuffer;
00000a  f8cdb000          STR      r11,[sp,#0]
;;;908      pRing = &_SEGGER_RTT.aUp[BufferIndex];
00000e  eb0a014a          ADD      r1,r10,r10,LSL #1
000012  481d              LDR      r0,|L30.136|
000014  eb0004c1          ADD      r4,r0,r1,LSL #3
;;;909      RdOff = pRing->RdOff;
000018  f8d49010          LDR      r9,[r4,#0x10]
;;;910      WrOff = pRing->WrOff;
00001c  68e6              LDR      r6,[r4,#0xc]
;;;911      if (RdOff <= WrOff) {                                 // Case 1), 2) or 3)
00001e  45b1              CMP      r9,r6
000020  d829              BHI      |L30.118|
;;;912        Avail = pRing->SizeOfBuffer - WrOff - 1u;           // Space until wrap-around (assume 1 byte not usable for case that RdOff == 0)
000022  68a0              LDR      r0,[r4,#8]
000024  1b80              SUBS     r0,r0,r6
000026  1e47              SUBS     r7,r0,#1
;;;913        if (Avail >= NumBytes) {                            // Case 1)?
000028  42af              CMP      r7,r5
00002a  d30b              BCC      |L30.68|
;;;914    CopyStraight:
00002c  bf00              NOP      
                  |L30.46|
;;;915          memcpy(pRing->pBuffer + WrOff, pData, NumBytes);
00002e  6861              LDR      r1,[r4,#4]
000030  1988              ADDS     r0,r1,r6
000032  462a              MOV      r2,r5
000034  9900              LDR      r1,[sp,#0]
000036  f7fffffe          BL       __aeabi_memcpy
;;;916          pRing->WrOff = WrOff + NumBytes;
00003a  1970              ADDS     r0,r6,r5
00003c  60e0              STR      r0,[r4,#0xc]
;;;917          return 1;
00003e  2001              MOVS     r0,#1
                  |L30.64|
;;;918        }
;;;919        Avail += RdOff;                                     // Space incl. wrap-around
;;;920        if (Avail >= NumBytes) {                            // Case 2? => If not, we have case 3) (does not fit)
;;;921          Rem = pRing->SizeOfBuffer - WrOff;                // Space until end of buffer
;;;922          memcpy(pRing->pBuffer + WrOff, pData, Rem);       // Copy 1st chunk
;;;923          NumBytes -= Rem;
;;;924          //
;;;925          // Special case: First check that assumed RdOff == 0 calculated that last element before wrap-around could not be used
;;;926          // But 2nd check (considering space until wrap-around and until RdOff) revealed that RdOff is not 0, so we can use the last element
;;;927          // In this case, we may use a copy straight until buffer end anyway without needing to copy 2 chunks
;;;928          // Therefore, check if 2nd memcpy is necessary at all
;;;929          //
;;;930          if (NumBytes) {
;;;931            memcpy(pRing->pBuffer, pData + Rem, NumBytes);
;;;932          }
;;;933          pRing->WrOff = NumBytes;
;;;934          return 1;
;;;935        }
;;;936      } else {                                             // Potential case 4)
;;;937        Avail = RdOff - WrOff - 1u;
;;;938        if (Avail >= NumBytes) {                           // Case 4)? => If not, we have case 5) (does not fit)
;;;939          goto CopyStraight;
;;;940        }
;;;941      }
;;;942      return 0;     // No space in buffer
;;;943    }
000040  e8bd8ff8          POP      {r3-r11,pc}
                  |L30.68|
000044  444f              ADD      r7,r7,r9              ;919
000046  42af              CMP      r7,r5                 ;920
000048  d31b              BCC      |L30.130|
00004a  68a0              LDR      r0,[r4,#8]            ;921
00004c  eba00806          SUB      r8,r0,r6              ;921
000050  6861              LDR      r1,[r4,#4]            ;922
000052  1988              ADDS     r0,r1,r6              ;922
000054  4642              MOV      r2,r8                 ;922
000056  9900              LDR      r1,[sp,#0]            ;922
000058  f7fffffe          BL       __aeabi_memcpy
00005c  eba50508          SUB      r5,r5,r8              ;923
000060  b135              CBZ      r5,|L30.112|
000062  9a00              LDR      r2,[sp,#0]            ;931
000064  eb020108          ADD      r1,r2,r8              ;931
000068  462a              MOV      r2,r5                 ;931
00006a  6860              LDR      r0,[r4,#4]            ;931
00006c  f7fffffe          BL       __aeabi_memcpy
                  |L30.112|
000070  60e5              STR      r5,[r4,#0xc]          ;933
000072  2001              MOVS     r0,#1                 ;934
000074  e7e4              B        |L30.64|
                  |L30.118|
000076  eba90006          SUB      r0,r9,r6              ;937
00007a  1e47              SUBS     r7,r0,#1              ;937
00007c  42af              CMP      r7,r5                 ;938
00007e  d300              BCC      |L30.130|
000080  e7d5              B        |L30.46|
                  |L30.130|
000082  2000              MOVS     r0,#0                 ;942
000084  e7dc              B        |L30.64|
;;;944    #endif
                          ENDP

000086  0000              DCW      0x0000
                  |L30.136|
                          DCD      _SEGGER_RTT+0x18

                          AREA ||i.SEGGER_RTT_WriteString||, CODE, READONLY, ALIGN=1

                  SEGGER_RTT_WriteString PROC
;;;1199   */
;;;1200   unsigned SEGGER_RTT_WriteString(unsigned BufferIndex, const char* s) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1201     unsigned Len;
;;;1202   
;;;1203     Len = STRLEN(s);
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       strlen
00000c  4606              MOV      r6,r0
;;;1204     return SEGGER_RTT_Write(BufferIndex, s, Len);
00000e  4632              MOV      r2,r6
000010  4621              MOV      r1,r4
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       SEGGER_RTT_Write
;;;1205   }
000018  bd70              POP      {r4-r6,pc}
;;;1206   
                          ENDP


                          AREA ||i.SEGGER_RTT_WriteWithOverwriteNoLock||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_WriteWithOverwriteNoLock PROC
;;;789    */
;;;790    void SEGGER_RTT_WriteWithOverwriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
;;;791      const char*           pData;
;;;792      SEGGER_RTT_BUFFER_UP* pRing;
;;;793      unsigned              Avail;
;;;794    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;795      char*                 pDst;
;;;796    #endif
;;;797    
;;;798      pData = (const char *)pBuffer;
00000a  46c1              MOV      r9,r8
;;;799      //
;;;800      // Get "to-host" ring buffer and copy some elements into local variables.
;;;801      //
;;;802      pRing = &_SEGGER_RTT.aUp[BufferIndex];
00000c  eb070147          ADD      r1,r7,r7,LSL #1
000010  4825              LDR      r0,|L32.168|
000012  eb0004c1          ADD      r4,r0,r1,LSL #3
;;;803      //
;;;804      // Check if we will overwrite data and need to adjust the RdOff.
;;;805      //
;;;806      if (pRing->WrOff == pRing->RdOff) {
000016  e9d40103          LDRD     r0,r1,[r4,#0xc]
00001a  4288              CMP      r0,r1
00001c  d102              BNE      |L32.36|
;;;807        Avail = pRing->SizeOfBuffer - 1u;
00001e  68a0              LDR      r0,[r4,#8]
000020  1e45              SUBS     r5,r0,#1
000022  e00e              B        |L32.66|
                  |L32.36|
;;;808      } else if ( pRing->WrOff < pRing->RdOff) {
000024  e9d40103          LDRD     r0,r1,[r4,#0xc]
000028  4288              CMP      r0,r1
00002a  d204              BCS      |L32.54|
;;;809        Avail = pRing->RdOff - pRing->WrOff - 1u;
00002c  6920              LDR      r0,[r4,#0x10]
00002e  68e1              LDR      r1,[r4,#0xc]
000030  1a40              SUBS     r0,r0,r1
000032  1e45              SUBS     r5,r0,#1
000034  e005              B        |L32.66|
                  |L32.54|
;;;810      } else {
;;;811        Avail = pRing->RdOff - pRing->WrOff - 1u + pRing->SizeOfBuffer;
000036  6920              LDR      r0,[r4,#0x10]
000038  68e1              LDR      r1,[r4,#0xc]
00003a  1a40              SUBS     r0,r0,r1
00003c  1e40              SUBS     r0,r0,#1
00003e  68a1              LDR      r1,[r4,#8]
000040  1845              ADDS     r5,r0,r1
                  |L32.66|
;;;812      }
;;;813      if (NumBytes > Avail) {
000042  42ae              CMP      r6,r5
000044  d90c              BLS      |L32.96|
;;;814        pRing->RdOff += (NumBytes - Avail);
000046  6920              LDR      r0,[r4,#0x10]
000048  1b71              SUBS     r1,r6,r5
00004a  4408              ADD      r0,r0,r1
00004c  6120              STR      r0,[r4,#0x10]
;;;815        while (pRing->RdOff >= pRing->SizeOfBuffer) {
00004e  e003              B        |L32.88|
                  |L32.80|
;;;816          pRing->RdOff -= pRing->SizeOfBuffer;
000050  6920              LDR      r0,[r4,#0x10]
000052  68a1              LDR      r1,[r4,#8]
000054  1a40              SUBS     r0,r0,r1
000056  6120              STR      r0,[r4,#0x10]
                  |L32.88|
000058  6920              LDR      r0,[r4,#0x10]         ;815
00005a  68a1              LDR      r1,[r4,#8]            ;815
00005c  4288              CMP      r0,r1                 ;815
00005e  d2f7              BCS      |L32.80|
                  |L32.96|
;;;817        }
;;;818      }
;;;819      //
;;;820      // Write all data, no need to check the RdOff, but possibly handle multiple wrap-arounds
;;;821      //
;;;822      Avail = pRing->SizeOfBuffer - pRing->WrOff;
000060  e9d40102          LDRD     r0,r1,[r4,#8]
000064  1a45              SUBS     r5,r0,r1
;;;823      do {
000066  bf00              NOP      
                  |L32.104|
;;;824        if (Avail > NumBytes) {
000068  42b5              CMP      r5,r6
00006a  d90a              BLS      |L32.130|
;;;825          //
;;;826          // Last round
;;;827          //
;;;828    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;829          pDst = pRing->pBuffer + pRing->WrOff;
;;;830          Avail = NumBytes;
;;;831          while (NumBytes--) {
;;;832            *pDst++ = *pData++;
;;;833          };
;;;834          pRing->WrOff += Avail;
;;;835    #else
;;;836          SEGGER_RTT_MEMCPY(pRing->pBuffer + pRing->WrOff, pData, NumBytes);
00006c  68e2              LDR      r2,[r4,#0xc]
00006e  6861              LDR      r1,[r4,#4]
000070  1888              ADDS     r0,r1,r2
000072  4632              MOV      r2,r6
000074  4649              MOV      r1,r9
000076  f7fffffe          BL       __aeabi_memcpy
;;;837          pRing->WrOff += NumBytes;
00007a  68e0              LDR      r0,[r4,#0xc]
00007c  4430              ADD      r0,r0,r6
00007e  60e0              STR      r0,[r4,#0xc]
;;;838    #endif
;;;839          break;
000080  e00e              B        |L32.160|
                  |L32.130|
;;;840        } else {
;;;841          //
;;;842          //  Wrap-around necessary, write until wrap-around and reset WrOff
;;;843          //
;;;844    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;845          pDst = pRing->pBuffer + pRing->WrOff;
;;;846          NumBytes -= Avail;
;;;847          while (Avail--) {
;;;848            *pDst++ = *pData++;
;;;849          };
;;;850          pRing->WrOff = 0;
;;;851    #else
;;;852          SEGGER_RTT_MEMCPY(pRing->pBuffer + pRing->WrOff, pData, Avail);
000082  68e2              LDR      r2,[r4,#0xc]
000084  6861              LDR      r1,[r4,#4]
000086  1888              ADDS     r0,r1,r2
000088  462a              MOV      r2,r5
00008a  4649              MOV      r1,r9
00008c  f7fffffe          BL       __aeabi_memcpy
;;;853          pData += Avail;
000090  44a9              ADD      r9,r9,r5
;;;854          pRing->WrOff = 0;
000092  2000              MOVS     r0,#0
000094  60e0              STR      r0,[r4,#0xc]
;;;855          NumBytes -= Avail;
000096  1b76              SUBS     r6,r6,r5
;;;856    #endif
;;;857          Avail = (pRing->SizeOfBuffer - 1);
000098  68a0              LDR      r0,[r4,#8]
00009a  1e45              SUBS     r5,r0,#1
;;;858        }
;;;859      } while (NumBytes);
00009c  2e00              CMP      r6,#0
00009e  d1e3              BNE      |L32.104|
                  |L32.160|
0000a0  bf00              NOP                            ;839
;;;860    }
0000a2  e8bd87f0          POP      {r4-r10,pc}
;;;861    
                          ENDP

0000a6  0000              DCW      0x0000
                  |L32.168|
                          DCD      _SEGGER_RTT+0x18

                          AREA ||i._DoInit||, CODE, READONLY, ALIGN=2

                  _DoInit PROC
;;;274                    } while (0)
;;;275    static void _DoInit(void) {
000000  b510              PUSH     {r4,lr}
;;;276      SEGGER_RTT_CB* p;
;;;277      //
;;;278      // Initialize control block
;;;279      //
;;;280      p = &_SEGGER_RTT;
000002  4c12              LDR      r4,|L33.76|
;;;281      p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
000004  2003              MOVS     r0,#3
000006  6120              STR      r0,[r4,#0x10]
;;;282      p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
000008  6160              STR      r0,[r4,#0x14]
;;;283      //
;;;284      // Initialize up buffer 0
;;;285      //
;;;286      p->aUp[0].sName         = "Terminal";
00000a  a011              ADR      r0,|L33.80|
00000c  61a0              STR      r0,[r4,#0x18]
;;;287      p->aUp[0].pBuffer       = _acUpBuffer;
00000e  4913              LDR      r1,|L33.92|
000010  61e1              STR      r1,[r4,#0x1c]
;;;288      p->aUp[0].SizeOfBuffer  = sizeof(_acUpBuffer);
000012  f44f6180          MOV      r1,#0x400
000016  6221              STR      r1,[r4,#0x20]
;;;289      p->aUp[0].RdOff         = 0u;
000018  2100              MOVS     r1,#0
00001a  62a1              STR      r1,[r4,#0x28]
;;;290      p->aUp[0].WrOff         = 0u;
00001c  6261              STR      r1,[r4,#0x24]
;;;291      p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
00001e  62e1              STR      r1,[r4,#0x2c]
;;;292      //
;;;293      // Initialize down buffer 0
;;;294      //
;;;295      p->aDown[0].sName         = "Terminal";
000020  a00b              ADR      r0,|L33.80|
000022  6620              STR      r0,[r4,#0x60]
;;;296      p->aDown[0].pBuffer       = _acDownBuffer;
000024  490e              LDR      r1,|L33.96|
000026  6661              STR      r1,[r4,#0x64]
;;;297      p->aDown[0].SizeOfBuffer  = sizeof(_acDownBuffer);
000028  2110              MOVS     r1,#0x10
00002a  66a1              STR      r1,[r4,#0x68]
;;;298      p->aDown[0].RdOff         = 0u;
00002c  2100              MOVS     r1,#0
00002e  6721              STR      r1,[r4,#0x70]
;;;299      p->aDown[0].WrOff         = 0u;
000030  66e1              STR      r1,[r4,#0x6c]
;;;300      p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
000032  6761              STR      r1,[r4,#0x74]
;;;301      //
;;;302      // Finish initialization of the control block.
;;;303      // Copy Id string in three steps to make sure "SEGGER RTT" is not found
;;;304      // in initializer memory (usually flash) by J-Link
;;;305      //
;;;306      STRCPY(&p->acID[7], "RTT", 9);
000034  a10b              ADR      r1,|L33.100|
000036  1de0              ADDS     r0,r4,#7
000038  f7fffffe          BL       strcpy
;;;307      STRCPY(&p->acID[0], "SEGGER", 7);
00003c  a10a              ADR      r1,|L33.104|
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       strcpy
;;;308      p->acID[6] = ' ';
000044  2020              MOVS     r0,#0x20
000046  71a0              STRB     r0,[r4,#6]
;;;309    }
000048  bd10              POP      {r4,pc}
;;;310    
                          ENDP

00004a  0000              DCW      0x0000
                  |L33.76|
                          DCD      _SEGGER_RTT
                  |L33.80|
000050  5465726d          DCB      "Terminal",0
000054  696e616c
000058  00      
000059  00                DCB      0
00005a  00                DCB      0
00005b  00                DCB      0
                  |L33.92|
                          DCD      _acUpBuffer
                  |L33.96|
                          DCD      _acDownBuffer
                  |L33.100|
000064  52545400          DCB      "RTT",0
                  |L33.104|
000068  53454747          DCB      "SEGGER",0
00006c  455200  
00006f  00                DCB      0

                          AREA ||i._GetAvailWriteSpace||, CODE, READONLY, ALIGN=1

                  _GetAvailWriteSpace PROC
;;;479    */
;;;480    static unsigned _GetAvailWriteSpace(SEGGER_RTT_BUFFER_UP* pRing) {
000000  b510              PUSH     {r4,lr}
000002  4601              MOV      r1,r0
;;;481      unsigned RdOff;
;;;482      unsigned WrOff;
;;;483      unsigned r;
;;;484      //
;;;485      // Avoid warnings regarding volatile access order.  It's not a problem
;;;486      // in this case, but dampen compiler enthusiasm.
;;;487      //
;;;488      RdOff = pRing->RdOff;
000004  690a              LDR      r2,[r1,#0x10]
;;;489      WrOff = pRing->WrOff;
000006  68cb              LDR      r3,[r1,#0xc]
;;;490      if (RdOff <= WrOff) {
000008  429a              CMP      r2,r3
00000a  d804              BHI      |L34.22|
;;;491        r = pRing->SizeOfBuffer - 1u - WrOff + RdOff;
00000c  688c              LDR      r4,[r1,#8]
00000e  1e64              SUBS     r4,r4,#1
000010  1ae4              SUBS     r4,r4,r3
000012  18a0              ADDS     r0,r4,r2
000014  e001              B        |L34.26|
                  |L34.22|
;;;492      } else {
;;;493        r = RdOff - WrOff - 1u;
000016  1ad4              SUBS     r4,r2,r3
000018  1e60              SUBS     r0,r4,#1
                  |L34.26|
;;;494      }
;;;495      return r;
;;;496    }
00001a  bd10              POP      {r4,pc}
;;;497    
                          ENDP


                          AREA ||i._PostTerminalSwitch||, CODE, READONLY, ALIGN=2

                  _PostTerminalSwitch PROC
;;;457    */
;;;458    static void _PostTerminalSwitch(SEGGER_RTT_BUFFER_UP* pRing, unsigned char TerminalId) {
000000  b538              PUSH     {r3-r5,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;459      unsigned char ac[2];
;;;460    
;;;461      ac[0] = 0xFFu;
000006  20ff              MOVS     r0,#0xff
000008  f88d0000          STRB     r0,[sp,#0]
;;;462      ac[1] = _aTerminalId[TerminalId];  // Caller made already sure that TerminalId does not exceed our terminal limit
00000c  4804              LDR      r0,|L35.32|
00000e  5d00              LDRB     r0,[r0,r4]
000010  f88d0001          STRB     r0,[sp,#1]
;;;463      _WriteBlocking(pRing, (const char*)ac, 2u);
000014  2202              MOVS     r2,#2
000016  4669              MOV      r1,sp
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       _WriteBlocking
;;;464    }
00001e  bd38              POP      {r3-r5,pc}
;;;465    
                          ENDP

                  |L35.32|
                          DCD      _aTerminalId

                          AREA ||i._WriteBlocking||, CODE, READONLY, ALIGN=1

                  _WriteBlocking PROC
;;;329    */
;;;330    static unsigned _WriteBlocking(SEGGER_RTT_BUFFER_UP* pRing, const char* pBuffer, unsigned NumBytes) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
000008  4617              MOV      r7,r2
;;;331      unsigned NumBytesToWrite;
;;;332      unsigned NumBytesWritten;
;;;333      unsigned RdOff;
;;;334      unsigned WrOff;
;;;335    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;336      char*    pDst;
;;;337    #endif
;;;338      //
;;;339      // Write data to buffer and handle wrap-around if necessary
;;;340      //
;;;341      NumBytesWritten = 0u;
00000a  f04f0a00          MOV      r10,#0
;;;342      WrOff = pRing->WrOff;
00000e  68e5              LDR      r5,[r4,#0xc]
;;;343      do {
000010  bf00              NOP      
                  |L36.18|
;;;344        RdOff = pRing->RdOff;                         // May be changed by host (debug probe) in the meantime
000012  f8d48010          LDR      r8,[r4,#0x10]
;;;345        if (RdOff > WrOff) {
000016  45a8              CMP      r8,r5
000018  d903              BLS      |L36.34|
;;;346          NumBytesToWrite = RdOff - WrOff - 1u;
00001a  eba80005          SUB      r0,r8,r5
00001e  1e46              SUBS     r6,r0,#1
000020  e004              B        |L36.44|
                  |L36.34|
;;;347        } else {
;;;348          NumBytesToWrite = pRing->SizeOfBuffer - (WrOff - RdOff + 1u);
000022  eba50008          SUB      r0,r5,r8
000026  1c40              ADDS     r0,r0,#1
000028  68a1              LDR      r1,[r4,#8]
00002a  1a0e              SUBS     r6,r1,r0
                  |L36.44|
;;;349        }
;;;350        NumBytesToWrite = MIN(NumBytesToWrite, (pRing->SizeOfBuffer - WrOff));      // Number of bytes that can be written until buffer wrap-around
00002c  68a0              LDR      r0,[r4,#8]
00002e  1b40              SUBS     r0,r0,r5
000030  42b0              CMP      r0,r6
000032  d901              BLS      |L36.56|
000034  4630              MOV      r0,r6
000036  e001              B        |L36.60|
                  |L36.56|
000038  68a0              LDR      r0,[r4,#8]
00003a  1b40              SUBS     r0,r0,r5
                  |L36.60|
00003c  4606              MOV      r6,r0
;;;351        NumBytesToWrite = MIN(NumBytesToWrite, NumBytes);
00003e  42be              CMP      r6,r7
000040  d201              BCS      |L36.70|
000042  4630              MOV      r0,r6
000044  e000              B        |L36.72|
                  |L36.70|
000046  4638              MOV      r0,r7
                  |L36.72|
000048  4606              MOV      r6,r0
;;;352    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;353        pDst = pRing->pBuffer + WrOff;
;;;354        NumBytesWritten += NumBytesToWrite;
;;;355        NumBytes        -= NumBytesToWrite;
;;;356        WrOff           += NumBytesToWrite;
;;;357        while (NumBytesToWrite--) {
;;;358          *pDst++ = *pBuffer++;
;;;359        };
;;;360    #else
;;;361        SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pBuffer, NumBytesToWrite);
00004a  6861              LDR      r1,[r4,#4]
00004c  1948              ADDS     r0,r1,r5
00004e  4632              MOV      r2,r6
000050  4649              MOV      r1,r9
000052  f7fffffe          BL       __aeabi_memcpy
;;;362        NumBytesWritten += NumBytesToWrite;
000056  44b2              ADD      r10,r10,r6
;;;363        pBuffer         += NumBytesToWrite;
000058  44b1              ADD      r9,r9,r6
;;;364        NumBytes        -= NumBytesToWrite;
00005a  1bbf              SUBS     r7,r7,r6
;;;365        WrOff           += NumBytesToWrite;
00005c  4435              ADD      r5,r5,r6
;;;366    #endif
;;;367        if (WrOff == pRing->SizeOfBuffer) {
00005e  68a0              LDR      r0,[r4,#8]
000060  42a8              CMP      r0,r5
000062  d100              BNE      |L36.102|
;;;368          WrOff = 0u;
000064  2500              MOVS     r5,#0
                  |L36.102|
;;;369        }
;;;370        pRing->WrOff = WrOff;
000066  60e5              STR      r5,[r4,#0xc]
;;;371      } while (NumBytes);
000068  2f00              CMP      r7,#0
00006a  d1d2              BNE      |L36.18|
;;;372      //
;;;373      return NumBytesWritten;
00006c  4650              MOV      r0,r10
;;;374    }
00006e  e8bd87f0          POP      {r4-r10,pc}
;;;375    
                          ENDP


                          AREA ||i._WriteNoCheck||, CODE, READONLY, ALIGN=1

                  _WriteNoCheck PROC
;;;393    */
;;;394    static void _WriteNoCheck(SEGGER_RTT_BUFFER_UP* pRing, const char* pData, unsigned NumBytes) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
000008  4615              MOV      r5,r2
;;;395      unsigned NumBytesAtOnce;
;;;396      unsigned WrOff;
;;;397      unsigned Rem;
;;;398    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;399      char*    pDst;
;;;400    #endif
;;;401    
;;;402      WrOff = pRing->WrOff;
00000a  68e6              LDR      r6,[r4,#0xc]
;;;403      Rem = pRing->SizeOfBuffer - WrOff;
00000c  68a0              LDR      r0,[r4,#8]
00000e  1b87              SUBS     r7,r0,r6
;;;404      if (Rem > NumBytes) {
000010  42af              CMP      r7,r5
000012  d908              BLS      |L37.38|
;;;405        //
;;;406        // All data fits before wrap around
;;;407        //
;;;408    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;409        pDst = pRing->pBuffer + WrOff;
;;;410        WrOff += NumBytes;
;;;411        while (NumBytes--) {
;;;412          *pDst++ = *pData++;
;;;413        };
;;;414        pRing->WrOff = WrOff;
;;;415    #else
;;;416        SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pData, NumBytes);
000014  6861              LDR      r1,[r4,#4]
000016  1988              ADDS     r0,r1,r6
000018  462a              MOV      r2,r5
00001a  4649              MOV      r1,r9
00001c  f7fffffe          BL       __aeabi_memcpy
;;;417        pRing->WrOff = WrOff + NumBytes;
000020  1970              ADDS     r0,r6,r5
000022  60e0              STR      r0,[r4,#0xc]
000024  e010              B        |L37.72|
                  |L37.38|
;;;418    #endif
;;;419      } else {
;;;420        //
;;;421        // We reach the end of the buffer, so need to wrap around
;;;422        //
;;;423    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;424        pDst = pRing->pBuffer + WrOff;
;;;425        NumBytesAtOnce = Rem;
;;;426        while (NumBytesAtOnce--) {
;;;427          *pDst++ = *pData++;
;;;428        };
;;;429        pDst = pRing->pBuffer;
;;;430        NumBytesAtOnce = NumBytes - Rem;
;;;431        while (NumBytesAtOnce--) {
;;;432          *pDst++ = *pData++;
;;;433        };
;;;434        pRing->WrOff = NumBytes - Rem;
;;;435    #else
;;;436        NumBytesAtOnce = Rem;
000026  46b8              MOV      r8,r7
;;;437        SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pData, NumBytesAtOnce);
000028  6861              LDR      r1,[r4,#4]
00002a  1988              ADDS     r0,r1,r6
00002c  4642              MOV      r2,r8
00002e  4649              MOV      r1,r9
000030  f7fffffe          BL       __aeabi_memcpy
;;;438        NumBytesAtOnce = NumBytes - Rem;
000034  eba50807          SUB      r8,r5,r7
;;;439        SEGGER_RTT_MEMCPY(pRing->pBuffer, pData + Rem, NumBytesAtOnce);
000038  eb090107          ADD      r1,r9,r7
00003c  4642              MOV      r2,r8
00003e  6860              LDR      r0,[r4,#4]
000040  f7fffffe          BL       __aeabi_memcpy
;;;440        pRing->WrOff = NumBytesAtOnce;
000044  f8c4800c          STR      r8,[r4,#0xc]
                  |L37.72|
;;;441    #endif
;;;442      }
;;;443    }
000048  e8bd87f0          POP      {r4-r10,pc}
;;;444    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  _SEGGER_RTT
                          %        168
                  _acUpBuffer
                          %        1024
                  _acDownBuffer
                          %        16

                          AREA ||.data||, DATA, ALIGN=0

                  _aTerminalId
000000  30313233          DCB      0x30,0x31,0x32,0x33
000004  34353637          DCB      0x34,0x35,0x36,0x37
000008  38394142          DCB      0x38,0x39,0x41,0x42
00000c  43444546          DCB      0x43,0x44,0x45,0x46
                  _ActiveTerminal
000010  00                DCB      0x00

; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\diskio.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\diskio.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\FatFS\src -I..\..\User\Mass_Storage\inc -I..\..\User\LCD_Driver -I..\..\User\SYSTEM\sys -I..\..\User\Debugprintf -I..\..\User\LogDebug -I..\..\User\app\inc -I..\..\User\app\src -I..\..\User\bsp\inc -I..\..\User\bsp\src -I.\RTE\_Flash -ID:\Keil_v5\ARM\Packs\ARM\CMSIS\5.5.1\CMSIS\Core\Include -ID:\Keil_v5\ARM\Packs\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=527 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\diskio.crf ..\..\User\FatFS\src\diskio.c]
                          THUMB

                          AREA ||i.disk_initialize||, CODE, READONLY, ALIGN=1

                  disk_initialize PROC
;;;62     
;;;63     DSTATUS disk_initialize (
000000  b570              PUSH     {r4-r6,lr}
;;;64     	BYTE pdrv				/* Physical drive nmuber to identify the drive */
;;;65     )
;;;66     {
000002  4604              MOV      r4,r0
;;;67     	DSTATUS stat = STA_NOINIT;
000004  2501              MOVS     r5,#1
;;;68     
;;;69     	switch (pdrv)
000006  b114              CBZ      r4,|L1.14|
000008  2c01              CMP      r4,#1
00000a  d10e              BNE      |L1.42|
00000c  e006              B        |L1.28|
                  |L1.14|
;;;70     	{
;;;71     		case FS_SD :		/* SD卡 */
;;;72     			if (SD_Init() == SD_OK)
00000e  f7fffffe          BL       SD_Init
000012  b908              CBNZ     r0,|L1.24|
;;;73     			{
;;;74     				stat = RES_OK;
000014  2500              MOVS     r5,#0
000016  e000              B        |L1.26|
                  |L1.24|
;;;75     			}
;;;76     			else
;;;77     			{
;;;78     				stat = STA_NODISK;
000018  2502              MOVS     r5,#2
                  |L1.26|
;;;79     			}
;;;80     			break;
00001a  e007              B        |L1.44|
                  |L1.28|
;;;81     			
;;;82     		case FS_SPIFLASH :
;;;83     			bsp_InitSFlash();		/* 初始化FLASH,引脚上只初始化CS，对应SPI口线，在bsp初始化时已经初始化过了 */
00001c  f7fffffe          BL       bsp_InitSFlash
;;;84     			// translate the reslut code here
;;;85     			stat = disk_status(pdrv);
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       disk_status
000026  4605              MOV      r5,r0
;;;86     			break;
000028  e000              B        |L1.44|
                  |L1.42|
;;;87     
;;;88     		default :
;;;89     			break;
00002a  bf00              NOP      
                  |L1.44|
00002c  bf00              NOP                            ;80
;;;90     	}
;;;91     	return stat;
00002e  4628              MOV      r0,r5
;;;92     }
000030  bd70              POP      {r4-r6,pc}
;;;93     
                          ENDP


                          AREA ||i.disk_ioctl||, CODE, READONLY, ALIGN=2

                  disk_ioctl PROC
;;;273    #if _USE_IOCTL
;;;274    DRESULT disk_ioctl (
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;275    	BYTE pdrv,		/* Physical drive nmuber (0..) */
;;;276    	BYTE cmd,		/* Control code */
;;;277    	void *buff		/* Buffer to send/receive control data */
;;;278    )
;;;279    {
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
000008  4614              MOV      r4,r2
;;;280    	DRESULT res = RES_PARERR;
00000a  f04f0904          MOV      r9,#4
;;;281    
;;;282    	switch (pdrv) 
00000e  b116              CBZ      r6,|L2.22|
000010  2e01              CMP      r6,#1
000012  d144              BNE      |L2.158|
000014  e02b              B        |L2.110|
                  |L2.22|
;;;283    	{
;;;284    		case FS_SD :
;;;285    			res = RES_ERROR;
000016  f04f0901          MOV      r9,#1
;;;286    			switch (cmd)
00001a  2d05              CMP      r5,#5
00001c  d222              BCS      |L2.100|
00001e  e8dff005          TBB      [pc,r5]
000022  030c              DCB      0x03,0x0c
000024  061a2000          DCB      0x06,0x1a,0x20,0x00
;;;287    			{
;;;288    				/* SD卡磁盘容量： SDCardInfo.CardCapacity */
;;;289    				case CTRL_SYNC :		/* Wait for end of internal write process of the drive */
;;;290    					res = RES_OK;
000028  f04f0900          MOV      r9,#0
;;;291    					break;
00002c  e01d              B        |L2.106|
;;;292    
;;;293    				// Get R/W sector size (WORD) 
;;;294    				case GET_SECTOR_SIZE :    
;;;295    					*(WORD * )buff = SD_SECTOR_SIZE;
00002e  f44f7000          MOV      r0,#0x200
000032  8020              STRH     r0,[r4,#0]
;;;296    					res = RES_OK;
000034  f04f0900          MOV      r9,#0
;;;297    					break;
000038  e017              B        |L2.106|
;;;298    				
;;;299    				case GET_SECTOR_COUNT :	/* Get drive capacity in unit of sector (DWORD) */
;;;300    					*(DWORD*)buff = SDCardInfo.CardCapacity / SDCardInfo.CardBlockSize;
00003a  481c              LDR      r0,|L2.172|
00003c  f8d0c050          LDR      r12,[r0,#0x50]  ; SDCardInfo
000040  4662              MOV      r2,r12
000042  2300              MOVS     r3,#0
000044  e9d07112          LDRD     r7,r1,[r0,#0x48]
000048  4638              MOV      r0,r7
00004a  f7fffffe          BL       __aeabi_uldivmod
00004e  6020              STR      r0,[r4,#0]
;;;301    					res = RES_OK;
000050  f04f0900          MOV      r9,#0
;;;302    					break;
000054  e009              B        |L2.106|
;;;303    
;;;304    				case GET_BLOCK_SIZE :	/* Get erase block size in unit of sector (DWORD) */
;;;305    					*(WORD*)buff = 512;
000056  f44f7000          MOV      r0,#0x200
00005a  8020              STRH     r0,[r4,#0]
;;;306    					res = RES_OK;
00005c  f04f0900          MOV      r9,#0
;;;307    					break;
000060  e003              B        |L2.106|
;;;308    
;;;309    				case CTRL_ERASE_SECTOR: /* Erase a block of sectors (used when _USE_ERASE == 1) */
;;;310    					break;
000062  e002              B        |L2.106|
                  |L2.100|
;;;311    				
;;;312    				default:
;;;313    					res = RES_PARERR;
000064  f04f0904          MOV      r9,#4
;;;314    					break;
000068  bf00              NOP      
                  |L2.106|
00006a  bf00              NOP                            ;291
;;;315    			}
;;;316    			break;
00006c  e01a              B        |L2.164|
                  |L2.110|
;;;317    
;;;318    		case FS_SPIFLASH :
;;;319    				// pre-process here
;;;320    				switch (cmd) 
00006e  b135              CBZ      r5,|L2.126|
000070  2d01              CMP      r5,#1
000072  d005              BEQ      |L2.128|
000074  2d02              CMP      r5,#2
000076  d007              BEQ      |L2.136|
000078  2d03              CMP      r5,#3
00007a  d10c              BNE      |L2.150|
00007c  e008              B        |L2.144|
                  |L2.126|
;;;321    				{
;;;322    					/* SPI Flash不需要同步 */
;;;323    					case CTRL_SYNC :  
;;;324    						break;
00007e  e00a              B        |L2.150|
                  |L2.128|
;;;325    					
;;;326    					/* 扇区数量: 4096*4096/1024/1024=16(MB) */
;;;327    					case GET_SECTOR_COUNT:
;;;328    						*(DWORD * )buff = 4096;
000080  f44f5080          MOV      r0,#0x1000
000084  6020              STR      r0,[r4,#0]
;;;329    						break;
000086  e006              B        |L2.150|
                  |L2.136|
;;;330    					
;;;331    					/* 扇区大小 */
;;;332    					case GET_SECTOR_SIZE :
;;;333    						*(WORD * )buff = 4096;
000088  f44f5080          MOV      r0,#0x1000
00008c  8020              STRH     r0,[r4,#0]
;;;334    						break;
00008e  e002              B        |L2.150|
                  |L2.144|
;;;335    					
;;;336    					/* 同时擦除扇区个数 */
;;;337    					case GET_BLOCK_SIZE :
;;;338    						*(DWORD * )buff = 8;
000090  2008              MOVS     r0,#8
000092  6020              STR      r0,[r4,#0]
;;;339    						break;
000094  bf00              NOP      
                  |L2.150|
000096  bf00              NOP                            ;324
;;;340    				}
;;;341    				// post-process here
;;;342    				res = RES_OK;
000098  f04f0900          MOV      r9,#0
;;;343    				break;
00009c  e002              B        |L2.164|
                  |L2.158|
;;;344    
;;;345    		default:
;;;346    			res = RES_PARERR;
00009e  f04f0904          MOV      r9,#4
;;;347    			break;
0000a2  bf00              NOP      
                  |L2.164|
0000a4  bf00              NOP                            ;316
;;;348    	}
;;;349    	return res;
0000a6  4648              MOV      r0,r9
;;;350    }
0000a8  e8bd87f0          POP      {r4-r10,pc}
;;;351    #endif
                          ENDP

                  |L2.172|
                          DCD      SDCardInfo

                          AREA ||i.disk_read||, CODE, READONLY, ALIGN=2

                  disk_read PROC
;;;99     
;;;100    DRESULT disk_read (
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;101    	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
;;;102    	BYTE *buff,		/* Data buffer to store read data */
;;;103    	DWORD sector,	/* Sector address in LBA */
;;;104    	UINT count		/* Number of sectors to read */
;;;105    )
;;;106    {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
;;;107    	DRESULT res = RES_PARERR;
00000c  f04f0a04          MOV      r10,#4
;;;108    	SD_Error Status;
;;;109    
;;;110    	switch (pdrv)
000010  b117              CBZ      r7,|L3.24|
000012  2f01              CMP      r7,#1
000014  d13c              BNE      |L3.144|
000016  e033              B        |L3.128|
                  |L3.24|
;;;111    	{
;;;112    		case FS_SD :
;;;113    			if (count == 1)
000018  2d01              CMP      r5,#1
00001a  d109              BNE      |L3.48|
;;;114    			{
;;;115    				Status = SD_ReadBlock(buff, sector << 9 , SD_SECTOR_SIZE);
00001c  0268              LSLS     r0,r5,#9
00001e  0261              LSLS     r1,r4,#9
000020  460a              MOV      r2,r1
000022  2300              MOVS     r3,#0
000024  9000              STR      r0,[sp,#0]
000026  4640              MOV      r0,r8
000028  f7fffffe          BL       SD_ReadBlock
00002c  4606              MOV      r6,r0
00002e  e00b              B        |L3.72|
                  |L3.48|
;;;116    			}
;;;117    			else
;;;118    			{
;;;119    				Status = SD_ReadMultiBlocks(buff, sector << 9 , SD_SECTOR_SIZE, count+1);
000030  1c68              ADDS     r0,r5,#1
000032  f44f7100          MOV      r1,#0x200
000036  e9cd1000          STRD     r1,r0,[sp,#0]
00003a  0261              LSLS     r1,r4,#9
00003c  460a              MOV      r2,r1
00003e  2300              MOVS     r3,#0
000040  4640              MOV      r0,r8
000042  f7fffffe          BL       SD_ReadMultiBlocks
000046  4606              MOV      r6,r0
                  |L3.72|
;;;120    			}
;;;121    #ifdef  SD_DMA_MODE			
;;;122    			/* SDIO工作在DMA模式，需要检查操作DMA传输是否完成 */
;;;123    			Status = SD_WaitReadOperation();
000048  f7fffffe          BL       SD_WaitReadOperation
00004c  4606              MOV      r6,r0
;;;124    			if (Status != SD_OK)
00004e  b116              CBZ      r6,|L3.86|
;;;125    			{
;;;126    				return RES_ERROR;
000050  2001              MOVS     r0,#1
                  |L3.82|
;;;127    			}
;;;128    			
;;;129    			//while(SD_GetStatus() != SD_TRANSFER_OK); 如果不插卡，则此处会死机
;;;130    			{
;;;131    				uint32_t i;
;;;132    				SDTransferState status;
;;;133    				
;;;134    				for (i = 0; i < 100000; i++)
;;;135    				{									
;;;136    					status = SD_GetStatus();
;;;137    					if (status == SD_TRANSFER_ERROR)
;;;138    					{
;;;139    						res = RES_ERROR;
;;;140    						break;
;;;141    					}
;;;142    					else if (status == SD_TRANSFER_OK)
;;;143    					{
;;;144    						res = RES_OK;
;;;145    						break;
;;;146    					}
;;;147    					//  SD_TRANSFER_BUSY 则继续等待 
;;;148    				}
;;;149    			}
;;;150    #endif
;;;151    			break;
;;;152    			
;;;153    		case FS_SPIFLASH :
;;;154    			// translate the arguments here
;;;155    			/* 
;;;156    				由于SPI_FLASH一个扇区大小为4096字节，
;;;157    				sector是扇区号，读第1个扇区时，实际时从地址1*4096开始读取
;;;158    				count时读出扇区的数量，每个扇区4096字节，读1个扇区时，实际读字节数为1*4096
;;;159    			*/
;;;160    			sf_ReadBuffer(buff, sector << 12, count<<12);	
;;;161    			// translate the reslut code here
;;;162    			res = RES_OK;
;;;163    			break;
;;;164    
;;;165    		default:
;;;166    			res = RES_PARERR;
;;;167    			break;
;;;168    	}
;;;169    	return res;
;;;170    }
000052  e8bd87fc          POP      {r2-r10,pc}
                  |L3.86|
000056  f04f0900          MOV      r9,#0                 ;134
00005a  e00c              B        |L3.118|
                  |L3.92|
00005c  f7fffffe          BL       SD_GetStatus
000060  2802              CMP      r0,#2                 ;137
000062  d102              BNE      |L3.106|
000064  f04f0a01          MOV      r10,#1                ;139
000068  e008              B        |L3.124|
                  |L3.106|
00006a  b910              CBNZ     r0,|L3.114|
00006c  f04f0a00          MOV      r10,#0                ;144
000070  e004              B        |L3.124|
                  |L3.114|
000072  f1090901          ADD      r9,r9,#1              ;134
                  |L3.118|
000076  4909              LDR      r1,|L3.156|
000078  4589              CMP      r9,r1                 ;134
00007a  d3ef              BCC      |L3.92|
                  |L3.124|
00007c  bf00              NOP                            ;140
00007e  e00a              B        |L3.150|
                  |L3.128|
000080  032a              LSLS     r2,r5,#12             ;160
000082  0321              LSLS     r1,r4,#12             ;160
000084  4640              MOV      r0,r8                 ;160
000086  f7fffffe          BL       sf_ReadBuffer
00008a  f04f0a00          MOV      r10,#0                ;162
00008e  e002              B        |L3.150|
                  |L3.144|
000090  f04f0a04          MOV      r10,#4                ;166
000094  bf00              NOP                            ;167
                  |L3.150|
000096  bf00              NOP                            ;151
000098  4650              MOV      r0,r10                ;169
00009a  e7da              B        |L3.82|
;;;171    
                          ENDP

                  |L3.156|
                          DCD      0x000186a0

                          AREA ||i.disk_status||, CODE, READONLY, ALIGN=2

                  disk_status PROC
;;;21     
;;;22     DSTATUS disk_status 
000000  b570              PUSH     {r4-r6,lr}
;;;23     (
;;;24     	BYTE pdrv		/* Physical drive nmuber to identify the drive */
;;;25     )
;;;26     {
000002  4605              MOV      r5,r0
;;;27     	DSTATUS stat = STA_NOINIT;
000004  2401              MOVS     r4,#1
;;;28     
;;;29     	switch (pdrv)
000006  b115              CBZ      r5,|L4.14|
000008  2d01              CMP      r5,#1
00000a  d10e              BNE      |L4.42|
00000c  e001              B        |L4.18|
                  |L4.14|
;;;30     	{
;;;31     		case FS_SD :
;;;32     			stat = 0;
00000e  2400              MOVS     r4,#0
;;;33     			break;
000010  e00c              B        |L4.44|
                  |L4.18|
;;;34     		
;;;35     		case FS_SPIFLASH :	
;;;36     			/* 获取芯片信息 */
;;;37     			sf_ReadInfo();		
000012  f7fffffe          BL       sf_ReadInfo
;;;38     			/* 识别ID是否正确 */
;;;39     			if(g_tSF.ChipID == N25Q128A_ID)
000016  4807              LDR      r0,|L4.52|
000018  6800              LDR      r0,[r0,#0]  ; g_tSF
00001a  4907              LDR      r1,|L4.56|
00001c  4288              CMP      r0,r1
00001e  d102              BNE      |L4.38|
;;;40     			{
;;;41     				stat &= ~STA_NOINIT;
000020  f0240401          BIC      r4,r4,#1
000024  e000              B        |L4.40|
                  |L4.38|
;;;42     			}
;;;43     			else 
;;;44     			{
;;;45     				stat = STA_NOINIT;
000026  2401              MOVS     r4,#1
                  |L4.40|
;;;46     			}
;;;47     			// translate the reslut code here
;;;48     			break;
000028  e000              B        |L4.44|
                  |L4.42|
;;;49     
;;;50     
;;;51     		default:
;;;52     			break;
00002a  bf00              NOP      
                  |L4.44|
00002c  bf00              NOP                            ;33
;;;53     	}
;;;54     	return stat;
00002e  4620              MOV      r0,r4
;;;55     }
000030  bd70              POP      {r4-r6,pc}
;;;56     
                          ENDP

000032  0000              DCW      0x0000
                  |L4.52|
                          DCD      g_tSF
                  |L4.56|
                          DCD      0x0020ba18

                          AREA ||i.disk_write||, CODE, READONLY, ALIGN=2

                  disk_write PROC
;;;178    #if _USE_WRITE
;;;179    DRESULT disk_write 
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;180    (
;;;181    	BYTE pdrv,			/* Physical drive nmuber to identify the drive */
;;;182    	const BYTE *buff,	/* Data to be written */
;;;183    	DWORD sector,		/* Sector address in LBA */
;;;184    	UINT count			/* Number of sectors to write */
;;;185    )
;;;186    {
000004  4681              MOV      r9,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
;;;187    	DRESULT res = RES_OK;
00000c  2000              MOVS     r0,#0
00000e  9002              STR      r0,[sp,#8]
;;;188    	SD_Error Status;
;;;189    	uint32_t j;
;;;190    	BYTE *p;
;;;191    
;;;192    	switch (pdrv)
000010  f1b90f00          CMP      r9,#0
000014  d003              BEQ      |L5.30|
000016  f1b90f01          CMP      r9,#1
00001a  d14b              BNE      |L5.180|
00001c  e036              B        |L5.140|
                  |L5.30|
;;;193    	{
;;;194    		case FS_SD :
;;;195    			if (count == 1)
00001e  2e01              CMP      r6,#1
000020  d109              BNE      |L5.54|
;;;196    			{
;;;197    				Status = SD_WriteBlock((uint8_t *)buff, sector << 9 , SD_SECTOR_SIZE);
000022  0270              LSLS     r0,r6,#9
000024  0269              LSLS     r1,r5,#9
000026  460a              MOV      r2,r1
000028  2300              MOVS     r3,#0
00002a  9000              STR      r0,[sp,#0]
00002c  4638              MOV      r0,r7
00002e  f7fffffe          BL       SD_WriteBlock
000032  4604              MOV      r4,r0
000034  e00b              B        |L5.78|
                  |L5.54|
;;;198    			}
;;;199    			else
;;;200    			{
;;;201    				Status = SD_WriteMultiBlocks((uint8_t *)buff, sector << 9 ,SD_SECTOR_SIZE, count+1);				
000036  1c70              ADDS     r0,r6,#1
000038  f44f7100          MOV      r1,#0x200
00003c  e9cd1000          STRD     r1,r0,[sp,#0]
000040  0269              LSLS     r1,r5,#9
000042  460a              MOV      r2,r1
000044  2300              MOVS     r3,#0
000046  4638              MOV      r0,r7
000048  f7fffffe          BL       SD_WriteMultiBlocks
00004c  4604              MOV      r4,r0
                  |L5.78|
;;;202    			}
;;;203    			
;;;204    			if (Status != SD_OK)
00004e  b114              CBZ      r4,|L5.86|
;;;205    			{
;;;206    				return RES_ERROR;
000050  2001              MOVS     r0,#1
                  |L5.82|
;;;207    			}
;;;208    #ifdef  SD_DMA_MODE
;;;209    			/* SDIO工作在DMA模式，需要检查操作DMA传输是否完成 */
;;;210    			Status = SD_WaitWriteOperation();
;;;211    			if (Status != SD_OK)
;;;212    			{
;;;213    				return RES_ERROR;
;;;214    			}
;;;215    			
;;;216    			//while(SD_GetStatus() != SD_TRANSFER_OK); 如果不插卡，则此处会死机
;;;217    			{
;;;218    				uint32_t i;
;;;219    				SDTransferState status;
;;;220    				
;;;221    				for (i = 0; i < 100000; i++)
;;;222    				{									
;;;223    					status = SD_GetStatus();
;;;224    					if (status == SD_TRANSFER_ERROR)
;;;225    					{
;;;226    						res = RES_ERROR;
;;;227    						break;
;;;228    					}
;;;229    					else if (status == SD_TRANSFER_OK)
;;;230    					{
;;;231    						res = RES_OK;
;;;232    						break;
;;;233    					}
;;;234    					//  SD_TRANSFER_BUSY 则继续等待 
;;;235    				}
;;;236    			}
;;;237    #endif
;;;238    			break;
;;;239    			
;;;240    		case FS_SPIFLASH :
;;;241    			// translate the arguments here
;;;242    			/* 
;;;243    				由于SPI_FLASH一个扇区大小为4096字节，
;;;244    				sector是扇区号，写入第1个扇区时，实际时从地址1*4096开始写入
;;;245    				count是写入扇区的数量，每个扇区4096字节，写入1个扇区时，实际写入数量为1*4096
;;;246    			*/		
;;;247    			p = (BYTE *)buff;
;;;248    			for(j = 0; j < count; j++)
;;;249    			{
;;;250    				/* 每次写入一个扇区 */
;;;251    				sf_WriteBuffer((uint8_t *)buff, sector << 12, 4096);
;;;252    				p += 4096;					
;;;253    			}
;;;254    
;;;255    			// translate the reslut code here
;;;256    			res = RES_OK;
;;;257    			return res;	
;;;258    		
;;;259    
;;;260    		default:
;;;261    			res = RES_PARERR;
;;;262    			break;
;;;263    	}
;;;264    	return res;
;;;265    }
000052  e8bd8ffe          POP      {r1-r11,pc}
                  |L5.86|
000056  f7fffffe          BL       SD_WaitWriteOperation
00005a  4604              MOV      r4,r0                 ;210
00005c  b10c              CBZ      r4,|L5.98|
00005e  2001              MOVS     r0,#1                 ;213
000060  e7f7              B        |L5.82|
                  |L5.98|
000062  f04f0b00          MOV      r11,#0                ;221
000066  e00c              B        |L5.130|
                  |L5.104|
000068  f7fffffe          BL       SD_GetStatus
00006c  2802              CMP      r0,#2                 ;224
00006e  d102              BNE      |L5.118|
000070  2101              MOVS     r1,#1                 ;226
000072  9102              STR      r1,[sp,#8]            ;226
000074  e008              B        |L5.136|
                  |L5.118|
000076  b910              CBNZ     r0,|L5.126|
000078  2100              MOVS     r1,#0                 ;231
00007a  9102              STR      r1,[sp,#8]            ;231
00007c  e004              B        |L5.136|
                  |L5.126|
00007e  f10b0b01          ADD      r11,r11,#1            ;221
                  |L5.130|
000082  490f              LDR      r1,|L5.192|
000084  458b              CMP      r11,r1                ;221
000086  d3ef              BCC      |L5.104|
                  |L5.136|
000088  bf00              NOP                            ;227
00008a  e016              B        |L5.186|
                  |L5.140|
00008c  46ba              MOV      r10,r7                ;247
00008e  f04f0800          MOV      r8,#0                 ;248
000092  e009              B        |L5.168|
                  |L5.148|
000094  0329              LSLS     r1,r5,#12             ;251
000096  f44f5280          MOV      r2,#0x1000            ;251
00009a  4638              MOV      r0,r7                 ;251
00009c  f7fffffe          BL       sf_WriteBuffer
0000a0  f50a5a80          ADD      r10,r10,#0x1000       ;252
0000a4  f1080801          ADD      r8,r8,#1              ;248
                  |L5.168|
0000a8  45b0              CMP      r8,r6                 ;248
0000aa  d3f3              BCC      |L5.148|
0000ac  2000              MOVS     r0,#0                 ;256
0000ae  9002              STR      r0,[sp,#8]            ;256
0000b0  9802              LDR      r0,[sp,#8]            ;257
0000b2  e7ce              B        |L5.82|
                  |L5.180|
0000b4  2004              MOVS     r0,#4                 ;261
0000b6  9002              STR      r0,[sp,#8]            ;261
0000b8  bf00              NOP                            ;262
                  |L5.186|
0000ba  bf00              NOP                            ;238
0000bc  9802              LDR      r0,[sp,#8]            ;264
0000be  e7c8              B        |L5.82|
;;;266    #endif
                          ENDP

                  |L5.192|
                          DCD      0x000186a0

                          AREA ||i.get_fattime||, CODE, READONLY, ALIGN=2

                  get_fattime PROC
;;;360    */
;;;361    DWORD get_fattime (void)
000000  4800              LDR      r0,|L6.4|
;;;362    {
;;;363    	/* 如果有全局时钟，可按下面的格式进行时钟转换. 这个例子是2014-07-02 00:00:00 */
;;;364    #if 0
;;;365    	RTC_ReadClock();
;;;366    	return  ((DWORD)(g_tRTC.Year - 1980) << 25)		/* Year  */
;;;367    			| ((DWORD)g_tRTC.Mon << 21)				/* Month   */
;;;368    			| ((DWORD)g_tRTC.Day << 16)				/* Day_m  1*/
;;;369    			| ((DWORD)g_tRTC.Hour << 11)			/* Hour  */
;;;370    			| ((DWORD)g_tRTC.Min << 5)				/* Min  */
;;;371    			| ((DWORD)g_tRTC.Sec >> 1);				/* Sec  */
;;;372    	
;;;373    #else
;;;374    	return	  ((DWORD)(2014 - 1980) << 25)	/* Year = 2014 */
;;;375    			| ((DWORD)7 << 21)				/* Month = 7 */
;;;376    			| ((DWORD)2 << 16)				/* Day_m = 2*/
;;;377    			| ((DWORD)0 << 11)				/* Hour = 0 */
;;;378    			| ((DWORD)0 << 5)				/* Min = 0 */
;;;379    			| ((DWORD)0 >> 1);				/* Sec = 0 */
;;;380    #endif	
;;;381    }
000002  4770              BX       lr
;;;382    
                          ENDP

                  |L6.4|
                          DCD      0x44e20000

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\FatFS\\src\\diskio.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_diskio_c_fd8865f0____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___8_diskio_c_fd8865f0____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_diskio_c_fd8865f0____REVSH|
#line 128
|__asm___8_diskio_c_fd8865f0____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

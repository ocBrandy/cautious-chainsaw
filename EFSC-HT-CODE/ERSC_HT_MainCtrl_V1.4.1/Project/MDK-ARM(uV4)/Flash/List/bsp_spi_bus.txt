; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_spi_bus.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_spi_bus.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\FatFS\src -I..\..\User\Mass_Storage\inc -I..\..\User\LCD_Driver -I..\..\User\SYSTEM\sys -I..\..\User\Debugprintf -I..\..\User\LogDebug -I..\..\User\app\inc -I..\..\User\app\src -I..\..\User\bsp\inc -I..\..\User\bsp\src -I.\RTE\_Flash -ID:\Keil_v5\ARM\Packs\ARM\CMSIS\5.5.1\CMSIS\Core\Include -ID:\Keil_v5\ARM\Packs\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=527 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_spi_bus.crf ..\..\User\bsp\src\bsp_spi_bus.c]
                          THUMB

                          AREA ||i.bsp_InitSPIBus||, CODE, READONLY, ALIGN=2

                  bsp_InitSPIBus PROC
;;;77     */
;;;78     void bsp_InitSPIBus(void)
000000  b508              PUSH     {r3,lr}
;;;79     {
;;;80     #ifdef SOFT_SPI		/* 软件SPI */
;;;81     	GPIO_InitTypeDef  GPIO_InitStructure;
;;;82     
;;;83     	/* 打开GPIO时钟 */
;;;84     	RCC_APB2PeriphClockCmd(RCC_SCK | RCC_MOSI | RCC_MISO, ENABLE);	
000002  2101              MOVS     r1,#1
000004  2004              MOVS     r0,#4
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;85     
;;;86     	/* 配置SPI引脚SCK、MISO 和 MOSI为复用推挽模式 */
;;;87     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00000a  2003              MOVS     r0,#3
00000c  f88d0002          STRB     r0,[sp,#2]
;;;88     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;	/* 推挽输出模式 */
000010  2010              MOVS     r0,#0x10
000012  f88d0003          STRB     r0,[sp,#3]
;;;89     	GPIO_InitStructure.GPIO_Pin = PIN_SCK;
000016  2020              MOVS     r0,#0x20
000018  f8ad0000          STRH     r0,[sp,#0]
;;;90     	GPIO_Init(PORT_SCK, &GPIO_InitStructure);
00001c  4669              MOV      r1,sp
00001e  480a              LDR      r0,|L1.72|
000020  f7fffffe          BL       GPIO_Init
;;;91     
;;;92     	GPIO_InitStructure.GPIO_Pin = PIN_MOSI;
000024  2080              MOVS     r0,#0x80
000026  f8ad0000          STRH     r0,[sp,#0]
;;;93     	GPIO_Init(PORT_MOSI, &GPIO_InitStructure);	
00002a  4669              MOV      r1,sp
00002c  4806              LDR      r0,|L1.72|
00002e  f7fffffe          BL       GPIO_Init
;;;94     
;;;95     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;		/* MISO 设置为输入上拉 */
000032  2048              MOVS     r0,#0x48
000034  f88d0003          STRB     r0,[sp,#3]
;;;96     	GPIO_InitStructure.GPIO_Pin = PIN_MISO;
000038  2040              MOVS     r0,#0x40
00003a  f8ad0000          STRH     r0,[sp,#0]
;;;97     	GPIO_Init(PORT_MISO, &GPIO_InitStructure);
00003e  4669              MOV      r1,sp
000040  4801              LDR      r0,|L1.72|
000042  f7fffffe          BL       GPIO_Init
;;;98     #endif
;;;99     
;;;100    #ifdef HARD_SPI		/* 硬件SPI */
;;;101    	GPIO_InitTypeDef GPIO_InitStructure;
;;;102    
;;;103    	/* 开启 SPI 时钟 */
;;;104    	//RCC_APB2PeriphClockCmd(RCC_SPI, ENABLE);
;;;105    	
;;;106    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE);
;;;107    	
;;;108    	/* 使能 GPIO 时钟 */
;;;109    	RCC_APB2PeriphClockCmd(RCC_SCK | RCC_MOSI | RCC_MISO, ENABLE);	
;;;110    
;;;111    	/* 配置 SPI引脚SCK、MISO 和 MOSI为复用推挽模式 */
;;;112    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
;;;113    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;114    	GPIO_InitStructure.GPIO_Pin = PIN_SCK;	
;;;115    	GPIO_Init(PORT_SCK, &GPIO_InitStructure);
;;;116    	
;;;117    	GPIO_InitStructure.GPIO_Pin = PIN_MISO;	
;;;118    	GPIO_Init(PORT_MISO, &GPIO_InitStructure);
;;;119    
;;;120    	GPIO_InitStructure.GPIO_Pin = PIN_MOSI;	
;;;121    	GPIO_Init(PORT_MOSI, &GPIO_InitStructure);
;;;122    		
;;;123    	bsp_SPI_Init(SPI_Direction_2Lines_FullDuplex | SPI_Mode_Master | SPI_DataSize_8b
;;;124    		| SPI_CPOL_Low | SPI_CPHA_1Edge | SPI_NSS_Soft | SPI_BaudRatePrescaler_64 | SPI_FirstBit_MSB);	
;;;125    	
;;;126    	/* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
;;;127    	SPI_HARD->I2SCFGR &= SPI_Mode_Select;		/* 选择SPI模式，不是I2S模式 */
;;;128    
;;;129    	/*---------------------------- SPIx CRCPOLY Configuration --------------------*/
;;;130    	/* Write to SPIx CRCPOLY */
;;;131    	SPI_HARD->CRCPR = 7;		/* 一般不用 */
;;;132    
;;;133    
;;;134    	SPI_Cmd(SPI_HARD, DISABLE);			/* 先禁止SPI  */
;;;135    
;;;136    	SPI_Cmd(SPI_HARD, ENABLE);			/* 使能SPI  */
;;;137    #endif
;;;138    }
000046  bd08              POP      {r3,pc}
;;;139    
                          ENDP

                  |L1.72|
                          DCD      0x40010800

                          AREA ||i.bsp_SetSpiSck||, CODE, READONLY, ALIGN=2

                  bsp_SetSpiSck PROC
;;;417    #ifdef SOFT_SPI		/* 软件SPI */
;;;418    void bsp_SetSpiSck(uint8_t _data)
000000  b918              CBNZ     r0,|L2.10|
;;;419    {
;;;420    	if (_data == 0)
;;;421    	{
;;;422    		SCK_0();
000002  2120              MOVS     r1,#0x20
000004  4a03              LDR      r2,|L2.20|
000006  6011              STR      r1,[r2,#0]
000008  e003              B        |L2.18|
                  |L2.10|
;;;423    	}
;;;424    	else
;;;425    	{
;;;426    		SCK_1();
00000a  2120              MOVS     r1,#0x20
00000c  4a01              LDR      r2,|L2.20|
00000e  1f12              SUBS     r2,r2,#4
000010  6011              STR      r1,[r2,#0]
                  |L2.18|
;;;427    	}
;;;428    }
000012  4770              BX       lr
;;;429    #endif
                          ENDP

                  |L2.20|
                          DCD      0x40010814

                          AREA ||i.bsp_SpiBusBusy||, CODE, READONLY, ALIGN=2

                  bsp_SpiBusBusy PROC
;;;403    */
;;;404    uint8_t bsp_SpiBusBusy(void)
000000  4801              LDR      r0,|L3.8|
;;;405    {
;;;406    	return g_spi_busy;
000002  7800              LDRB     r0,[r0,#0]  ; g_spi_busy
;;;407    }
000004  4770              BX       lr
;;;408    
                          ENDP

000006  0000              DCW      0x0000
                  |L3.8|
                          DCD      g_spi_busy

                          AREA ||i.bsp_SpiBusEnter||, CODE, READONLY, ALIGN=2

                  bsp_SpiBusEnter PROC
;;;377    */
;;;378    void bsp_SpiBusEnter(void)
000000  2001              MOVS     r0,#1
;;;379    {
;;;380    	g_spi_busy = 1;
000002  4901              LDR      r1,|L4.8|
000004  7008              STRB     r0,[r1,#0]
;;;381    }
000006  4770              BX       lr
;;;382    
                          ENDP

                  |L4.8|
                          DCD      g_spi_busy

                          AREA ||i.bsp_SpiBusExit||, CODE, READONLY, ALIGN=2

                  bsp_SpiBusExit PROC
;;;390    */
;;;391    void bsp_SpiBusExit(void)
000000  2000              MOVS     r0,#0
;;;392    {
;;;393    	g_spi_busy = 0;
000002  4901              LDR      r1,|L5.8|
000004  7008              STRB     r0,[r1,#0]
;;;394    }
000006  4770              BX       lr
;;;395    
                          ENDP

                  |L5.8|
                          DCD      g_spi_busy

                          AREA ||i.bsp_spiDelay||, CODE, READONLY, ALIGN=1

                  bsp_spiDelay PROC
;;;169    */
;;;170    void bsp_spiDelay(void)
000000  2000              MOVS     r0,#0
;;;171    {
;;;172    	uint32_t i;
;;;173    
;;;174    	for (i = 0; i < 2; i++);
000002  e000              B        |L6.6|
                  |L6.4|
000004  1c40              ADDS     r0,r0,#1
                  |L6.6|
000006  2802              CMP      r0,#2
000008  d3fc              BCC      |L6.4|
;;;175    }
00000a  4770              BX       lr
;;;176    #endif
                          ENDP


                          AREA ||i.bsp_spiRead0||, CODE, READONLY, ALIGN=2

                  bsp_spiRead0 PROC
;;;232    */
;;;233    uint8_t bsp_spiRead0(void)
000000  b570              PUSH     {r4-r6,lr}
;;;234    {
;;;235    #ifdef SOFT_SPI		/* 软件SPI */
;;;236    	uint8_t i;
;;;237    	uint8_t read = 0;
000002  2400              MOVS     r4,#0
;;;238    
;;;239    	for (i = 0; i < 8; i++)
000004  2500              MOVS     r5,#0
000006  e017              B        |L7.56|
                  |L7.8|
;;;240    	{
;;;241    		read = read<<1;
000008  0660              LSLS     r0,r4,#25
00000a  0e04              LSRS     r4,r0,#24
;;;242    
;;;243    		if (MISO_IS_HIGH())
00000c  2140              MOVS     r1,#0x40
00000e  480c              LDR      r0,|L7.64|
000010  f7fffffe          BL       GPIO_ReadInputDataBit
000014  2801              CMP      r0,#1
000016  d101              BNE      |L7.28|
;;;244    		{
;;;245    			read++;
000018  1c60              ADDS     r0,r4,#1
00001a  b2c4              UXTB     r4,r0
                  |L7.28|
;;;246    		}
;;;247    		SCK_1();
00001c  2020              MOVS     r0,#0x20
00001e  4908              LDR      r1,|L7.64|
000020  3110              ADDS     r1,r1,#0x10
000022  6008              STR      r0,[r1,#0]
;;;248    		bsp_spiDelay();
000024  f7fffffe          BL       bsp_spiDelay
;;;249    		SCK_0();
000028  2020              MOVS     r0,#0x20
00002a  4905              LDR      r1,|L7.64|
00002c  3114              ADDS     r1,r1,#0x14
00002e  6008              STR      r0,[r1,#0]
;;;250    		bsp_spiDelay();
000030  f7fffffe          BL       bsp_spiDelay
000034  1c68              ADDS     r0,r5,#1              ;239
000036  b2c5              UXTB     r5,r0                 ;239
                  |L7.56|
000038  2d08              CMP      r5,#8                 ;239
00003a  dbe5              BLT      |L7.8|
;;;251    	}
;;;252    	return read;
00003c  4620              MOV      r0,r4
;;;253    #endif
;;;254    
;;;255    #ifdef HARD_SPI		/* 硬件SPI */
;;;256    	uint8_t read;
;;;257    
;;;258    	/* 等待发送缓冲区空 */
;;;259    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET);
;;;260    
;;;261    	/* 发送一个字节 */
;;;262    	SPI_I2S_SendData(SPI1, 0);
;;;263    
;;;264    	/* 等待数据接收完毕 */
;;;265    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET);
;;;266    
;;;267    	/* 读取接收到的数据 */
;;;268    	read = SPI_I2S_ReceiveData(SPI1);
;;;269    
;;;270    	/* 返回读到的数据 */
;;;271    	return read;
;;;272    #endif
;;;273    }
00003e  bd70              POP      {r4-r6,pc}
;;;274    
                          ENDP

                  |L7.64|
                          DCD      0x40010800

                          AREA ||i.bsp_spiRead1||, CODE, READONLY, ALIGN=2

                  bsp_spiRead1 PROC
;;;328    */
;;;329    uint8_t bsp_spiRead1(void)
000000  b570              PUSH     {r4-r6,lr}
;;;330    {
;;;331    #ifdef SOFT_SPI		/* 软件SPI */
;;;332    	uint8_t i;
;;;333    	uint8_t read = 0;
000002  2400              MOVS     r4,#0
;;;334    
;;;335    	for (i = 0; i < 8; i++)
000004  2500              MOVS     r5,#0
000006  e017              B        |L8.56|
                  |L8.8|
;;;336    	{
;;;337    		SCK_0();
000008  2020              MOVS     r0,#0x20
00000a  490d              LDR      r1,|L8.64|
00000c  6008              STR      r0,[r1,#0]
;;;338    		bsp_spiDelay();
00000e  f7fffffe          BL       bsp_spiDelay
;;;339    		read = read << 1;
000012  0660              LSLS     r0,r4,#25
000014  0e04              LSRS     r4,r0,#24
;;;340    		if (MISO_IS_HIGH())
000016  2140              MOVS     r1,#0x40
000018  4809              LDR      r0,|L8.64|
00001a  3814              SUBS     r0,r0,#0x14
00001c  f7fffffe          BL       GPIO_ReadInputDataBit
000020  2801              CMP      r0,#1
000022  d101              BNE      |L8.40|
;;;341    		{
;;;342    			read++;
000024  1c60              ADDS     r0,r4,#1
000026  b2c4              UXTB     r4,r0
                  |L8.40|
;;;343    		}
;;;344    		SCK_1();
000028  2020              MOVS     r0,#0x20
00002a  4905              LDR      r1,|L8.64|
00002c  1f09              SUBS     r1,r1,#4
00002e  6008              STR      r0,[r1,#0]
;;;345    		bsp_spiDelay();
000030  f7fffffe          BL       bsp_spiDelay
000034  1c68              ADDS     r0,r5,#1              ;335
000036  b2c5              UXTB     r5,r0                 ;335
                  |L8.56|
000038  2d08              CMP      r5,#8                 ;335
00003a  dbe5              BLT      |L8.8|
;;;346    	}
;;;347    	return read;
00003c  4620              MOV      r0,r4
;;;348    #endif
;;;349    
;;;350    #ifdef HARD_SPI		/* 硬件SPI */
;;;351    	uint8_t read;
;;;352    
;;;353    	/* 等待发送缓冲区空 */
;;;354    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET);
;;;355    
;;;356    	/* 发送一个字节 */
;;;357    	SPI_I2S_SendData(SPI1, 0);
;;;358    
;;;359    	/* 等待数据接收完毕 */
;;;360    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET);
;;;361    
;;;362    	/* 读取接收到的数据 */
;;;363    	read = SPI_I2S_ReceiveData(SPI1);
;;;364    
;;;365    	/* 返回读到的数据 */
;;;366    	return read;
;;;367    #endif
;;;368    }
00003e  bd70              POP      {r4-r6,pc}
;;;369    
                          ENDP

                  |L8.64|
                          DCD      0x40010814

                          AREA ||i.bsp_spiWrite0||, CODE, READONLY, ALIGN=2

                  bsp_spiWrite0 PROC
;;;185    */
;;;186    void bsp_spiWrite0(uint8_t _ucByte)
000000  b500              PUSH     {lr}
;;;187    {
000002  4602              MOV      r2,r0
;;;188    #ifdef SOFT_SPI		/* 软件SPI */
;;;189    	uint8_t i;
;;;190    
;;;191    	for(i = 0; i < 8; i++)
000004  2300              MOVS     r3,#0
000006  e019              B        |L9.60|
                  |L9.8|
;;;192    	{
;;;193    		if (_ucByte & 0x80)
000008  f0020080          AND      r0,r2,#0x80
00000c  b118              CBZ      r0,|L9.22|
;;;194    		{
;;;195    			MOSI_1();
00000e  2080              MOVS     r0,#0x80
000010  490d              LDR      r1,|L9.72|
000012  6008              STR      r0,[r1,#0]
000014  e003              B        |L9.30|
                  |L9.22|
;;;196    		}
;;;197    		else
;;;198    		{
;;;199    			MOSI_0();
000016  2080              MOVS     r0,#0x80
000018  490b              LDR      r1,|L9.72|
00001a  1d09              ADDS     r1,r1,#4
00001c  6008              STR      r0,[r1,#0]
                  |L9.30|
;;;200    		}
;;;201    		bsp_spiDelay();
00001e  f7fffffe          BL       bsp_spiDelay
;;;202    		SCK_1();
000022  2020              MOVS     r0,#0x20
000024  4908              LDR      r1,|L9.72|
000026  6008              STR      r0,[r1,#0]
;;;203    		_ucByte <<= 1;
000028  0650              LSLS     r0,r2,#25
00002a  0e02              LSRS     r2,r0,#24
;;;204    		bsp_spiDelay();
00002c  f7fffffe          BL       bsp_spiDelay
;;;205    		SCK_0();
000030  2020              MOVS     r0,#0x20
000032  4905              LDR      r1,|L9.72|
000034  1d09              ADDS     r1,r1,#4
000036  6008              STR      r0,[r1,#0]
000038  1c58              ADDS     r0,r3,#1              ;191
00003a  b2c3              UXTB     r3,r0                 ;191
                  |L9.60|
00003c  2b08              CMP      r3,#8                 ;191
00003e  dbe3              BLT      |L9.8|
;;;206    	}
;;;207    	bsp_spiDelay();
000040  f7fffffe          BL       bsp_spiDelay
;;;208    #endif
;;;209    
;;;210    #ifdef HARD_SPI		/* 硬件SPI */
;;;211    	/* 等待发送缓冲区空 */
;;;212    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET);
;;;213    
;;;214    	/* 发送一个字节 */
;;;215    	SPI_I2S_SendData(SPI1, _ucByte);
;;;216    
;;;217    	/* 等待数据接收完毕 */
;;;218    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET);
;;;219    
;;;220    	/* 读取接收到的数据 */
;;;221    	SPI_I2S_ReceiveData(SPI1);
;;;222    #endif
;;;223    }
000044  bd00              POP      {pc}
;;;224    
                          ENDP

000046  0000              DCW      0x0000
                  |L9.72|
                          DCD      0x40010810

                          AREA ||i.bsp_spiWrite1||, CODE, READONLY, ALIGN=2

                  bsp_spiWrite1 PROC
;;;282    */
;;;283    void bsp_spiWrite1(uint8_t _ucByte)
000000  b500              PUSH     {lr}
;;;284    {
000002  4602              MOV      r2,r0
;;;285    #ifdef SOFT_SPI		/* 软件SPI */
;;;286    	uint8_t i;
;;;287    
;;;288    	for(i = 0; i < 8; i++)
000004  2300              MOVS     r3,#0
000006  e019              B        |L10.60|
                  |L10.8|
;;;289    	{
;;;290    		if (_ucByte & 0x80)
000008  f0020080          AND      r0,r2,#0x80
00000c  b118              CBZ      r0,|L10.22|
;;;291    		{
;;;292    			MOSI_1();
00000e  2080              MOVS     r0,#0x80
000010  490c              LDR      r1,|L10.68|
000012  6008              STR      r0,[r1,#0]
000014  e003              B        |L10.30|
                  |L10.22|
;;;293    		}
;;;294    		else
;;;295    		{
;;;296    			MOSI_0();
000016  2080              MOVS     r0,#0x80
000018  490a              LDR      r1,|L10.68|
00001a  1d09              ADDS     r1,r1,#4
00001c  6008              STR      r0,[r1,#0]
                  |L10.30|
;;;297    		}
;;;298    		SCK_0();
00001e  2020              MOVS     r0,#0x20
000020  4908              LDR      r1,|L10.68|
000022  1d09              ADDS     r1,r1,#4
000024  6008              STR      r0,[r1,#0]
;;;299    		_ucByte <<= 1;
000026  0650              LSLS     r0,r2,#25
000028  0e02              LSRS     r2,r0,#24
;;;300    		bsp_spiDelay();
00002a  f7fffffe          BL       bsp_spiDelay
;;;301    		SCK_1();				/* SCK上升沿采集数据, SCK空闲时为高电平 */
00002e  2020              MOVS     r0,#0x20
000030  4904              LDR      r1,|L10.68|
000032  6008              STR      r0,[r1,#0]
;;;302    		bsp_spiDelay();
000034  f7fffffe          BL       bsp_spiDelay
000038  1c58              ADDS     r0,r3,#1              ;288
00003a  b2c3              UXTB     r3,r0                 ;288
                  |L10.60|
00003c  2b08              CMP      r3,#8                 ;288
00003e  dbe3              BLT      |L10.8|
;;;303    	}
;;;304    #endif
;;;305    
;;;306    #ifdef HARD_SPI		/* 硬件SPI */
;;;307    	/* 等待发送缓冲区空 */
;;;308    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET);
;;;309    
;;;310    	/* 发送一个字节 */
;;;311    	SPI_I2S_SendData(SPI1, _ucByte);
;;;312    
;;;313    	/* 等待数据接收完毕 */
;;;314    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET);
;;;315    
;;;316    	/* 读取接收到的数据 */
;;;317    	SPI_I2S_ReceiveData(SPI1);
;;;318    #endif
;;;319    }
000040  bd00              POP      {pc}
;;;320    
                          ENDP

000042  0000              DCW      0x0000
                  |L10.68|
                          DCD      0x40010810

                          AREA ||.data||, DATA, ALIGN=0

                  g_spi_busy
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_spi_bus.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_spi_bus_c_c88bcf96____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___13_bsp_spi_bus_c_c88bcf96____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_spi_bus_c_c88bcf96____REVSH|
#line 128
|__asm___13_bsp_spi_bus_c_c88bcf96____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

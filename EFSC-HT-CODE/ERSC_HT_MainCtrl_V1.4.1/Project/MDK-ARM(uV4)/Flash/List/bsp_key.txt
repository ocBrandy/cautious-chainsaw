; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_key.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_key.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\FatFS\src -I..\..\User\Mass_Storage\inc -I..\..\User\LCD_Driver -I..\..\User\SYSTEM\sys -I..\..\User\Debugprintf -I..\..\User\LogDebug -I..\..\User\app\inc -I..\..\User\app\src -I..\..\User\bsp\inc -I..\..\User\bsp\src -I.\RTE\_Flash -ID:\Keil_v5\ARM\Packs\ARM\CMSIS\5.5.1\CMSIS\Core\Include -ID:\Keil_v5\ARM\Packs\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=527 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_key.crf ..\..\User\bsp\src\bsp_key.c]
                          THUMB

                          AREA ||i.IsKeyDownK1||, CODE, READONLY, ALIGN=2

                  IsKeyDownK1 PROC
;;;118    //按键按下，高电平返回1
;;;119    static uint8_t IsKeyDownK1(void) {if ((GPIO_PORT_K1->IDR & GPIO_PIN_K1) != 0) return 1;else return 0;}
000000  4804              LDR      r0,|L1.20|
000002  6800              LDR      r0,[r0,#0]
000004  f4006000          AND      r0,r0,#0x800
000008  b108              CBZ      r0,|L1.14|
00000a  2001              MOVS     r0,#1
                  |L1.12|
00000c  4770              BX       lr
                  |L1.14|
00000e  2000              MOVS     r0,#0
000010  e7fc              B        |L1.12|
;;;120    static uint8_t IsKeyDownK2(void) {if ((GPIO_PORT_K2->IDR & GPIO_PIN_K2) != 0) return 1;else return 0;}
                          ENDP

000012  0000              DCW      0x0000
                  |L1.20|
                          DCD      0x40011808

                          AREA ||i.IsKeyDownK2||, CODE, READONLY, ALIGN=2

                  IsKeyDownK2 PROC
;;;119    static uint8_t IsKeyDownK1(void) {if ((GPIO_PORT_K1->IDR & GPIO_PIN_K1) != 0) return 1;else return 0;}
;;;120    static uint8_t IsKeyDownK2(void) {if ((GPIO_PORT_K2->IDR & GPIO_PIN_K2) != 0) return 1;else return 0;}
000000  4804              LDR      r0,|L2.20|
000002  6800              LDR      r0,[r0,#0]
000004  f4006080          AND      r0,r0,#0x400
000008  b108              CBZ      r0,|L2.14|
00000a  2001              MOVS     r0,#1
                  |L2.12|
00000c  4770              BX       lr
                  |L2.14|
00000e  2000              MOVS     r0,#0
000010  e7fc              B        |L2.12|
;;;121    static uint8_t IsKeyDownK3(void) {if ((GPIO_PORT_K3->IDR & GPIO_PIN_K3) != 0) return 1;else return 0;}
                          ENDP

000012  0000              DCW      0x0000
                  |L2.20|
                          DCD      0x40011808

                          AREA ||i.IsKeyDownK3||, CODE, READONLY, ALIGN=2

                  IsKeyDownK3 PROC
;;;120    static uint8_t IsKeyDownK2(void) {if ((GPIO_PORT_K2->IDR & GPIO_PIN_K2) != 0) return 1;else return 0;}
;;;121    static uint8_t IsKeyDownK3(void) {if ((GPIO_PORT_K3->IDR & GPIO_PIN_K3) != 0) return 1;else return 0;}
000000  4804              LDR      r0,|L3.20|
000002  6800              LDR      r0,[r0,#0]
000004  f4007000          AND      r0,r0,#0x200
000008  b108              CBZ      r0,|L3.14|
00000a  2001              MOVS     r0,#1
                  |L3.12|
00000c  4770              BX       lr
                  |L3.14|
00000e  2000              MOVS     r0,#0
000010  e7fc              B        |L3.12|
;;;122    static uint8_t IsKeyDownK4(void) {if ((GPIO_PORT_K4->IDR & GPIO_PIN_K4) != 0) return 0;else return 1;}
                          ENDP

000012  0000              DCW      0x0000
                  |L3.20|
                          DCD      0x40011808

                          AREA ||i.IsKeyDownK4||, CODE, READONLY, ALIGN=2

                  IsKeyDownK4 PROC
;;;121    static uint8_t IsKeyDownK3(void) {if ((GPIO_PORT_K3->IDR & GPIO_PIN_K3) != 0) return 1;else return 0;}
;;;122    static uint8_t IsKeyDownK4(void) {if ((GPIO_PORT_K4->IDR & GPIO_PIN_K4) != 0) return 0;else return 1;}
000000  4804              LDR      r0,|L4.20|
000002  6800              LDR      r0,[r0,#0]
000004  f4004080          AND      r0,r0,#0x4000
000008  b108              CBZ      r0,|L4.14|
00000a  2000              MOVS     r0,#0
                  |L4.12|
00000c  4770              BX       lr
                  |L4.14|
00000e  2001              MOVS     r0,#1
000010  e7fc              B        |L4.12|
;;;123    static uint8_t IsKeyDownK5(void) {if ((GPIO_PORT_K5->IDR & GPIO_PIN_K5) != 0) return 0;else return 1;}
                          ENDP

000012  0000              DCW      0x0000
                  |L4.20|
                          DCD      0x40011808

                          AREA ||i.IsKeyDownK5||, CODE, READONLY, ALIGN=2

                  IsKeyDownK5 PROC
;;;122    static uint8_t IsKeyDownK4(void) {if ((GPIO_PORT_K4->IDR & GPIO_PIN_K4) != 0) return 0;else return 1;}
;;;123    static uint8_t IsKeyDownK5(void) {if ((GPIO_PORT_K5->IDR & GPIO_PIN_K5) != 0) return 0;else return 1;}
000000  4804              LDR      r0,|L5.20|
000002  6800              LDR      r0,[r0,#0]
000004  f4005000          AND      r0,r0,#0x2000
000008  b108              CBZ      r0,|L5.14|
00000a  2000              MOVS     r0,#0
                  |L5.12|
00000c  4770              BX       lr
                  |L5.14|
00000e  2001              MOVS     r0,#1
000010  e7fc              B        |L5.12|
;;;124    static uint8_t IsKeyDownK6(void) {if ((GPIO_PORT_K6->IDR & GPIO_PIN_K6) != 0) return 0;else return 1;}
                          ENDP

000012  0000              DCW      0x0000
                  |L5.20|
                          DCD      0x40011808

                          AREA ||i.IsKeyDownK6||, CODE, READONLY, ALIGN=2

                  IsKeyDownK6 PROC
;;;123    static uint8_t IsKeyDownK5(void) {if ((GPIO_PORT_K5->IDR & GPIO_PIN_K5) != 0) return 0;else return 1;}
;;;124    static uint8_t IsKeyDownK6(void) {if ((GPIO_PORT_K6->IDR & GPIO_PIN_K6) != 0) return 0;else return 1;}
000000  4804              LDR      r0,|L6.20|
000002  6800              LDR      r0,[r0,#0]
000004  f4005080          AND      r0,r0,#0x1000
000008  b108              CBZ      r0,|L6.14|
00000a  2000              MOVS     r0,#0
                  |L6.12|
00000c  4770              BX       lr
                  |L6.14|
00000e  2001              MOVS     r0,#1
000010  e7fc              B        |L6.12|
;;;125    //static uint8_t IsKeyDown10(void) {if (IsKeyDown1() && IsKeyDown2()) return 1;else return 0;}		/* K1 K2组合键 */
                          ENDP

000012  0000              DCW      0x0000
                  |L6.20|
                          DCD      0x40011808

                          AREA ||i.bsp_ClearKey||, CODE, READONLY, ALIGN=2

                  bsp_ClearKey PROC
;;;311    */
;;;312    void bsp_ClearKey(void)
000000  4802              LDR      r0,|L7.12|
;;;313    {
;;;314    	s_tKey.Read = s_tKey.Write;
000002  7d40              LDRB     r0,[r0,#0x15]  ; s_tKey
000004  4901              LDR      r1,|L7.12|
000006  7508              STRB     r0,[r1,#0x14]
;;;315    }
000008  4770              BX       lr
;;;316    
                          ENDP

00000a  0000              DCW      0x0000
                  |L7.12|
                          DCD      s_tKey

                          AREA ||i.bsp_DetectKey||, CODE, READONLY, ALIGN=2

                  bsp_DetectKey PROC
;;;412    */
;;;413    static void bsp_DetectKey(uint8_t i)
000000  b570              PUSH     {r4-r6,lr}
;;;414    {
000002  4605              MOV      r5,r0
;;;415    	KEY_T *pBtn;
;;;416    
;;;417    	/*
;;;418    		如果没有初始化按键函数，则报错
;;;419    		if (s_tBtn[i].IsKeyDownFunc == 0)
;;;420    		{
;;;421    			printf("Fault : DetectButton(), s_tBtn[i].IsKeyDownFunc undefine");
;;;422    		}
;;;423    	*/
;;;424    //按键按下
;;;425    	pBtn = &s_tBtn[i];
000004  4830              LDR      r0,|L8.200|
000006  eb001405          ADD      r4,r0,r5,LSL #4
;;;426    	if (pBtn->IsKeyDownFunc())
00000a  6820              LDR      r0,[r4,#0]
00000c  4780              BLX      r0
00000e  2800              CMP      r0,#0
000010  d03e              BEQ      |L8.144|
;;;427    	{
;;;428    		//短按键，软件处理消抖
;;;429    		if (pBtn->Count < KEY_FILTER_TIME)
000012  7920              LDRB     r0,[r4,#4]
000014  2805              CMP      r0,#5
000016  da02              BGE      |L8.30|
;;;430    		{
;;;431    			pBtn->Count = KEY_FILTER_TIME;
000018  2005              MOVS     r0,#5
00001a  7120              STRB     r0,[r4,#4]
00001c  e052              B        |L8.196|
                  |L8.30|
;;;432    		}
;;;433    		else if(pBtn->Count < 2 * KEY_FILTER_TIME)
00001e  7920              LDRB     r0,[r4,#4]
000020  280a              CMP      r0,#0xa
000022  da03              BGE      |L8.44|
;;;434    		{
;;;435    			pBtn->Count++;
000024  7920              LDRB     r0,[r4,#4]
000026  1c40              ADDS     r0,r0,#1
000028  7120              STRB     r0,[r4,#4]
00002a  e04b              B        |L8.196|
                  |L8.44|
;;;436    		}
;;;437    		else
;;;438    		{
;;;439    			if (pBtn->State == 0)
00002c  7aa0              LDRB     r0,[r4,#0xa]
00002e  b938              CBNZ     r0,|L8.64|
;;;440    			{
;;;441    				pBtn->State = 1;
000030  2001              MOVS     r0,#1
000032  72a0              STRB     r0,[r4,#0xa]
;;;442    
;;;443    				/* 发送按钮按下的消息 */
;;;444    				bsp_PutKey((uint8_t)(3 * i + 1));
000034  eb050145          ADD      r1,r5,r5,LSL #1
000038  1c49              ADDS     r1,r1,#1
00003a  b2c8              UXTB     r0,r1
00003c  f7fffffe          BL       bsp_PutKey
                  |L8.64|
;;;445    //				comSendChar(COM1,(uint8_t)(3 * i + 1));	
;;;446    			}
;;;447    	//处理长按键
;;;448    			if (pBtn->LongTime > 0)
000040  8920              LDRH     r0,[r4,#8]
000042  2800              CMP      r0,#0
000044  dd3e              BLE      |L8.196|
;;;449    			{
;;;450    				
;;;451    				if (pBtn->LongCount < pBtn->LongTime)
000046  88e0              LDRH     r0,[r4,#6]
000048  8921              LDRH     r1,[r4,#8]
00004a  4288              CMP      r0,r1
00004c  da0d              BGE      |L8.106|
;;;452    				{
;;;453    					/* 发送按钮持续按下的消息 */
;;;454    					if (++pBtn->LongCount == pBtn->LongTime)
00004e  88e0              LDRH     r0,[r4,#6]
000050  1c40              ADDS     r0,r0,#1
000052  b280              UXTH     r0,r0
000054  80e0              STRH     r0,[r4,#6]
000056  8921              LDRH     r1,[r4,#8]
000058  4288              CMP      r0,r1
00005a  d133              BNE      |L8.196|
;;;455    					{
;;;456    						/* 键值放入按键FIFO */
;;;457    						bsp_PutKey((uint8_t)(3 * i + 3));
00005c  eb050145          ADD      r1,r5,r5,LSL #1
000060  1cc9              ADDS     r1,r1,#3
000062  b2c8              UXTB     r0,r1
000064  f7fffffe          BL       bsp_PutKey
000068  e02c              B        |L8.196|
                  |L8.106|
;;;458    //						comSendChar(COM1,(uint8_t)(3 * i + 3));
;;;459    					}
;;;460    				}
;;;461    				else
;;;462    				{
;;;463    					if (pBtn->RepeatSpeed > 0)
00006a  7ae0              LDRB     r0,[r4,#0xb]
00006c  2800              CMP      r0,#0
00006e  dd29              BLE      |L8.196|
;;;464    					{
;;;465    						if (++pBtn->RepeatCount >= pBtn->RepeatSpeed)
000070  7b20              LDRB     r0,[r4,#0xc]
000072  1c40              ADDS     r0,r0,#1
000074  b2c0              UXTB     r0,r0
000076  7320              STRB     r0,[r4,#0xc]
000078  7ae1              LDRB     r1,[r4,#0xb]
00007a  4288              CMP      r0,r1
00007c  db22              BLT      |L8.196|
;;;466    						{
;;;467    							pBtn->RepeatCount = 0;
00007e  2000              MOVS     r0,#0
000080  7320              STRB     r0,[r4,#0xc]
;;;468    							/* 长按键后，每隔pBtn->RepeatSpeed*10ms发送1个按键  */
;;;469    							bsp_PutKey((uint8_t)(3 * i + 3));				
000082  eb050145          ADD      r1,r5,r5,LSL #1
000086  1cc9              ADDS     r1,r1,#3
000088  b2c8              UXTB     r0,r1
00008a  f7fffffe          BL       bsp_PutKey
00008e  e019              B        |L8.196|
                  |L8.144|
;;;470    //						comSendChar(COM1,(uint8_t)(3 * i + 3));
;;;471    						}
;;;472    					}
;;;473    				}
;;;474    			}
;;;475    		}
;;;476    	}
;;;477    	else
;;;478    	{
;;;479    		if(pBtn->Count > KEY_FILTER_TIME)
000090  7920              LDRB     r0,[r4,#4]
000092  2805              CMP      r0,#5
000094  dd02              BLE      |L8.156|
;;;480    		{
;;;481    			pBtn->Count = KEY_FILTER_TIME;
000096  2005              MOVS     r0,#5
000098  7120              STRB     r0,[r4,#4]
00009a  e010              B        |L8.190|
                  |L8.156|
;;;482    		}
;;;483    		else if(pBtn->Count != 0)
00009c  7920              LDRB     r0,[r4,#4]
00009e  b118              CBZ      r0,|L8.168|
;;;484    		{
;;;485    			pBtn->Count--;
0000a0  7920              LDRB     r0,[r4,#4]
0000a2  1e40              SUBS     r0,r0,#1
0000a4  7120              STRB     r0,[r4,#4]
0000a6  e00a              B        |L8.190|
                  |L8.168|
;;;486    		}
;;;487    		else
;;;488    		{
;;;489    			if (pBtn->State == 1)
0000a8  7aa0              LDRB     r0,[r4,#0xa]
0000aa  2801              CMP      r0,#1
0000ac  d107              BNE      |L8.190|
;;;490    			{
;;;491    				pBtn->State = 0;
0000ae  2000              MOVS     r0,#0
0000b0  72a0              STRB     r0,[r4,#0xa]
;;;492    
;;;493    				/* 松开按键KEY_FILTER_TIME后 发送按钮弹起的消息 */
;;;494    				bsp_PutKey((uint8_t)(3 * i + 2));
0000b2  eb050145          ADD      r1,r5,r5,LSL #1
0000b6  1c89              ADDS     r1,r1,#2
0000b8  b2c8              UXTB     r0,r1
0000ba  f7fffffe          BL       bsp_PutKey
                  |L8.190|
;;;495    //				comSendChar(COM1,(uint8_t)(3 * i + 2));
;;;496    			}
;;;497    		}
;;;498    
;;;499    		pBtn->LongCount = 0;
0000be  2000              MOVS     r0,#0
0000c0  80e0              STRH     r0,[r4,#6]
;;;500    		pBtn->RepeatCount = 0;
0000c2  7320              STRB     r0,[r4,#0xc]
                  |L8.196|
;;;501    	}
;;;502    }
0000c4  bd70              POP      {r4-r6,pc}
;;;503    
                          ENDP

0000c6  0000              DCW      0x0000
                  |L8.200|
                          DCD      s_tBtn

                          AREA ||i.bsp_GetKey||, CODE, READONLY, ALIGN=2

                  bsp_GetKey PROC
;;;224    */
;;;225    uint8_t bsp_GetKey(void)
000000  480b              LDR      r0,|L9.48|
;;;226    {
;;;227    	uint8_t ret;
;;;228    
;;;229    	if (s_tKey.Read == s_tKey.Write)
000002  7d00              LDRB     r0,[r0,#0x14]  ; s_tKey
000004  4a0a              LDR      r2,|L9.48|
000006  7d52              LDRB     r2,[r2,#0x15]  ; s_tKey
000008  4290              CMP      r0,r2
00000a  d101              BNE      |L9.16|
;;;230    	{
;;;231    		return KEY_NONE;
00000c  2000              MOVS     r0,#0
                  |L9.14|
;;;232    	}
;;;233    	else
;;;234    	{
;;;235    		ret = s_tKey.Buf[s_tKey.Read];
;;;236    
;;;237    		if (++s_tKey.Read >= KEY_FIFO_SIZE)
;;;238    		{
;;;239    			s_tKey.Read = 0;
;;;240    		}
;;;241    		return ret;
;;;242    	}
;;;243    }
00000e  4770              BX       lr
                  |L9.16|
000010  4807              LDR      r0,|L9.48|
000012  7d00              LDRB     r0,[r0,#0x14]         ;235  ; s_tKey
000014  4a06              LDR      r2,|L9.48|
000016  5c11              LDRB     r1,[r2,r0]            ;235
000018  4610              MOV      r0,r2                 ;237
00001a  7d00              LDRB     r0,[r0,#0x14]         ;237  ; s_tKey
00001c  1c40              ADDS     r0,r0,#1              ;237
00001e  b2c0              UXTB     r0,r0                 ;237
000020  7510              STRB     r0,[r2,#0x14]         ;237
000022  2814              CMP      r0,#0x14              ;237
000024  db01              BLT      |L9.42|
000026  2000              MOVS     r0,#0                 ;239
000028  7510              STRB     r0,[r2,#0x14]         ;239
                  |L9.42|
00002a  4608              MOV      r0,r1                 ;241
00002c  e7ef              B        |L9.14|
;;;244    
                          ENDP

00002e  0000              DCW      0x0000
                  |L9.48|
                          DCD      s_tKey

                          AREA ||i.bsp_GetKey2||, CODE, READONLY, ALIGN=2

                  bsp_GetKey2 PROC
;;;252    */
;;;253    uint8_t bsp_GetKey2(void)
000000  480b              LDR      r0,|L10.48|
;;;254    {
;;;255    	uint8_t ret;
;;;256    
;;;257    	if (s_tKey.Read2 == s_tKey.Write)
000002  7d80              LDRB     r0,[r0,#0x16]  ; s_tKey
000004  4a0a              LDR      r2,|L10.48|
000006  7d52              LDRB     r2,[r2,#0x15]  ; s_tKey
000008  4290              CMP      r0,r2
00000a  d101              BNE      |L10.16|
;;;258    	{
;;;259    		return KEY_NONE;
00000c  2000              MOVS     r0,#0
                  |L10.14|
;;;260    	}
;;;261    	else
;;;262    	{
;;;263    		ret = s_tKey.Buf[s_tKey.Read2];
;;;264    
;;;265    		if (++s_tKey.Read2 >= KEY_FIFO_SIZE)
;;;266    		{
;;;267    			s_tKey.Read2 = 0;
;;;268    		}
;;;269    		return ret;
;;;270    	}
;;;271    }
00000e  4770              BX       lr
                  |L10.16|
000010  4807              LDR      r0,|L10.48|
000012  7d80              LDRB     r0,[r0,#0x16]         ;263  ; s_tKey
000014  4a06              LDR      r2,|L10.48|
000016  5c11              LDRB     r1,[r2,r0]            ;263
000018  4610              MOV      r0,r2                 ;265
00001a  7d80              LDRB     r0,[r0,#0x16]         ;265  ; s_tKey
00001c  1c40              ADDS     r0,r0,#1              ;265
00001e  b2c0              UXTB     r0,r0                 ;265
000020  7590              STRB     r0,[r2,#0x16]         ;265
000022  2814              CMP      r0,#0x14              ;265
000024  db01              BLT      |L10.42|
000026  2000              MOVS     r0,#0                 ;267
000028  7590              STRB     r0,[r2,#0x16]         ;267
                  |L10.42|
00002a  4608              MOV      r0,r1                 ;269
00002c  e7ef              B        |L10.14|
;;;272    
                          ENDP

00002e  0000              DCW      0x0000
                  |L10.48|
                          DCD      s_tKey

                          AREA ||i.bsp_GetKeyState||, CODE, READONLY, ALIGN=2

                  bsp_GetKeyState PROC
;;;280    */
;;;281    uint8_t bsp_GetKeyState(KEY_ID_E _ucKeyID)
000000  4601              MOV      r1,r0
;;;282    {
;;;283    	return s_tBtn[_ucKeyID].State;
000002  4802              LDR      r0,|L11.12|
000004  eb001001          ADD      r0,r0,r1,LSL #4
000008  7a80              LDRB     r0,[r0,#0xa]
;;;284    }
00000a  4770              BX       lr
;;;285    
                          ENDP

                  |L11.12|
                          DCD      s_tBtn

                          AREA ||i.bsp_InitKey||, CODE, READONLY, ALIGN=1

                  bsp_InitKey PROC
;;;192    */
;;;193    void bsp_InitKey(void)
000000  b510              PUSH     {r4,lr}
;;;194    {
;;;195    	bsp_InitKeyVar();		/* 初始化按键变量 */
000002  f7fffffe          BL       bsp_InitKeyVar
;;;196    	bsp_InitKeyHard();		/* 初始化按键硬件 */
000006  f7fffffe          BL       bsp_InitKeyHard
;;;197    }
00000a  bd10              POP      {r4,pc}
;;;198    
                          ENDP


                          AREA ||i.bsp_InitKeyHard||, CODE, READONLY, ALIGN=2

                  bsp_InitKeyHard PROC
;;;324    */
;;;325    static void bsp_InitKeyHard(void)
000000  b508              PUSH     {r3,lr}
;;;326    {
;;;327    	GPIO_InitTypeDef GPIO_InitStructure;
;;;328    
;;;329    	/* 第1步：打开GPIO时钟 */
;;;330    	RCC_APB2PeriphClockCmd(RCC_ALL_KEY, ENABLE);
000002  2101              MOVS     r1,#1
000004  2040              MOVS     r0,#0x40
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;331    
;;;332    	/* 第2步：配置所有的按键GPIO为浮动输入模式(实际上CPU复位后就是输入状态) */
;;;333    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00000a  2003              MOVS     r0,#3
00000c  f88d0002          STRB     r0,[sp,#2]
;;;334    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;	/* 输入浮空模式 */
000010  2004              MOVS     r0,#4
000012  f88d0003          STRB     r0,[sp,#3]
;;;335    	
;;;336    	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_K1;
000016  0240              LSLS     r0,r0,#9
000018  f8ad0000          STRH     r0,[sp,#0]
;;;337    	GPIO_Init(GPIO_PORT_K1, &GPIO_InitStructure);
00001c  4669              MOV      r1,sp
00001e  4816              LDR      r0,|L13.120|
000020  f7fffffe          BL       GPIO_Init
;;;338    
;;;339    	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_K2;
000024  f44f6080          MOV      r0,#0x400
000028  f8ad0000          STRH     r0,[sp,#0]
;;;340    	GPIO_Init(GPIO_PORT_K2, &GPIO_InitStructure);
00002c  4669              MOV      r1,sp
00002e  4812              LDR      r0,|L13.120|
000030  f7fffffe          BL       GPIO_Init
;;;341    	
;;;342    	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_K3;
000034  f44f7000          MOV      r0,#0x200
000038  f8ad0000          STRH     r0,[sp,#0]
;;;343    	GPIO_Init(GPIO_PORT_K3, &GPIO_InitStructure);
00003c  4669              MOV      r1,sp
00003e  480e              LDR      r0,|L13.120|
000040  f7fffffe          BL       GPIO_Init
;;;344    	
;;;345    	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_K4;
000044  f44f4080          MOV      r0,#0x4000
000048  f8ad0000          STRH     r0,[sp,#0]
;;;346    	GPIO_Init(GPIO_PORT_K4, &GPIO_InitStructure);
00004c  4669              MOV      r1,sp
00004e  480a              LDR      r0,|L13.120|
000050  f7fffffe          BL       GPIO_Init
;;;347    	
;;;348    	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_K5;
000054  f44f5000          MOV      r0,#0x2000
000058  f8ad0000          STRH     r0,[sp,#0]
;;;349    	GPIO_Init(GPIO_PORT_K5, &GPIO_InitStructure);
00005c  4669              MOV      r1,sp
00005e  4806              LDR      r0,|L13.120|
000060  f7fffffe          BL       GPIO_Init
;;;350    	
;;;351    	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_K6;
000064  f44f5080          MOV      r0,#0x1000
000068  f8ad0000          STRH     r0,[sp,#0]
;;;352    	GPIO_Init(GPIO_PORT_K6, &GPIO_InitStructure);
00006c  4669              MOV      r1,sp
00006e  4802              LDR      r0,|L13.120|
000070  f7fffffe          BL       GPIO_Init
;;;353    	
;;;354    }
000074  bd08              POP      {r3,pc}
;;;355    
                          ENDP

000076  0000              DCW      0x0000
                  |L13.120|
                          DCD      0x40011800

                          AREA ||i.bsp_InitKeyVar||, CODE, READONLY, ALIGN=2

                  bsp_InitKeyVar PROC
;;;363    */
;;;364    static void bsp_InitKeyVar(void)
000000  2100              MOVS     r1,#0
;;;365    {
;;;366    	uint8_t i;
;;;367    
;;;368    	/* 对按键FIFO读写指针清零 */
;;;369    	s_tKey.Read = 0;
000002  4a1a              LDR      r2,|L14.108|
000004  7511              STRB     r1,[r2,#0x14]
;;;370    	s_tKey.Write = 0;
000006  7551              STRB     r1,[r2,#0x15]
;;;371    	s_tKey.Read2 = 0;
000008  7591              STRB     r1,[r2,#0x16]
;;;372    
;;;373    	/* 给每个按键结构体成员变量赋一组缺省值 */
;;;374    	for (i = 0; i < KEY_COUNT; i++)
00000a  2000              MOVS     r0,#0
00000c  e018              B        |L14.64|
                  |L14.14|
;;;375    	{
;;;376    		s_tBtn[i].LongTime = KEY_LONG_TIME;			/* 长按时间 0 表示不检测长按键事件 */
00000e  2114              MOVS     r1,#0x14
000010  4a17              LDR      r2,|L14.112|
000012  eb021200          ADD      r2,r2,r0,LSL #4
000016  8111              STRH     r1,[r2,#8]
;;;377    		s_tBtn[i].Count = KEY_FILTER_TIME / 2;		/* 计数器设置为滤波时间的一半 */
000018  2102              MOVS     r1,#2
00001a  4a15              LDR      r2,|L14.112|
00001c  eb021200          ADD      r2,r2,r0,LSL #4
000020  7111              STRB     r1,[r2,#4]
;;;378    		s_tBtn[i].State = 0;							/* 按键缺省状态，0为未按下 */
000022  2100              MOVS     r1,#0
000024  4a12              LDR      r2,|L14.112|
000026  eb021200          ADD      r2,r2,r0,LSL #4
00002a  7291              STRB     r1,[r2,#0xa]
;;;379    		//s_tBtn[i].KeyCodeDown = 3 * i + 1;				/* 按键按下的键值代码 */
;;;380    		//s_tBtn[i].KeyCodeUp   = 3 * i + 2;				/* 按键弹起的键值代码 */
;;;381    		//s_tBtn[i].KeyCodeLong = 3 * i + 3;				/* 按键被持续按下的键值代码 */
;;;382    		s_tBtn[i].RepeatSpeed = 0;						/* 按键连发的速度，0表示不支持连发 */
00002c  4a10              LDR      r2,|L14.112|
00002e  eb021200          ADD      r2,r2,r0,LSL #4
000032  72d1              STRB     r1,[r2,#0xb]
;;;383    		s_tBtn[i].RepeatCount = 0;						/* 连发计数器 */
000034  4a0e              LDR      r2,|L14.112|
000036  eb021200          ADD      r2,r2,r0,LSL #4
00003a  7311              STRB     r1,[r2,#0xc]
00003c  1c41              ADDS     r1,r0,#1              ;374
00003e  b2c8              UXTB     r0,r1                 ;374
                  |L14.64|
000040  2806              CMP      r0,#6                 ;374
000042  dbe4              BLT      |L14.14|
;;;384    	}
;;;385    	/* 如果需要单独更改某个按键的参数，可以在此单独重新赋值 */
;;;386    	/* 比如，我们希望按键1按下超过1s后，自动重发相同键值 */	
;;;387    //	s_tBtn[KID_K5].LongTime = 100;
;;;388    	s_tBtn[KID_K5].RepeatSpeed = 50;	/* 每隔250ms自动发送键值 */
000044  2232              MOVS     r2,#0x32
000046  490a              LDR      r1,|L14.112|
000048  f881204b          STRB     r2,[r1,#0x4b]
;;;389    	
;;;390    
;;;391    	s_tBtn[KID_K6].RepeatSpeed = 50;
00004c  f881205b          STRB     r2,[r1,#0x5b]
;;;392    //	s_tBtn[KID_K6].LongTime = 100;
;;;393    //	s_tBtn[KID_K6].State = 1;	
;;;394    	/* 判断按键按下的函数（监测按键是否按下） */
;;;395    	s_tBtn[0].IsKeyDownFunc = IsKeyDownK1;
000050  4908              LDR      r1,|L14.116|
000052  4a07              LDR      r2,|L14.112|
000054  6011              STR      r1,[r2,#0]  ; s_tBtn
;;;396    	s_tBtn[1].IsKeyDownFunc = IsKeyDownK2;
000056  4908              LDR      r1,|L14.120|
000058  6111              STR      r1,[r2,#0x10]  ; s_tBtn
;;;397    	s_tBtn[2].IsKeyDownFunc = IsKeyDownK3;
00005a  4908              LDR      r1,|L14.124|
00005c  6211              STR      r1,[r2,#0x20]  ; s_tBtn
;;;398    	s_tBtn[3].IsKeyDownFunc = IsKeyDownK4;
00005e  4908              LDR      r1,|L14.128|
000060  6311              STR      r1,[r2,#0x30]  ; s_tBtn
;;;399    	s_tBtn[4].IsKeyDownFunc = IsKeyDownK5;
000062  4908              LDR      r1,|L14.132|
000064  6411              STR      r1,[r2,#0x40]  ; s_tBtn
;;;400    	s_tBtn[5].IsKeyDownFunc = IsKeyDownK6;
000066  4908              LDR      r1,|L14.136|
000068  6511              STR      r1,[r2,#0x50]  ; s_tBtn
;;;401    	/* 组合键 */
;;;402    //	s_tBtn[3].IsKeyDownFunc = IsKeyDown10;
;;;403    }
00006a  4770              BX       lr
;;;404    
                          ENDP

                  |L14.108|
                          DCD      s_tKey
                  |L14.112|
                          DCD      s_tBtn
                  |L14.116|
                          DCD      IsKeyDownK1
                  |L14.120|
                          DCD      IsKeyDownK2
                  |L14.124|
                          DCD      IsKeyDownK3
                  |L14.128|
                          DCD      IsKeyDownK4
                  |L14.132|
                          DCD      IsKeyDownK5
                  |L14.136|
                          DCD      IsKeyDownK6

                          AREA ||i.bsp_KeyScan||, CODE, READONLY, ALIGN=1

                  bsp_KeyScan PROC
;;;511    */
;;;512    void bsp_KeyScan(void)
000000  b510              PUSH     {r4,lr}
;;;513    {
;;;514    	uint8_t i;
;;;515    
;;;516    	for (i = 0; i < KEY_COUNT; i++)
000002  2400              MOVS     r4,#0
000004  e004              B        |L15.16|
                  |L15.6|
;;;517    	{
;;;518    		bsp_DetectKey(i);
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       bsp_DetectKey
00000c  1c60              ADDS     r0,r4,#1              ;516
00000e  b2c4              UXTB     r4,r0                 ;516
                  |L15.16|
000010  2c06              CMP      r4,#6                 ;516
000012  dbf8              BLT      |L15.6|
;;;519    	}
;;;520    }
000014  bd10              POP      {r4,pc}
;;;521    
                          ENDP


                          AREA ||i.bsp_PutKey||, CODE, READONLY, ALIGN=2

                  bsp_PutKey PROC
;;;206    */
;;;207    void bsp_PutKey(uint8_t _KeyCode)
000000  4906              LDR      r1,|L16.28|
;;;208    {
;;;209    	s_tKey.Buf[s_tKey.Write] = _KeyCode;
000002  7d49              LDRB     r1,[r1,#0x15]  ; s_tKey
000004  4a05              LDR      r2,|L16.28|
000006  5450              STRB     r0,[r2,r1]
;;;210    
;;;211    	if (++s_tKey.Write  >= KEY_FIFO_SIZE)
000008  4611              MOV      r1,r2
00000a  7d49              LDRB     r1,[r1,#0x15]  ; s_tKey
00000c  1c49              ADDS     r1,r1,#1
00000e  b2c9              UXTB     r1,r1
000010  7551              STRB     r1,[r2,#0x15]
000012  2914              CMP      r1,#0x14
000014  db01              BLT      |L16.26|
;;;212    	{
;;;213    		s_tKey.Write = 0;
000016  2100              MOVS     r1,#0
000018  7551              STRB     r1,[r2,#0x15]
                  |L16.26|
;;;214    	}
;;;215    }
00001a  4770              BX       lr
;;;216    
                          ENDP

                  |L16.28|
                          DCD      s_tKey

                          AREA ||i.bsp_SetKeyParam||, CODE, READONLY, ALIGN=2

                  bsp_SetKeyParam PROC
;;;295    */
;;;296    void bsp_SetKeyParam(uint8_t _ucKeyID, uint16_t _LongTime, uint8_t  _RepeatSpeed)
000000  b510              PUSH     {r4,lr}
;;;297    {
;;;298    	s_tBtn[_ucKeyID].LongTime = _LongTime;			/* 长按时间 0 表示不检测长按键事件 */
000002  4b07              LDR      r3,|L17.32|
000004  eb031300          ADD      r3,r3,r0,LSL #4
000008  8119              STRH     r1,[r3,#8]
;;;299    	s_tBtn[_ucKeyID].RepeatSpeed = _RepeatSpeed;			/* 按键连发的速度，0表示不支持连发 */
00000a  4b05              LDR      r3,|L17.32|
00000c  eb031300          ADD      r3,r3,r0,LSL #4
000010  72da              STRB     r2,[r3,#0xb]
;;;300    	s_tBtn[_ucKeyID].RepeatCount = 0;						/* 连发计数器 */
000012  2300              MOVS     r3,#0
000014  4c02              LDR      r4,|L17.32|
000016  eb041400          ADD      r4,r4,r0,LSL #4
00001a  7323              STRB     r3,[r4,#0xc]
;;;301    }
00001c  bd10              POP      {r4,pc}
;;;302    
                          ENDP

00001e  0000              DCW      0x0000
                  |L17.32|
                          DCD      s_tBtn

                          AREA ||i.init_key||, CODE, READONLY, ALIGN=2

                  init_key PROC
;;;126    #endif
;;;127    void init_key(void)
000000  b510              PUSH     {r4,lr}
;;;128    {
;;;129    	
;;;130    	s_tKey.Read = 0;
000002  2000              MOVS     r0,#0
000004  4931              LDR      r1,|L18.204|
000006  7508              STRB     r0,[r1,#0x14]
;;;131    	s_tKey.Write = 0;	
000008  7548              STRB     r0,[r1,#0x15]
;;;132    	if(IsKeyDownK1() == 1)
00000a  f7fffffe          BL       IsKeyDownK1
00000e  2801              CMP      r0,#1
000010  d106              BNE      |L18.32|
;;;133    	{
;;;134    		onButtonUpdata_Rect(2,open,COLOR_GREEN); 
000012  f44f62fc          MOV      r2,#0x7e0
000016  2101              MOVS     r1,#1
000018  2002              MOVS     r0,#2
00001a  f7fffffe          BL       onButtonUpdata_Rect
00001e  e005              B        |L18.44|
                  |L18.32|
;;;135    	}
;;;136    	else
;;;137    	{
;;;138    		onButtonUpdata_Rect(2,close,COLOR_GREEN);		
000020  f44f62fc          MOV      r2,#0x7e0
000024  2100              MOVS     r1,#0
000026  2002              MOVS     r0,#2
000028  f7fffffe          BL       onButtonUpdata_Rect
                  |L18.44|
;;;139    	}
;;;140    	if(IsKeyDownK2() == 1)
00002c  f7fffffe          BL       IsKeyDownK2
000030  2801              CMP      r0,#1
000032  d106              BNE      |L18.66|
;;;141    	{
;;;142    		onButtonUpdata_Rect(3,open,COLOR_GREEN); 
000034  f44f62fc          MOV      r2,#0x7e0
000038  2101              MOVS     r1,#1
00003a  2003              MOVS     r0,#3
00003c  f7fffffe          BL       onButtonUpdata_Rect
000040  e005              B        |L18.78|
                  |L18.66|
;;;143    	}
;;;144    	else
;;;145    	{
;;;146    		onButtonUpdata_Rect(3,close,COLOR_GREEN);		
000042  f44f62fc          MOV      r2,#0x7e0
000046  2100              MOVS     r1,#0
000048  2003              MOVS     r0,#3
00004a  f7fffffe          BL       onButtonUpdata_Rect
                  |L18.78|
;;;147    	}
;;;148    	if(IsKeyDownK3() == 1)
00004e  f7fffffe          BL       IsKeyDownK3
000052  2801              CMP      r0,#1
000054  d106              BNE      |L18.100|
;;;149    	{
;;;150    		onButtonUpdata_Rect(4,open,COLOR_GREEN); 
000056  f44f62fc          MOV      r2,#0x7e0
00005a  2101              MOVS     r1,#1
00005c  2004              MOVS     r0,#4
00005e  f7fffffe          BL       onButtonUpdata_Rect
000062  e005              B        |L18.112|
                  |L18.100|
;;;151    	}
;;;152    	else
;;;153    	{
;;;154    		onButtonUpdata_Rect(4,close,COLOR_GREEN);		
000064  f44f62fc          MOV      r2,#0x7e0
000068  2100              MOVS     r1,#0
00006a  2004              MOVS     r0,#4
00006c  f7fffffe          BL       onButtonUpdata_Rect
                  |L18.112|
;;;155    	}
;;;156    	if(IsKeyDownK4() == 1)
000070  f7fffffe          BL       IsKeyDownK4
000074  2801              CMP      r0,#1
000076  d106              BNE      |L18.134|
;;;157    	{
;;;158    		onButtonUpdata_Rect(0,open,COLOR_GREEN); 
000078  f44f62fc          MOV      r2,#0x7e0
00007c  2101              MOVS     r1,#1
00007e  2000              MOVS     r0,#0
000080  f7fffffe          BL       onButtonUpdata_Rect
000084  e005              B        |L18.146|
                  |L18.134|
;;;159    	}
;;;160    	else
;;;161    	{
;;;162    		onButtonUpdata_Rect(0,close,COLOR_GREEN);		
000086  f44f62fc          MOV      r2,#0x7e0
00008a  2100              MOVS     r1,#0
00008c  4608              MOV      r0,r1
00008e  f7fffffe          BL       onButtonUpdata_Rect
                  |L18.146|
;;;163    	}
;;;164    	if(IsKeyDownK5() == 1)
000092  f7fffffe          BL       IsKeyDownK5
000096  2801              CMP      r0,#1
000098  d106              BNE      |L18.168|
;;;165    	{
;;;166    		
;;;167    		onButtonUpdata_Rect(1,open,COLOR_GREEN); 
00009a  f44f62fc          MOV      r2,#0x7e0
00009e  2101              MOVS     r1,#1
0000a0  4608              MOV      r0,r1
0000a2  f7fffffe          BL       onButtonUpdata_Rect
0000a6  e002              B        |L18.174|
                  |L18.168|
;;;168    	}
;;;169    	else
;;;170    	{
;;;171    		ButtonClear(1);//两色块全清色		
0000a8  2001              MOVS     r0,#1
0000aa  f7fffffe          BL       ButtonClear
                  |L18.174|
;;;172    //		onButtonUpdata_Rect(1,close,COLOR_GREEN);		
;;;173    	}
;;;174    	if(IsKeyDownK6() == 1)
0000ae  f7fffffe          BL       IsKeyDownK6
0000b2  2801              CMP      r0,#1
0000b4  d106              BNE      |L18.196|
;;;175    	{
;;;176    			
;;;177    		onButtonUpdata_Rect(1,open,COLOR_GREEN); 
0000b6  f44f62fc          MOV      r2,#0x7e0
0000ba  2101              MOVS     r1,#1
0000bc  4608              MOV      r0,r1
0000be  f7fffffe          BL       onButtonUpdata_Rect
0000c2  e002              B        |L18.202|
                  |L18.196|
;;;178    	}
;;;179    	else
;;;180    	{
;;;181    		ButtonClear(1);//两色块全清色	
0000c4  2001              MOVS     r0,#1
0000c6  f7fffffe          BL       ButtonClear
                  |L18.202|
;;;182    //		onButtonUpdata_Rect(1,close,COLOR_GREEN);		
;;;183    	}
;;;184    }
0000ca  bd10              POP      {r4,pc}
;;;185    /*
                          ENDP

                  |L18.204|
                          DCD      s_tKey

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  s_tBtn
                          %        96
                  s_tKey
                          %        23

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_key.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_bsp_key_c_init_key____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___9_bsp_key_c_init_key____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_bsp_key_c_init_key____REVSH|
#line 128
|__asm___9_bsp_key_c_init_key____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

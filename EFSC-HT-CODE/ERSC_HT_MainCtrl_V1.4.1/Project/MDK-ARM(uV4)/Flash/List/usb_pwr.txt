; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\usb_pwr.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\usb_pwr.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\FatFS\src -I..\..\User\Mass_Storage\inc -I..\..\User\LCD_Driver -I..\..\User\SYSTEM\sys -I..\..\User\Debugprintf -I..\..\User\LogDebug -I..\..\User\app\inc -I..\..\User\app\src -I..\..\User\bsp\inc -I..\..\User\bsp\src -I.\RTE\_Flash -ID:\Keil_v5\ARM\Packs\ARM\CMSIS\5.5.1\CMSIS\Core\Include -ID:\Keil_v5\ARM\Packs\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=527 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\usb_pwr.crf ..\..\User\Mass_Storage\src\usb_pwr.c]
                          THUMB

                          AREA ||i.PowerOff||, CODE, READONLY, ALIGN=2

                  PowerOff PROC
;;;94     *******************************************************************************/
;;;95     RESULT PowerOff()
000000  b510              PUSH     {r4,lr}
;;;96     {
;;;97     #ifndef STM32F10X_CL  
;;;98       /* disable all interrupts and force USB reset */
;;;99       _SetCNTR(CNTR_FRES);
000002  2001              MOVS     r0,#1
000004  4905              LDR      r1,|L1.28|
000006  6008              STR      r0,[r1,#0]
;;;100      /* clear interrupt status register */
;;;101      _SetISTR(0);
000008  2000              MOVS     r0,#0
00000a  1d09              ADDS     r1,r1,#4
00000c  6008              STR      r0,[r1,#0]
;;;102      /* Disable the Pull-Up*/
;;;103      USB_Cable_Config(DISABLE);
00000e  f7fffffe          BL       USB_Cable_Config
;;;104      /* switch-off device */
;;;105      _SetCNTR(CNTR_FRES + CNTR_PDWN);
000012  2003              MOVS     r0,#3
000014  4901              LDR      r1,|L1.28|
000016  6008              STR      r0,[r1,#0]
;;;106      /* sw variables reset */
;;;107      /* ... */
;;;108    #endif /* STM32F10X_CL */
;;;109    
;;;110      return USB_SUCCESS;
000018  2000              MOVS     r0,#0
;;;111    }
00001a  bd10              POP      {r4,pc}
;;;112    
                          ENDP

                  |L1.28|
                          DCD      0x40005c40

                          AREA ||i.PowerOn||, CODE, READONLY, ALIGN=2

                  PowerOn PROC
;;;61     *******************************************************************************/
;;;62     RESULT PowerOn(void)
000000  b510              PUSH     {r4,lr}
;;;63     {
;;;64     #ifndef STM32F10X_CL
;;;65       uint16_t wRegVal;
;;;66       
;;;67       /*** cable plugged-in ? ***/
;;;68       /*while(!CablePluggedIn());*/
;;;69       USB_Cable_Config(ENABLE);
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       USB_Cable_Config
;;;70     
;;;71       /*** CNTR_PWDN = 0 ***/
;;;72       wRegVal = CNTR_FRES;
000008  2401              MOVS     r4,#1
;;;73       _SetCNTR(wRegVal);
00000a  480b              LDR      r0,|L2.56|
00000c  6004              STR      r4,[r0,#0]
;;;74     
;;;75       /*** CNTR_FRES = 0 ***/
;;;76       wInterrupt_Mask = 0;
00000e  2000              MOVS     r0,#0
000010  490a              LDR      r1,|L2.60|
000012  8008              STRH     r0,[r1,#0]
;;;77       _SetCNTR(wInterrupt_Mask);
000014  4608              MOV      r0,r1
000016  8800              LDRH     r0,[r0,#0]  ; wInterrupt_Mask
000018  4907              LDR      r1,|L2.56|
00001a  6008              STR      r0,[r1,#0]
;;;78       /*** Clear pending interrupts ***/
;;;79       _SetISTR(0);
00001c  2000              MOVS     r0,#0
00001e  1d09              ADDS     r1,r1,#4
000020  6008              STR      r0,[r1,#0]
;;;80       /*** Set interrupt mask ***/
;;;81       wInterrupt_Mask = CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM;
000022  f44f50e0          MOV      r0,#0x1c00
000026  4905              LDR      r1,|L2.60|
000028  8008              STRH     r0,[r1,#0]
;;;82       _SetCNTR(wInterrupt_Mask);
00002a  4608              MOV      r0,r1
00002c  8800              LDRH     r0,[r0,#0]  ; wInterrupt_Mask
00002e  4902              LDR      r1,|L2.56|
000030  6008              STR      r0,[r1,#0]
;;;83     #endif /* STM32F10X_CL */
;;;84       
;;;85       return USB_SUCCESS;
000032  2000              MOVS     r0,#0
;;;86     }
000034  bd10              POP      {r4,pc}
;;;87     
                          ENDP

000036  0000              DCW      0x0000
                  |L2.56|
                          DCD      0x40005c40
                  |L2.60|
                          DCD      wInterrupt_Mask

                          AREA ||i.Resume||, CODE, READONLY, ALIGN=2

                  Resume PROC
;;;196    *******************************************************************************/
;;;197    void Resume(RESUME_STATE eResumeSetVal)
000000  b570              PUSH     {r4-r6,lr}
;;;198    {
000002  4605              MOV      r5,r0
;;;199    #ifndef STM32F10X_CL
;;;200      uint16_t wCNTR;
;;;201    #endif /* STM32F10X_CL */
;;;202    
;;;203      if (eResumeSetVal != RESUME_ESOF)
000004  2d07              CMP      r5,#7
000006  d001              BEQ      |L3.12|
;;;204        ResumeS.eState = eResumeSetVal;
000008  4827              LDR      r0,|L3.168|
00000a  7005              STRB     r5,[r0,#0]
                  |L3.12|
;;;205    
;;;206      switch (ResumeS.eState)
00000c  4826              LDR      r0,|L3.168|
00000e  7800              LDRB     r0,[r0,#0]  ; ResumeS
000010  2808              CMP      r0,#8
000012  d241              BCS      |L3.152|
000014  e8dff000          TBB      [pc,r0]
000018  040a1016          DCB      0x04,0x0a,0x10,0x16
00001c  212e4142          DCB      0x21,0x2e,0x41,0x42
;;;207      {
;;;208        case RESUME_EXTERNAL:
;;;209          Resume_Init();
000020  f7fffffe          BL       Resume_Init
;;;210          ResumeS.eState = RESUME_OFF;
000024  2006              MOVS     r0,#6
000026  4920              LDR      r1,|L3.168|
000028  7008              STRB     r0,[r1,#0]
;;;211          break;
00002a  e03b              B        |L3.164|
;;;212        case RESUME_INTERNAL:
;;;213          Resume_Init();
00002c  f7fffffe          BL       Resume_Init
;;;214          ResumeS.eState = RESUME_START;
000030  2004              MOVS     r0,#4
000032  491d              LDR      r1,|L3.168|
000034  7008              STRB     r0,[r1,#0]
;;;215          break;
000036  e035              B        |L3.164|
;;;216        case RESUME_LATER:
;;;217          ResumeS.bESOFcnt = 2;
000038  2002              MOVS     r0,#2
00003a  491b              LDR      r1,|L3.168|
00003c  7048              STRB     r0,[r1,#1]
;;;218          ResumeS.eState = RESUME_WAIT;
00003e  2003              MOVS     r0,#3
000040  7008              STRB     r0,[r1,#0]
;;;219          break;
000042  e02f              B        |L3.164|
;;;220        case RESUME_WAIT:
;;;221          ResumeS.bESOFcnt--;
000044  4818              LDR      r0,|L3.168|
000046  7840              LDRB     r0,[r0,#1]  ; ResumeS
000048  1e40              SUBS     r0,r0,#1
00004a  4917              LDR      r1,|L3.168|
00004c  7048              STRB     r0,[r1,#1]
;;;222          if (ResumeS.bESOFcnt == 0)
00004e  4608              MOV      r0,r1
000050  7840              LDRB     r0,[r0,#1]  ; ResumeS
000052  b908              CBNZ     r0,|L3.88|
;;;223            ResumeS.eState = RESUME_START;
000054  2004              MOVS     r0,#4
000056  7008              STRB     r0,[r1,#0]
                  |L3.88|
;;;224          break;
000058  e024              B        |L3.164|
;;;225        case RESUME_START:
;;;226         #ifdef STM32F10X_CL
;;;227          OTGD_FS_SetRemoteWakeup();
;;;228         #else 
;;;229          wCNTR = _GetCNTR();
00005a  4814              LDR      r0,|L3.172|
00005c  6800              LDR      r0,[r0,#0]
00005e  b284              UXTH     r4,r0
;;;230          wCNTR |= CNTR_RESUME;
000060  f0440410          ORR      r4,r4,#0x10
;;;231          _SetCNTR(wCNTR);
000064  4811              LDR      r0,|L3.172|
000066  6004              STR      r4,[r0,#0]
;;;232         #endif /* STM32F10X_CL */
;;;233          ResumeS.eState = RESUME_ON;
000068  2005              MOVS     r0,#5
00006a  490f              LDR      r1,|L3.168|
00006c  7008              STRB     r0,[r1,#0]
;;;234          ResumeS.bESOFcnt = 10;
00006e  200a              MOVS     r0,#0xa
000070  7048              STRB     r0,[r1,#1]
;;;235          break;
000072  e017              B        |L3.164|
;;;236        case RESUME_ON:
;;;237        #ifndef STM32F10X_CL      
;;;238          ResumeS.bESOFcnt--;
000074  480c              LDR      r0,|L3.168|
000076  7840              LDRB     r0,[r0,#1]  ; ResumeS
000078  1e40              SUBS     r0,r0,#1
00007a  490b              LDR      r1,|L3.168|
00007c  7048              STRB     r0,[r1,#1]
;;;239          if (ResumeS.bESOFcnt == 0)
00007e  4608              MOV      r0,r1
000080  7840              LDRB     r0,[r0,#1]  ; ResumeS
000082  b940              CBNZ     r0,|L3.150|
;;;240          {
;;;241         #endif /* STM32F10X_CL */    
;;;242           #ifdef STM32F10X_CL
;;;243            OTGD_FS_ResetRemoteWakeup();
;;;244           #else
;;;245            wCNTR = _GetCNTR();
000084  4809              LDR      r0,|L3.172|
000086  6800              LDR      r0,[r0,#0]
000088  b284              UXTH     r4,r0
;;;246            wCNTR &= (~CNTR_RESUME);
00008a  f0240410          BIC      r4,r4,#0x10
;;;247            _SetCNTR(wCNTR);
00008e  4807              LDR      r0,|L3.172|
000090  6004              STR      r4,[r0,#0]
;;;248           #endif /* STM32F10X_CL */
;;;249            ResumeS.eState = RESUME_OFF;
000092  2006              MOVS     r0,#6
000094  7008              STRB     r0,[r1,#0]
                  |L3.150|
;;;250         #ifndef STM32F10X_CL
;;;251          }
;;;252         #endif /* STM32F10X_CL */
;;;253          break;
000096  e005              B        |L3.164|
                  |L3.152|
;;;254        case RESUME_OFF:
000098  bf00              NOP      
;;;255        case RESUME_ESOF:
00009a  bf00              NOP      
;;;256        default:
;;;257          ResumeS.eState = RESUME_OFF;
00009c  2006              MOVS     r0,#6
00009e  4902              LDR      r1,|L3.168|
0000a0  7008              STRB     r0,[r1,#0]
;;;258          break;
0000a2  bf00              NOP      
                  |L3.164|
0000a4  bf00              NOP                            ;211
;;;259      }
;;;260    }
0000a6  bd70              POP      {r4-r6,pc}
;;;261    
                          ENDP

                  |L3.168|
                          DCD      ResumeS
                  |L3.172|
                          DCD      0x40005c40

                          AREA ||i.Resume_Init||, CODE, READONLY, ALIGN=2

                  Resume_Init PROC
;;;157    *******************************************************************************/
;;;158    void Resume_Init(void)
000000  b510              PUSH     {r4,lr}
;;;159    {
;;;160      /* ------------------ ONLY WITH BUS-POWERED DEVICES ---------------------- */
;;;161      /* restart the clocks */
;;;162      /* ...  */
;;;163    #ifndef STM32F10X_CL
;;;164      uint16_t wCNTR;
;;;165      
;;;166      /* CNTR_LPMODE = 0 */
;;;167      wCNTR = _GetCNTR();
000002  4807              LDR      r0,|L4.32|
000004  6800              LDR      r0,[r0,#0]
000006  b284              UXTH     r4,r0
;;;168      wCNTR &= (~CNTR_LPMODE);
000008  f0240404          BIC      r4,r4,#4
;;;169      _SetCNTR(wCNTR);
00000c  4804              LDR      r0,|L4.32|
00000e  6004              STR      r4,[r0,#0]
;;;170    #endif /* STM32F10X_CL */
;;;171      
;;;172      /* restore full power */
;;;173      /* ... on connected devices */
;;;174      Leave_LowPowerMode();
000010  f7fffffe          BL       Leave_LowPowerMode
;;;175    
;;;176    #ifndef STM32F10X_CL
;;;177      /* reset FSUSP bit */
;;;178      _SetCNTR(IMR_MSK);
000014  f44f4004          MOV      r0,#0x8400
000018  4901              LDR      r1,|L4.32|
00001a  6008              STR      r0,[r1,#0]
;;;179    #endif /* STM32F10X_CL */
;;;180      
;;;181      /* reverse suspend preparation */
;;;182      /* ... */
;;;183    }
00001c  bd10              POP      {r4,pc}
;;;184    
                          ENDP

00001e  0000              DCW      0x0000
                  |L4.32|
                          DCD      0x40005c40

                          AREA ||i.Suspend||, CODE, READONLY, ALIGN=2

                  Suspend PROC
;;;119    *******************************************************************************/
;;;120    void Suspend(void)
000000  b510              PUSH     {r4,lr}
;;;121    {
;;;122    
;;;123      /* suspend preparation */
;;;124      /* ... */
;;;125      
;;;126    #ifndef STM32F10X_CL
;;;127      uint16_t wCNTR;
;;;128    
;;;129      /* macrocell enters suspend mode */
;;;130      wCNTR = _GetCNTR();
000002  4808              LDR      r0,|L5.36|
000004  6800              LDR      r0,[r0,#0]
000006  b284              UXTH     r4,r0
;;;131      wCNTR |= CNTR_FSUSP;
000008  f0440408          ORR      r4,r4,#8
;;;132      _SetCNTR(wCNTR);
00000c  4805              LDR      r0,|L5.36|
00000e  6004              STR      r4,[r0,#0]
;;;133    #endif /* STM32F10X_CL */
;;;134      
;;;135      /* ------------------ ONLY WITH BUS-POWERED DEVICES ---------------------- */
;;;136      /* power reduction */
;;;137      /* ... on connected devices */
;;;138    
;;;139    #ifndef STM32F10X_CL
;;;140      /* force low-power mode in the macrocell */
;;;141      wCNTR = _GetCNTR();
000010  6800              LDR      r0,[r0,#0]
000012  b284              UXTH     r4,r0
;;;142      wCNTR |= CNTR_LPMODE;
000014  f0440404          ORR      r4,r4,#4
;;;143      _SetCNTR(wCNTR);
000018  4802              LDR      r0,|L5.36|
00001a  6004              STR      r4,[r0,#0]
;;;144    #endif /* STM32F10X_CL */
;;;145    
;;;146      /* switch-off the clocks */
;;;147      /* ... */
;;;148      Enter_LowPowerMode();
00001c  f7fffffe          BL       Enter_LowPowerMode
;;;149    }
000020  bd10              POP      {r4,pc}
;;;150    
                          ENDP

000022  0000              DCW      0x0000
                  |L5.36|
                          DCD      0x40005c40

                          AREA ||.data||, DATA, ALIGN=2

                  bDeviceState
                          DCD      0x00000000
                  fSuspendEnabled
000004  01                DCB      0x01
                  ResumeS
000005  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\Mass_Storage\\src\\usb_pwr.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_usb_pwr_c_e4e9521d____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___9_usb_pwr_c_e4e9521d____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_usb_pwr_c_e4e9521d____REVSH|
#line 128
|__asm___9_usb_pwr_c_e4e9521d____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

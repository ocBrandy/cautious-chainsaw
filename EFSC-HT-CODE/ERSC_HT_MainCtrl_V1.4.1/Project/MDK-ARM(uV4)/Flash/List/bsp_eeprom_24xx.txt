; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_eeprom_24xx.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_eeprom_24xx.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\FatFS\src -I..\..\User\Mass_Storage\inc -I..\..\User\LCD_Driver -I..\..\User\SYSTEM\sys -I..\..\User\Debugprintf -I..\..\User\LogDebug -I..\..\User\app\inc -I..\..\User\app\src -I..\..\User\bsp\inc -I..\..\User\bsp\src -I.\RTE\_Flash -ID:\Keil_v5\ARM\Packs\ARM\CMSIS\5.5.1\CMSIS\Core\Include -ID:\Keil_v5\ARM\Packs\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=527 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_eeprom_24xx.crf ..\..\User\bsp\src\bsp_eeprom_24xx.c]
                          THUMB

                          AREA ||i.ee_CheckOk||, CODE, READONLY, ALIGN=1

                  ee_CheckOk PROC
;;;30     */
;;;31     uint8_t ee_CheckOk(void)
000000  b510              PUSH     {r4,lr}
;;;32     {
;;;33     	if (i2c_CheckDevice(EE_DEV_ADDR) == 0)
000002  20a0              MOVS     r0,#0xa0
000004  f7fffffe          BL       i2c_CheckDevice
000008  b908              CBNZ     r0,|L1.14|
;;;34     	{
;;;35     		return 1;
00000a  2001              MOVS     r0,#1
                  |L1.12|
;;;36     	}
;;;37     	else
;;;38     	{
;;;39     		/* 失败后，切记发送I2C总线停止信号 */
;;;40     		i2c_Stop();
;;;41     		return 0;
;;;42     	}
;;;43     }
00000c  bd10              POP      {r4,pc}
                  |L1.14|
00000e  f7fffffe          BL       i2c_Stop
000012  2000              MOVS     r0,#0                 ;41
000014  e7fa              B        |L1.12|
;;;44     
                          ENDP


                          AREA ||i.ee_ReadBytes||, CODE, READONLY, ALIGN=1

                  ee_ReadBytes PROC
;;;55     */
;;;56     uint8_t ee_ReadBytes(uint8_t *_pReadBuf, uint16_t _usAddress, uint16_t _usSize)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;57     {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;58     	uint16_t i;
;;;59     
;;;60     	/* 采用串行EEPROM随即读取指令序列，连续读取若干字节 */
;;;61     
;;;62     	/* 第1步：发起I2C总线启动信号 */
;;;63     	i2c_Start();
00000a  f7fffffe          BL       i2c_Start
;;;64     
;;;65     	/* 第2步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读 */
;;;66     	i2c_SendByte(EE_DEV_ADDR | I2C_WR);	/* 此处是写指令 */
00000e  20a0              MOVS     r0,#0xa0
000010  f7fffffe          BL       i2c_SendByte
;;;67     
;;;68     	/* 第3步：发送ACK */
;;;69     	if (i2c_WaitAck() != 0)
000014  f7fffffe          BL       i2c_WaitAck
000018  b100              CBZ      r0,|L2.28|
;;;70     	{
;;;71     		goto cmd_fail;	/* EEPROM器件无应答 */
00001a  e02c              B        |L2.118|
                  |L2.28|
;;;72     	}
;;;73     
;;;74     	/* 第4步：发送字节地址，24C02只有256字节，因此1个字节就够了，如果是24C04以上，那么此处需要连发多个地址 */
;;;75     	if (EE_ADDR_BYTES == 1)
;;;76     	{
;;;77     		i2c_SendByte((uint8_t)_usAddress);
;;;78     		if (i2c_WaitAck() != 0)
;;;79     		{
;;;80     			goto cmd_fail;	/* EEPROM器件无应答 */
;;;81     		}
;;;82     	}
;;;83     	else
;;;84     	{
;;;85     		i2c_SendByte(_usAddress >> 8);
00001c  1228              ASRS     r0,r5,#8
00001e  f7fffffe          BL       i2c_SendByte
;;;86     		if (i2c_WaitAck() != 0)
000022  f7fffffe          BL       i2c_WaitAck
000026  b100              CBZ      r0,|L2.42|
;;;87     		{
;;;88     			goto cmd_fail;	/* EEPROM器件无应答 */
000028  e025              B        |L2.118|
                  |L2.42|
;;;89     		}
;;;90     
;;;91     		i2c_SendByte(_usAddress);
00002a  b2e8              UXTB     r0,r5
00002c  f7fffffe          BL       i2c_SendByte
;;;92     		if (i2c_WaitAck() != 0)
000030  f7fffffe          BL       i2c_WaitAck
000034  b100              CBZ      r0,|L2.56|
;;;93     		{
;;;94     			goto cmd_fail;	/* EEPROM器件无应答 */
000036  e01e              B        |L2.118|
                  |L2.56|
;;;95     		}
;;;96     	}
;;;97     
;;;98     	/* 第6步：重新启动I2C总线。下面开始读取数据 */
;;;99     	i2c_Start();
000038  f7fffffe          BL       i2c_Start
;;;100    
;;;101    	/* 第7步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读 */
;;;102    	i2c_SendByte(EE_DEV_ADDR | I2C_RD);	/* 此处是读指令 */
00003c  20a1              MOVS     r0,#0xa1
00003e  f7fffffe          BL       i2c_SendByte
;;;103    
;;;104    	/* 第8步：发送ACK */
;;;105    	if (i2c_WaitAck() != 0)
000042  f7fffffe          BL       i2c_WaitAck
000046  b100              CBZ      r0,|L2.74|
;;;106    	{
;;;107    		goto cmd_fail;	/* EEPROM器件无应答 */
000048  e015              B        |L2.118|
                  |L2.74|
;;;108    	}
;;;109    
;;;110    	/* 第9步：循环读取数据 */
;;;111    	for (i = 0; i < _usSize; i++)
00004a  2400              MOVS     r4,#0
00004c  e00c              B        |L2.104|
                  |L2.78|
;;;112    	{
;;;113    		_pReadBuf[i] = i2c_ReadByte();	/* 读1个字节 */
00004e  f7fffffe          BL       i2c_ReadByte
000052  5538              STRB     r0,[r7,r4]
;;;114    
;;;115    		/* 每读完1个字节后，需要发送Ack， 最后一个字节不需要Ack，发Nack */
;;;116    		if (i != _usSize - 1)
000054  1e70              SUBS     r0,r6,#1
000056  42a0              CMP      r0,r4
000058  d002              BEQ      |L2.96|
;;;117    		{
;;;118    			i2c_Ack();	/* 中间字节读完后，CPU产生ACK信号(驱动SDA = 0) */
00005a  f7fffffe          BL       i2c_Ack
00005e  e001              B        |L2.100|
                  |L2.96|
;;;119    		}
;;;120    		else
;;;121    		{
;;;122    			i2c_NAck();	/* 最后1个字节读完后，CPU产生NACK信号(驱动SDA = 1) */
000060  f7fffffe          BL       i2c_NAck
                  |L2.100|
000064  1c60              ADDS     r0,r4,#1              ;111
000066  b284              UXTH     r4,r0                 ;111
                  |L2.104|
000068  42b4              CMP      r4,r6                 ;111
00006a  dbf0              BLT      |L2.78|
;;;123    		}
;;;124    	}
;;;125    	/* 发送I2C总线停止信号 */
;;;126    	i2c_Stop();
00006c  f7fffffe          BL       i2c_Stop
;;;127    	return 1;	/* 执行成功 */
000070  2001              MOVS     r0,#1
                  |L2.114|
;;;128    
;;;129    cmd_fail: /* 命令执行失败后，切记发送停止信号，避免影响I2C总线上其他设备 */
;;;130    	/* 发送I2C总线停止信号 */
;;;131    	i2c_Stop();
;;;132    	return 0;
;;;133    }
000072  e8bd81f0          POP      {r4-r8,pc}
                  |L2.118|
000076  f7fffffe          BL       i2c_Stop
00007a  2000              MOVS     r0,#0                 ;132
00007c  e7f9              B        |L2.114|
;;;134    
                          ENDP


                          AREA ||i.ee_WriteBytes||, CODE, READONLY, ALIGN=1

                  ee_WriteBytes PROC
;;;144    */
;;;145    uint8_t ee_WriteBytes(uint8_t *_pWriteBuf, uint16_t _usAddress, uint16_t _usSize)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;146    {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4691              MOV      r9,r2
;;;147    	uint16_t i,m;
;;;148    	uint16_t usAddr;
;;;149    
;;;150    	/*
;;;151    		写串行EEPROM不像读操作可以连续读取很多字节，每次写操作只能在同一个page。
;;;152    		对于24xx02，page size = 8
;;;153    		简单的处理方法为：按字节写操作模式，每写1个字节，都发送地址
;;;154    		为了提高连续写的效率: 本函数采用page wirte操作。
;;;155    	*/
;;;156    
;;;157    	usAddr = _usAddress;
00000a  4645              MOV      r5,r8
;;;158    	for (i = 0; i < _usSize; i++)
00000c  2400              MOVS     r4,#0
00000e  e033              B        |L3.120|
                  |L3.16|
;;;159    	{
;;;160    		/* 当发送第1个字节或是页面首地址时，需要重新发起启动信号和地址 */
;;;161    		if ((i == 0) || (usAddr & (EE_PAGE_SIZE - 1)) == 0)
000010  b114              CBZ      r4,|L3.24|
000012  f005001f          AND      r0,r5,#0x1f
000016  bb20              CBNZ     r0,|L3.98|
                  |L3.24|
;;;162    		{
;;;163    			/*　第０步：发停止信号，启动内部写操作　*/
;;;164    			i2c_Stop();
000018  f7fffffe          BL       i2c_Stop
;;;165    
;;;166    			/* 通过检查器件应答的方式，判断内部写操作是否完成, 一般小于 10ms
;;;167    				CLK频率为200KHz时，查询次数为30次左右
;;;168    			*/
;;;169    			for (m = 0; m < 1000; m++)
00001c  2600              MOVS     r6,#0
00001e  e00a              B        |L3.54|
                  |L3.32|
;;;170    			{
;;;171    				/* 第1步：发起I2C总线启动信号 */
;;;172    				i2c_Start();
000020  f7fffffe          BL       i2c_Start
;;;173    
;;;174    				/* 第2步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读 */
;;;175    				i2c_SendByte(EE_DEV_ADDR | I2C_WR);	/* 此处是写指令 */
000024  20a0              MOVS     r0,#0xa0
000026  f7fffffe          BL       i2c_SendByte
;;;176    
;;;177    				/* 第3步：发送一个时钟，判断器件是否正确应答 */
;;;178    				if (i2c_WaitAck() == 0)
00002a  f7fffffe          BL       i2c_WaitAck
00002e  b900              CBNZ     r0,|L3.50|
;;;179    				{
;;;180    					break;
000030  e004              B        |L3.60|
                  |L3.50|
000032  1c70              ADDS     r0,r6,#1              ;169
000034  b286              UXTH     r6,r0                 ;169
                  |L3.54|
000036  f5b67f7a          CMP      r6,#0x3e8             ;169
00003a  dbf1              BLT      |L3.32|
                  |L3.60|
00003c  bf00              NOP      
;;;181    				}
;;;182    			}
;;;183    			if (m  == 1000)
00003e  f5b67f7a          CMP      r6,#0x3e8
000042  d100              BNE      |L3.70|
;;;184    			{
;;;185    				goto cmd_fail;	/* EEPROM器件写超时 */
000044  e01f              B        |L3.134|
                  |L3.70|
;;;186    			}
;;;187    
;;;188    			/* 第4步：发送字节地址，24C02只有256字节，因此1个字节就够了，如果是24C04以上，那么此处需要连发多个地址 */
;;;189    			if (EE_ADDR_BYTES == 1)
;;;190    			{
;;;191    				i2c_SendByte((uint8_t)usAddr);
;;;192    				if (i2c_WaitAck() != 0)
;;;193    				{
;;;194    					goto cmd_fail;	/* EEPROM器件无应答 */
;;;195    				}
;;;196    			}
;;;197    			else
;;;198    			{
;;;199    				i2c_SendByte(usAddr >> 8);
000046  1228              ASRS     r0,r5,#8
000048  f7fffffe          BL       i2c_SendByte
;;;200    				if (i2c_WaitAck() != 0)
00004c  f7fffffe          BL       i2c_WaitAck
000050  b100              CBZ      r0,|L3.84|
;;;201    				{
;;;202    					goto cmd_fail;	/* EEPROM器件无应答 */
000052  e018              B        |L3.134|
                  |L3.84|
;;;203    				}
;;;204    
;;;205    				i2c_SendByte(usAddr);
000054  b2e8              UXTB     r0,r5
000056  f7fffffe          BL       i2c_SendByte
;;;206    				if (i2c_WaitAck() != 0)
00005a  f7fffffe          BL       i2c_WaitAck
00005e  b100              CBZ      r0,|L3.98|
;;;207    				{
;;;208    					goto cmd_fail;	/* EEPROM器件无应答 */
000060  e011              B        |L3.134|
                  |L3.98|
;;;209    				}
;;;210    			}
;;;211    		}
;;;212    
;;;213    		/* 第6步：开始写入数据 */
;;;214    		i2c_SendByte(_pWriteBuf[i]);
000062  5d38              LDRB     r0,[r7,r4]
000064  f7fffffe          BL       i2c_SendByte
;;;215    
;;;216    		/* 第7步：发送ACK */
;;;217    		if (i2c_WaitAck() != 0)
000068  f7fffffe          BL       i2c_WaitAck
00006c  b100              CBZ      r0,|L3.112|
;;;218    		{
;;;219    			goto cmd_fail;	/* EEPROM器件无应答 */
00006e  e00a              B        |L3.134|
                  |L3.112|
;;;220    		}
;;;221    
;;;222    		usAddr++;	/* 地址增1 */
000070  1c68              ADDS     r0,r5,#1
000072  b285              UXTH     r5,r0
000074  1c60              ADDS     r0,r4,#1              ;158
000076  b284              UXTH     r4,r0                 ;158
                  |L3.120|
000078  454c              CMP      r4,r9                 ;158
00007a  dbc9              BLT      |L3.16|
;;;223    	}
;;;224    
;;;225    	/* 命令执行成功，发送I2C总线停止信号 */
;;;226    	i2c_Stop();
00007c  f7fffffe          BL       i2c_Stop
;;;227    	return 1;
000080  2001              MOVS     r0,#1
                  |L3.130|
;;;228    
;;;229    cmd_fail: /* 命令执行失败后，切记发送停止信号，避免影响I2C总线上其他设备 */
;;;230    	/* 发送I2C总线停止信号 */
;;;231    	i2c_Stop();
;;;232    	return 0;
;;;233    }
000082  e8bd87f0          POP      {r4-r10,pc}
                  |L3.134|
000086  f7fffffe          BL       i2c_Stop
00008a  2000              MOVS     r0,#0                 ;232
00008c  e7f9              B        |L3.130|
;;;234    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_eeprom_24xx.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_bsp_eeprom_24xx_c_4eb00f1b____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___17_bsp_eeprom_24xx_c_4eb00f1b____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_bsp_eeprom_24xx_c_4eb00f1b____REVSH|
#line 128
|__asm___17_bsp_eeprom_24xx_c_4eb00f1b____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

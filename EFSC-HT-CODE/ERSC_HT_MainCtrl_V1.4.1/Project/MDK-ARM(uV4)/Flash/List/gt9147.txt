; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\gt9147.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\gt9147.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\FatFS\src -I..\..\User\Mass_Storage\inc -I..\..\User\LCD_Driver -I..\..\User\SYSTEM\sys -I..\..\User\Debugprintf -I..\..\User\LogDebug -I..\..\User\app\inc -I..\..\User\app\src -I..\..\User\bsp\inc -I..\..\User\bsp\src -I.\RTE\_Flash -ID:\Keil_v5\ARM\Packs\ARM\CMSIS\5.5.1\CMSIS\Core\Include -ID:\Keil_v5\ARM\Packs\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=527 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\gt9147.crf ..\..\User\LCD_Driver\gt9147.c]
                          THUMB

                          AREA ||i.GT9147_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  GT9147_Init PROC
;;;109    //返回值:0,初始化成功;1,初始化失败 
;;;110    u8 GT9147_Init(void)
000000  b50e              PUSH     {r1-r3,lr}
;;;111    {
;;;112    	u8 temp[5];  
;;;113     	GPIO_InitTypeDef  GPIO_InitStructure;	
;;;114    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOF, ENABLE);	 //使能PF端口时钟
000002  2101              MOVS     r1,#1
000004  2080              MOVS     r0,#0x80
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;115    
;;;116    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;				 // PF11端口配置
00000a  f44f6000          MOV      r0,#0x800
00000e  f8ad0000          STRH     r0,[sp,#0]
;;;117      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; 		 //推挽输出
000012  2010              MOVS     r0,#0x10
000014  f88d0003          STRB     r0,[sp,#3]
;;;118    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000018  2003              MOVS     r0,#3
00001a  f88d0002          STRB     r0,[sp,#2]
;;;119    	GPIO_Init(GPIOF, &GPIO_InitStructure);//PF11推挽输出
00001e  4669              MOV      r1,sp
000020  483a              LDR      r0,|L1.268|
000022  f7fffffe          BL       GPIO_Init
;;;120    	GPIO_SetBits(GPIOF,GPIO_Pin_1);//上拉
000026  2102              MOVS     r1,#2
000028  4838              LDR      r0,|L1.268|
00002a  f7fffffe          BL       GPIO_SetBits
;;;121    		
;;;122      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;				 // PB2端口配置
00002e  f44f6080          MOV      r0,#0x400
000032  f8ad0000          STRH     r0,[sp,#0]
;;;123    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; 		 //上拉输入
000036  2048              MOVS     r0,#0x48
000038  f88d0003          STRB     r0,[sp,#3]
;;;124    	GPIO_Init(GPIOF, &GPIO_InitStructure);//PF10上拉输入
00003c  4669              MOV      r1,sp
00003e  4833              LDR      r0,|L1.268|
000040  f7fffffe          BL       GPIO_Init
;;;125    	GPIO_SetBits(GPIOF,GPIO_Pin_10);//上拉		
000044  f44f6180          MOV      r1,#0x400
000048  4830              LDR      r0,|L1.268|
00004a  f7fffffe          BL       GPIO_SetBits
;;;126    	
;;;127     
;;;128    	CT_IIC_Init();      	//初始化电容屏的I2C总线  
00004e  f7fffffe          BL       CT_IIC_Init
;;;129    	GT_RST=0;				//复位
000052  2000              MOVS     r0,#0
000054  492e              LDR      r1,|L1.272|
000056  6008              STR      r0,[r1,#0]
;;;130    	bsp_DelayMS(10);
000058  200a              MOVS     r0,#0xa
00005a  f7fffffe          BL       bsp_DelayMS
;;;131     	GT_RST=1;				//释放复位 
00005e  2001              MOVS     r0,#1
000060  492c              LDR      r1,|L1.276|
000062  f8c101ac          STR      r0,[r1,#0x1ac]
;;;132    	bsp_DelayMS(10);
000066  200a              MOVS     r0,#0xa
000068  f7fffffe          BL       bsp_DelayMS
;;;133     
;;;134      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;				 // PB2端口配置
00006c  f44f6080          MOV      r0,#0x400
000070  f8ad0000          STRH     r0,[sp,#0]
;;;135    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD; 		 //下拉输入
000074  2028              MOVS     r0,#0x28
000076  f88d0003          STRB     r0,[sp,#3]
;;;136    	GPIO_Init(GPIOF, &GPIO_InitStructure);//PF10下拉输入
00007a  4669              MOV      r1,sp
00007c  4823              LDR      r0,|L1.268|
00007e  f7fffffe          BL       GPIO_Init
;;;137    	GPIO_ResetBits(GPIOF,GPIO_Pin_10);//下拉	
000082  f44f6180          MOV      r1,#0x400
000086  4821              LDR      r0,|L1.268|
000088  f7fffffe          BL       GPIO_ResetBits
;;;138    	
;;;139    	
;;;140    	bsp_DelayMS(100);  
00008c  2064              MOVS     r0,#0x64
00008e  f7fffffe          BL       bsp_DelayMS
;;;141    	GT9147_RD_Reg(GT_PID_REG,temp,4);	//读取产品ID
000092  2204              MOVS     r2,#4
000094  a901              ADD      r1,sp,#4
000096  f2481040          MOV      r0,#0x8140
00009a  f7fffffe          BL       GT9147_RD_Reg
;;;142    	temp[4]=0;
00009e  2000              MOVS     r0,#0
0000a0  f88d0008          STRB     r0,[sp,#8]
;;;143    	printf("CTP ID:%s\r\n",temp);		//打印ID
0000a4  a901              ADD      r1,sp,#4
0000a6  a01c              ADR      r0,|L1.280|
0000a8  f7fffffe          BL       __2printf
;;;144    	if(strcmp((char*)temp,"9147")==0)	//ID==9147
0000ac  a11d              ADR      r1,|L1.292|
0000ae  a801              ADD      r0,sp,#4
0000b0  f7fffffe          BL       strcmp
0000b4  bb40              CBNZ     r0,|L1.264|
;;;145    	{
;;;146    		temp[0]=0X02;			
0000b6  2002              MOVS     r0,#2
0000b8  f88d0004          STRB     r0,[sp,#4]
;;;147    		GT9147_WR_Reg(GT_CTRL_REG,temp,1);//软复位GT9147
0000bc  2201              MOVS     r2,#1
0000be  a901              ADD      r1,sp,#4
0000c0  f2480040          MOV      r0,#0x8040
0000c4  f7fffffe          BL       GT9147_WR_Reg
;;;148     		GT9147_RD_Reg(GT_CFGS_REG,temp,1);//读取GT_CFGS_REG寄存器
0000c8  2201              MOVS     r2,#1
0000ca  a901              ADD      r1,sp,#4
0000cc  f2480047          MOV      r0,#0x8047
0000d0  f7fffffe          BL       GT9147_RD_Reg
;;;149    		if(temp[0]<0X60)//默认版本比较低,需要更新flash配置
0000d4  f89d0004          LDRB     r0,[sp,#4]
0000d8  2860              CMP      r0,#0x60
0000da  da07              BGE      |L1.236|
;;;150    		{
;;;151    			printf("Default Ver:%d\r\n",temp[0]);
0000dc  f89d1004          LDRB     r1,[sp,#4]
0000e0  a012              ADR      r0,|L1.300|
0000e2  f7fffffe          BL       __2printf
;;;152    			GT9147_Send_Cfg(1);//更新并保存配置
0000e6  2001              MOVS     r0,#1
0000e8  f7fffffe          BL       GT9147_Send_Cfg
                  |L1.236|
;;;153    		}
;;;154    		bsp_DelayMS(10);
0000ec  200a              MOVS     r0,#0xa
0000ee  f7fffffe          BL       bsp_DelayMS
;;;155    		temp[0]=0X00;	 
0000f2  2000              MOVS     r0,#0
0000f4  f88d0004          STRB     r0,[sp,#4]
;;;156    		GT9147_WR_Reg(GT_CTRL_REG,temp,1);	//结束复位   	
0000f8  2201              MOVS     r2,#1
0000fa  a901              ADD      r1,sp,#4
0000fc  f2480040          MOV      r0,#0x8040
000100  f7fffffe          BL       GT9147_WR_Reg
;;;157    		return 0;
000104  2000              MOVS     r0,#0
                  |L1.262|
;;;158    	} 
;;;159    	return 1;
;;;160    }
000106  bd0e              POP      {r1-r3,pc}
                  |L1.264|
000108  2001              MOVS     r0,#1                 ;159
00010a  e7fc              B        |L1.262|
;;;161    const u16 GT9147_TPX_TBL[5]={GT_TP1_REG,GT_TP2_REG,GT_TP3_REG,GT_TP4_REG,GT_TP5_REG};
                          ENDP

                  |L1.268|
                          DCD      0x40011c00
                  |L1.272|
                          DCD      0x422381ac
                  |L1.276|
                          DCD      0x42238000
                  |L1.280|
000118  43545020          DCB      "CTP ID:%s\r\n",0
00011c  49443a25
000120  730d0a00
                  |L1.292|
000124  39313437          DCB      "9147",0
000128  00      
000129  00                DCB      0
00012a  00                DCB      0
00012b  00                DCB      0
                  |L1.300|
00012c  44656661          DCB      "Default Ver:%d\r\n",0
000130  756c7420
000134  5665723a
000138  25640d0a
00013c  00      
00013d  00                DCB      0
00013e  00                DCB      0
00013f  00                DCB      0

                          AREA ||i.GT9147_RD_Reg||, CODE, READONLY, ALIGN=1

                  GT9147_RD_Reg PROC
;;;88     //len:读数据长度			  
;;;89     void GT9147_RD_Reg(u16 reg,u8 *buf,u8 len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;90     {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
;;;91     	u8 i; 
;;;92      	CT_IIC_Start();	
00000a  f7fffffe          BL       CT_IIC_Start
;;;93      	CT_IIC_Send_Byte(GT_CMD_WR);   //发送写命令 	 
00000e  2028              MOVS     r0,#0x28
000010  f7fffffe          BL       CT_IIC_Send_Byte
;;;94     	CT_IIC_Wait_Ack();
000014  f7fffffe          BL       CT_IIC_Wait_Ack
;;;95      	CT_IIC_Send_Byte(reg>>8);   	//发送高8位地址
000018  1228              ASRS     r0,r5,#8
00001a  f7fffffe          BL       CT_IIC_Send_Byte
;;;96     	CT_IIC_Wait_Ack(); 	 										  		   
00001e  f7fffffe          BL       CT_IIC_Wait_Ack
;;;97      	CT_IIC_Send_Byte(reg&0XFF);   	//发送低8位地址
000022  b2e8              UXTB     r0,r5
000024  f7fffffe          BL       CT_IIC_Send_Byte
;;;98     	CT_IIC_Wait_Ack();  
000028  f7fffffe          BL       CT_IIC_Wait_Ack
;;;99      	CT_IIC_Start();  	 	   
00002c  f7fffffe          BL       CT_IIC_Start
;;;100    	CT_IIC_Send_Byte(GT_CMD_RD);   //发送读命令		   
000030  2029              MOVS     r0,#0x29
000032  f7fffffe          BL       CT_IIC_Send_Byte
;;;101    	CT_IIC_Wait_Ack();	   
000036  f7fffffe          BL       CT_IIC_Wait_Ack
;;;102    	for(i=0;i<len;i++)
00003a  2400              MOVS     r4,#0
00003c  e00b              B        |L2.86|
                  |L2.62|
;;;103    	{	   
;;;104        	buf[i]=CT_IIC_Read_Byte(i==(len-1)?0:1); //发数据	  
00003e  1e71              SUBS     r1,r6,#1
000040  42a1              CMP      r1,r4
000042  d001              BEQ      |L2.72|
000044  2101              MOVS     r1,#1
000046  e000              B        |L2.74|
                  |L2.72|
000048  2100              MOVS     r1,#0
                  |L2.74|
00004a  4608              MOV      r0,r1
00004c  f7fffffe          BL       CT_IIC_Read_Byte
000050  5538              STRB     r0,[r7,r4]
000052  1c60              ADDS     r0,r4,#1              ;102
000054  b2c4              UXTB     r4,r0                 ;102
                  |L2.86|
000056  42b4              CMP      r4,r6                 ;102
000058  dbf1              BLT      |L2.62|
;;;105    	} 
;;;106        CT_IIC_Stop();//产生一个停止条件    
00005a  f7fffffe          BL       CT_IIC_Stop
;;;107    } 
00005e  e8bd81f0          POP      {r4-r8,pc}
;;;108    //初始化GT9147触摸屏
                          ENDP


                          AREA ||i.GT9147_Scan||, CODE, READONLY, ALIGN=2

                  GT9147_Scan PROC
;;;165    //0,触屏无触摸;1,触屏有触摸
;;;166    u8 GT9147_Scan(u8 mode)
000000  b571              PUSH     {r0,r4-r6,lr}
;;;167    {
000002  b083              SUB      sp,sp,#0xc
;;;168    	u8 buf[4];
;;;169    	u8 i=0;
000004  2400              MOVS     r4,#0
;;;170    	u8 res=0;
000006  2600              MOVS     r6,#0
;;;171    	u8 temp;
;;;172    	u8 tempsta;
;;;173     	static u8 t=0;//控制查询间隔,从而降低CPU占用率   
;;;174    	t++;
000008  4879              LDR      r0,|L3.496|
00000a  7800              LDRB     r0,[r0,#0]  ; t
00000c  1c40              ADDS     r0,r0,#1
00000e  4978              LDR      r1,|L3.496|
000010  7008              STRB     r0,[r1,#0]
;;;175    	if((t%10)==0||t<10)//空闲时,每进入10次CTP_Scan函数才检测1次,从而节省CPU使用率
000012  4608              MOV      r0,r1
000014  7800              LDRB     r0,[r0,#0]  ; t
000016  210a              MOVS     r1,#0xa
000018  fb90f2f1          SDIV     r2,r0,r1
00001c  fb010012          MLS      r0,r1,r2,r0
000020  b118              CBZ      r0,|L3.42|
000022  4873              LDR      r0,|L3.496|
000024  7800              LDRB     r0,[r0,#0]  ; t
000026  280a              CMP      r0,#0xa
                  |L3.40|
000028  da7e              BGE      |L3.296|
                  |L3.42|
;;;176    	{
;;;177    		GT9147_RD_Reg(GT_GSTID_REG,&mode,1);	//读取触摸点的状态  
00002a  2201              MOVS     r2,#1
00002c  a903              ADD      r1,sp,#0xc
00002e  f248104e          MOV      r0,#0x814e
000032  f7fffffe          BL       GT9147_RD_Reg
;;;178     		if(mode&0X80&&((mode&0XF)<6))
000036  f89d000c          LDRB     r0,[sp,#0xc]
00003a  f0000080          AND      r0,r0,#0x80
00003e  b168              CBZ      r0,|L3.92|
000040  f89d000c          LDRB     r0,[sp,#0xc]
000044  f000000f          AND      r0,r0,#0xf
000048  2806              CMP      r0,#6
00004a  da07              BGE      |L3.92|
;;;179    		{
;;;180    			temp=0;
00004c  2000              MOVS     r0,#0
00004e  9001              STR      r0,[sp,#4]
;;;181    			GT9147_WR_Reg(GT_GSTID_REG,&temp,1);//清标志 		
000050  2201              MOVS     r2,#1
000052  a901              ADD      r1,sp,#4
000054  f248104e          MOV      r0,#0x814e
000058  f7fffffe          BL       GT9147_WR_Reg
                  |L3.92|
;;;182    		}		
;;;183    		if((mode&0XF)&&((mode&0XF)<6))
00005c  f89d000c          LDRB     r0,[sp,#0xc]
000060  f000000f          AND      r0,r0,#0xf
000064  2800              CMP      r0,#0
000066  d05f              BEQ      |L3.296|
000068  f89d000c          LDRB     r0,[sp,#0xc]
00006c  f000000f          AND      r0,r0,#0xf
000070  2806              CMP      r0,#6
000072  dad9              BGE      |L3.40|
;;;184    		{
;;;185    			temp=0XFF<<(mode&0XF);		//将点的个数转换为1的位数,匹配tp_dev.sta定义 
000074  f89d000c          LDRB     r0,[sp,#0xc]
000078  f000010f          AND      r1,r0,#0xf
00007c  20ff              MOVS     r0,#0xff
00007e  4088              LSLS     r0,r0,r1
000080  b2c0              UXTB     r0,r0
000082  9001              STR      r0,[sp,#4]
;;;186    			tempsta=tp_dev.sta;			//保存当前的tp_dev.sta值
000084  485b              LDR      r0,|L3.500|
000086  f8905020          LDRB     r5,[r0,#0x20]  ; tp_dev
;;;187    			tp_dev.sta=(~temp)|TP_PRES_DOWN|TP_CATH_PRES; 
00008a  f89d0004          LDRB     r0,[sp,#4]
00008e  43c0              MVNS     r0,r0
000090  b2c0              UXTB     r0,r0
000092  f04000c0          ORR      r0,r0,#0xc0
000096  4957              LDR      r1,|L3.500|
000098  f8810020          STRB     r0,[r1,#0x20]
;;;188    			tp_dev.x[4]=tp_dev.x[0];	//保存触点0的数据
00009c  4608              MOV      r0,r1
00009e  8981              LDRH     r1,[r0,#0xc]  ; tp_dev
0000a0  8281              STRH     r1,[r0,#0x14]
;;;189    			tp_dev.y[4]=tp_dev.y[0];
0000a2  8ac1              LDRH     r1,[r0,#0x16]  ; tp_dev
0000a4  83c1              STRH     r1,[r0,#0x1e]
;;;190    			for(i=0;i<5;i++)
0000a6  2400              MOVS     r4,#0
0000a8  e046              B        |L3.312|
                  |L3.170|
;;;191    			{
;;;192    				if(tp_dev.sta&(1<<i))	//触摸有效?
0000aa  4852              LDR      r0,|L3.500|
0000ac  f8900020          LDRB     r0,[r0,#0x20]  ; tp_dev
0000b0  2101              MOVS     r1,#1
0000b2  40a1              LSLS     r1,r1,r4
0000b4  4008              ANDS     r0,r0,r1
0000b6  b320              CBZ      r0,|L3.258|
;;;193    				{
;;;194    					GT9147_RD_Reg(GT9147_TPX_TBL[i],buf,4);	//读取XY坐标值
0000b8  494f              LDR      r1,|L3.504|
0000ba  f8310014          LDRH     r0,[r1,r4,LSL #1]
0000be  2204              MOVS     r2,#4
0000c0  a902              ADD      r1,sp,#8
0000c2  f7fffffe          BL       GT9147_RD_Reg
;;;195    					if(tp_dev.touchtype&0X01)//横屏
0000c6  484b              LDR      r0,|L3.500|
0000c8  f8900030          LDRB     r0,[r0,#0x30]  ; tp_dev
0000cc  f0000001          AND      r0,r0,#1
0000d0  b1c0              CBZ      r0,|L3.260|
;;;196    					{
;;;197    						tp_dev.y[i]=((u16)buf[1]<<8)+buf[0];
0000d2  f89d0008          LDRB     r0,[sp,#8]
0000d6  f89d1009          LDRB     r1,[sp,#9]
0000da  eb002001          ADD      r0,r0,r1,LSL #8
0000de  b281              UXTH     r1,r0
0000e0  4844              LDR      r0,|L3.500|
0000e2  3016              ADDS     r0,r0,#0x16
0000e4  f8201014          STRH     r1,[r0,r4,LSL #1]
;;;198    						tp_dev.x[i]=800-(((u16)buf[3]<<8)+buf[2]);
0000e8  f89d000a          LDRB     r0,[sp,#0xa]
0000ec  f89d100b          LDRB     r1,[sp,#0xb]
0000f0  eb002001          ADD      r0,r0,r1,LSL #8
0000f4  f5c07048          RSB      r0,r0,#0x320
0000f8  b281              UXTH     r1,r0
0000fa  483e              LDR      r0,|L3.500|
0000fc  300c              ADDS     r0,r0,#0xc
0000fe  f8201014          STRH     r1,[r0,r4,LSL #1]
                  |L3.258|
000102  e017              B        |L3.308|
                  |L3.260|
;;;199    					}else
;;;200    					{
;;;201    						tp_dev.x[i]=((u16)buf[1]<<8)+buf[0];
000104  f89d0008          LDRB     r0,[sp,#8]
000108  f89d1009          LDRB     r1,[sp,#9]
00010c  eb002001          ADD      r0,r0,r1,LSL #8
000110  b281              UXTH     r1,r0
000112  4838              LDR      r0,|L3.500|
000114  300c              ADDS     r0,r0,#0xc
000116  f8201014          STRH     r1,[r0,r4,LSL #1]
;;;202    						tp_dev.y[i]=((u16)buf[3]<<8)+buf[2];
00011a  f89d000a          LDRB     r0,[sp,#0xa]
00011e  f89d100b          LDRB     r1,[sp,#0xb]
000122  eb002001          ADD      r0,r0,r1,LSL #8
000126  e000              B        |L3.298|
                  |L3.296|
000128  e036              B        |L3.408|
                  |L3.298|
00012a  b281              UXTH     r1,r0
00012c  4831              LDR      r0,|L3.500|
00012e  3016              ADDS     r0,r0,#0x16
000130  f8201014          STRH     r1,[r0,r4,LSL #1]
                  |L3.308|
000134  1c60              ADDS     r0,r4,#1              ;190
000136  b2c4              UXTB     r4,r0                 ;190
                  |L3.312|
000138  2c05              CMP      r4,#5                 ;190
00013a  dbb6              BLT      |L3.170|
;;;203    					}  
;;;204    					//printf("x[%d]:%d,y[%d]:%d\r\n",i,tp_dev.x[i],i,tp_dev.y[i]);
;;;205    				}			
;;;206    			} 
;;;207    			res=1;
00013c  2601              MOVS     r6,#1
;;;208    			if(tp_dev.x[0]>lcddev.width||tp_dev.y[0]>lcddev.height)//非法数据(坐标超出了)
00013e  482d              LDR      r0,|L3.500|
000140  8980              LDRH     r0,[r0,#0xc]  ; tp_dev
000142  492e              LDR      r1,|L3.508|
000144  8809              LDRH     r1,[r1,#0]  ; lcddev
000146  4288              CMP      r0,r1
000148  dc05              BGT      |L3.342|
00014a  482a              LDR      r0,|L3.500|
00014c  8ac0              LDRH     r0,[r0,#0x16]  ; tp_dev
00014e  492b              LDR      r1,|L3.508|
000150  8849              LDRH     r1,[r1,#2]  ; lcddev
000152  4288              CMP      r0,r1
000154  dd1d              BLE      |L3.402|
                  |L3.342|
;;;209    			{ 
;;;210    				if((mode&0XF)>1)		//有其他点有数据,则复第二个触点的数据到第一个触点.
000156  f89d000c          LDRB     r0,[sp,#0xc]
00015a  f000000f          AND      r0,r0,#0xf
00015e  2801              CMP      r0,#1
000160  dd0a              BLE      |L3.376|
;;;211    				{
;;;212    					tp_dev.x[0]=tp_dev.x[1];
000162  4824              LDR      r0,|L3.500|
000164  89c0              LDRH     r0,[r0,#0xe]
000166  4923              LDR      r1,|L3.500|
000168  8188              STRH     r0,[r1,#0xc]
;;;213    					tp_dev.y[0]=tp_dev.y[1];
00016a  4608              MOV      r0,r1
00016c  8b00              LDRH     r0,[r0,#0x18]
00016e  82c8              STRH     r0,[r1,#0x16]
;;;214    					t=0;				//触发一次,则会最少连续监测10次,从而提高命中率
000170  2000              MOVS     r0,#0
000172  491f              LDR      r1,|L3.496|
000174  7008              STRB     r0,[r1,#0]
000176  e00f              B        |L3.408|
                  |L3.376|
;;;215    				}else					//非法数据,则忽略此次数据(还原原来的)  
;;;216    				{
;;;217    					tp_dev.x[0]=tp_dev.x[4];
000178  481e              LDR      r0,|L3.500|
00017a  8a80              LDRH     r0,[r0,#0x14]
00017c  491d              LDR      r1,|L3.500|
00017e  8188              STRH     r0,[r1,#0xc]
;;;218    					tp_dev.y[0]=tp_dev.y[4];
000180  4608              MOV      r0,r1
000182  8bc0              LDRH     r0,[r0,#0x1e]
000184  82c8              STRH     r0,[r1,#0x16]
;;;219    					mode=0X80;		
000186  2080              MOVS     r0,#0x80
000188  9003              STR      r0,[sp,#0xc]
;;;220    					tp_dev.sta=tempsta;	//恢复tp_dev.sta
00018a  4608              MOV      r0,r1
00018c  f8805020          STRB     r5,[r0,#0x20]
000190  e002              B        |L3.408|
                  |L3.402|
;;;221    				}
;;;222    			}else t=0;					//触发一次,则会最少连续监测10次,从而提高命中率
000192  2000              MOVS     r0,#0
000194  4916              LDR      r1,|L3.496|
000196  7008              STRB     r0,[r1,#0]
                  |L3.408|
;;;223    		}
;;;224    	}
;;;225    	if((mode&0X8F)==0X80)//无触摸点按下
000198  f89d000c          LDRB     r0,[sp,#0xc]
00019c  f000008f          AND      r0,r0,#0x8f
0001a0  2880              CMP      r0,#0x80
0001a2  d11a              BNE      |L3.474|
;;;226    	{ 
;;;227    		if(tp_dev.sta&TP_PRES_DOWN)	//之前是被按下的
0001a4  4813              LDR      r0,|L3.500|
0001a6  f8900020          LDRB     r0,[r0,#0x20]  ; tp_dev
0001aa  f0000080          AND      r0,r0,#0x80
0001ae  b140              CBZ      r0,|L3.450|
;;;228    		{
;;;229    			tp_dev.sta&=~(1<<7);	//标记按键松开
0001b0  4810              LDR      r0,|L3.500|
0001b2  f8900020          LDRB     r0,[r0,#0x20]  ; tp_dev
0001b6  f0200080          BIC      r0,r0,#0x80
0001ba  490e              LDR      r1,|L3.500|
0001bc  f8810020          STRB     r0,[r1,#0x20]
0001c0  e00b              B        |L3.474|
                  |L3.450|
;;;230    		}else						//之前就没有被按下
;;;231    		{ 
;;;232    			tp_dev.x[0]=0xffff;
0001c2  f64f70ff          MOV      r0,#0xffff
0001c6  490b              LDR      r1,|L3.500|
0001c8  8188              STRH     r0,[r1,#0xc]
;;;233    			tp_dev.y[0]=0xffff;
0001ca  82c8              STRH     r0,[r1,#0x16]
;;;234    			tp_dev.sta&=0XE0;	//清除点有效标记	
0001cc  4608              MOV      r0,r1
0001ce  f8900020          LDRB     r0,[r0,#0x20]  ; tp_dev
0001d2  f00000e0          AND      r0,r0,#0xe0
0001d6  f8810020          STRB     r0,[r1,#0x20]
                  |L3.474|
;;;235    		}	 
;;;236    	} 	
;;;237    	if(t>240)t=10;//重新从10开始计数
0001da  4805              LDR      r0,|L3.496|
0001dc  7800              LDRB     r0,[r0,#0]  ; t
0001de  28f0              CMP      r0,#0xf0
0001e0  dd02              BLE      |L3.488|
0001e2  200a              MOVS     r0,#0xa
0001e4  4902              LDR      r1,|L3.496|
0001e6  7008              STRB     r0,[r1,#0]
                  |L3.488|
;;;238    	return res;
0001e8  4630              MOV      r0,r6
;;;239    }
0001ea  b004              ADD      sp,sp,#0x10
0001ec  bd70              POP      {r4-r6,pc}
;;;240    
                          ENDP

0001ee  0000              DCW      0x0000
                  |L3.496|
                          DCD      t
                  |L3.500|
                          DCD      tp_dev
                  |L3.504|
                          DCD      GT9147_TPX_TBL
                  |L3.508|
                          DCD      lcddev

                          AREA ||i.GT9147_Send_Cfg||, CODE, READONLY, ALIGN=2

                  GT9147_Send_Cfg PROC
;;;47     //     1,参数保存到flash
;;;48     u8 GT9147_Send_Cfg(u8 mode)
000000  b538              PUSH     {r3-r5,lr}
;;;49     {
000002  4605              MOV      r5,r0
;;;50     	u8 buf[2];
;;;51     	u8 i=0;
000004  2400              MOVS     r4,#0
;;;52     	buf[0]=0;
000006  2000              MOVS     r0,#0
000008  f88d0000          STRB     r0,[sp,#0]
;;;53     	buf[1]=mode;	//是否写入到GT9147 FLASH?  即是否掉电保存
00000c  f88d5001          STRB     r5,[sp,#1]
;;;54     	for(i=0;i<sizeof(GT9147_CFG_TBL);i++)buf[0]+=GT9147_CFG_TBL[i];//计算校验和
000010  bf00              NOP      
000012  e009              B        |L4.40|
                  |L4.20|
000014  f89d0000          LDRB     r0,[sp,#0]
000018  490f              LDR      r1,|L4.88|
00001a  5d09              LDRB     r1,[r1,r4]
00001c  4408              ADD      r0,r0,r1
00001e  b2c0              UXTB     r0,r0
000020  f88d0000          STRB     r0,[sp,#0]
000024  1c60              ADDS     r0,r4,#1
000026  b2c4              UXTB     r4,r0
                  |L4.40|
000028  2cb8              CMP      r4,#0xb8
00002a  d3f3              BCC      |L4.20|
;;;55         buf[0]=(~buf[0])+1;
00002c  f89d0000          LDRB     r0,[sp,#0]
000030  43c0              MVNS     r0,r0
000032  1c40              ADDS     r0,r0,#1
000034  b2c0              UXTB     r0,r0
000036  f88d0000          STRB     r0,[sp,#0]
;;;56     	GT9147_WR_Reg(GT_CFGS_REG,(u8*)GT9147_CFG_TBL,sizeof(GT9147_CFG_TBL));//发送寄存器配置
00003a  22b8              MOVS     r2,#0xb8
00003c  4906              LDR      r1,|L4.88|
00003e  f2480047          MOV      r0,#0x8047
000042  f7fffffe          BL       GT9147_WR_Reg
;;;57     	GT9147_WR_Reg(GT_CHECK_REG,buf,2);//写入校验和,和配置更新标记
000046  2202              MOVS     r2,#2
000048  4669              MOV      r1,sp
00004a  f24800ff          MOV      r0,#0x80ff
00004e  f7fffffe          BL       GT9147_WR_Reg
;;;58     	return 0;
000052  2000              MOVS     r0,#0
;;;59     } 
000054  bd38              POP      {r3-r5,pc}
;;;60     //向GT9147写入一次数据
                          ENDP

000056  0000              DCW      0x0000
                  |L4.88|
                          DCD      GT9147_CFG_TBL

                          AREA ||i.GT9147_WR_Reg||, CODE, READONLY, ALIGN=1

                  GT9147_WR_Reg PROC
;;;64     //返回值:0,成功;1,失败.
;;;65     u8 GT9147_WR_Reg(u16 reg,u8 *buf,u8 len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;66     {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;67     	u8 i;
;;;68     	u8 ret=0;
00000a  f04f0800          MOV      r8,#0
;;;69     	CT_IIC_Start();	
00000e  f7fffffe          BL       CT_IIC_Start
;;;70      	CT_IIC_Send_Byte(GT_CMD_WR);   	//发送写命令 	 
000012  2028              MOVS     r0,#0x28
000014  f7fffffe          BL       CT_IIC_Send_Byte
;;;71     	CT_IIC_Wait_Ack();
000018  f7fffffe          BL       CT_IIC_Wait_Ack
;;;72     	CT_IIC_Send_Byte(reg>>8);   	//发送高8位地址
00001c  1220              ASRS     r0,r4,#8
00001e  f7fffffe          BL       CT_IIC_Send_Byte
;;;73     	CT_IIC_Wait_Ack(); 	 										  		   
000022  f7fffffe          BL       CT_IIC_Wait_Ack
;;;74     	CT_IIC_Send_Byte(reg&0XFF);   	//发送低8位地址
000026  b2e0              UXTB     r0,r4
000028  f7fffffe          BL       CT_IIC_Send_Byte
;;;75     	CT_IIC_Wait_Ack();  
00002c  f7fffffe          BL       CT_IIC_Wait_Ack
;;;76     	for(i=0;i<len;i++)
000030  2500              MOVS     r5,#0
000032  e00b              B        |L5.76|
                  |L5.52|
;;;77     	{	   
;;;78         	CT_IIC_Send_Byte(buf[i]);  	//发数据
000034  5d70              LDRB     r0,[r6,r5]
000036  f7fffffe          BL       CT_IIC_Send_Byte
;;;79     		ret=CT_IIC_Wait_Ack();
00003a  f7fffffe          BL       CT_IIC_Wait_Ack
00003e  4680              MOV      r8,r0
;;;80     		if(ret)break;  
000040  f1b80f00          CMP      r8,#0
000044  d000              BEQ      |L5.72|
000046  e003              B        |L5.80|
                  |L5.72|
000048  1c68              ADDS     r0,r5,#1              ;76
00004a  b2c5              UXTB     r5,r0                 ;76
                  |L5.76|
00004c  42bd              CMP      r5,r7                 ;76
00004e  dbf1              BLT      |L5.52|
                  |L5.80|
000050  bf00              NOP      
;;;81     	}
;;;82         CT_IIC_Stop();					//产生一个停止条件	    
000052  f7fffffe          BL       CT_IIC_Stop
;;;83     	return ret; 
000056  4640              MOV      r0,r8
;;;84     }
000058  e8bd81f0          POP      {r4-r8,pc}
;;;85     //从GT9147读出一次数据
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=1

                  GT9147_CFG_TBL
000000  60e00120          DCB      0x60,0xe0,0x01,0x20
000004  03053500          DCB      0x03,0x05,0x35,0x00
000008  02081e08          DCB      0x02,0x08,0x1e,0x08
00000c  503c0f05          DCB      0x50,0x3c,0x0f,0x05
000010  0000ff67          DCB      0x00,0x00,0xff,0x67
000014  50000018          DCB      0x50,0x00,0x00,0x18
000018  1a1e1489          DCB      0x1a,0x1e,0x14,0x89
00001c  280a302e          DCB      0x28,0x0a,0x30,0x2e
000020  bb0a0300          DCB      0xbb,0x0a,0x03,0x00
000024  0002331d          DCB      0x00,0x02,0x33,0x1d
000028  00000000          DCB      0x00,0x00,0x00,0x00
00002c  00000032          DCB      0x00,0x00,0x00,0x32
000030  00002a1c          DCB      0x00,0x00,0x2a,0x1c
000034  5a94c502          DCB      0x5a,0x94,0xc5,0x02
000038  07000000          DCB      0x07,0x00,0x00,0x00
00003c  b51f0090          DCB      0xb5,0x1f,0x00,0x90
000040  28007732          DCB      0x28,0x00,0x77,0x32
000044  00623f00          DCB      0x00,0x62,0x3f,0x00
000048  52500052          DCB      0x52,0x50,0x00,0x52
00004c  00000000          DCB      0x00,0x00,0x00,0x00
000050  00000000          DCB      0x00,0x00,0x00,0x00
000054  00000000          DCB      0x00,0x00,0x00,0x00
000058  00000000          DCB      0x00,0x00,0x00,0x00
00005c  00000000          DCB      0x00,0x00,0x00,0x00
000060  0000000f          DCB      0x00,0x00,0x00,0x0f
000064  0f030610          DCB      0x0f,0x03,0x06,0x10
000068  42f80f14          DCB      0x42,0xf8,0x0f,0x14
00006c  00000000          DCB      0x00,0x00,0x00,0x00
000070  1a181614          DCB      0x1a,0x18,0x16,0x14
000074  12100e0c          DCB      0x12,0x10,0x0e,0x0c
000078  0a080000          DCB      0x0a,0x08,0x00,0x00
00007c  00000000          DCB      0x00,0x00,0x00,0x00
000080  00000000          DCB      0x00,0x00,0x00,0x00
000084  00000000          DCB      0x00,0x00,0x00,0x00
000088  00000000          DCB      0x00,0x00,0x00,0x00
00008c  00002928          DCB      0x00,0x00,0x29,0x28
000090  2422201f          DCB      0x24,0x22,0x20,0x1f
000094  1e1d0e0c          DCB      0x1e,0x1d,0x0e,0x0c
000098  0a080605          DCB      0x0a,0x08,0x06,0x05
00009c  040200ff          DCB      0x04,0x02,0x00,0xff
0000a0  00000000          DCB      0x00,0x00,0x00,0x00
0000a4  00000000          DCB      0x00,0x00,0x00,0x00
0000a8  000000ff          DCB      0x00,0x00,0x00,0xff
0000ac  ffffffff          DCB      0xff,0xff,0xff,0xff
0000b0  ffffffff          DCB      0xff,0xff,0xff,0xff
0000b4  ffffffff          DCB      0xff,0xff,0xff,0xff
                  GT9147_TPX_TBL
0000b8  81508158          DCW      0x8150,0x8158
0000bc  81608168          DCW      0x8160,0x8168
0000c0  8170              DCW      0x8170

                          AREA ||.data||, DATA, ALIGN=0

                  t
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\LCD_Driver\\gt9147.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_gt9147_c_f8193403____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___8_gt9147_c_f8193403____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_gt9147_c_f8193403____REVSH|
#line 128
|__asm___8_gt9147_c_f8193403____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

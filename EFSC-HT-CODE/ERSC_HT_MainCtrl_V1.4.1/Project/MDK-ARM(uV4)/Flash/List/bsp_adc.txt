; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_adc.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_adc.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\FatFS\src -I..\..\User\Mass_Storage\inc -I..\..\User\LCD_Driver -I..\..\User\SYSTEM\sys -I..\..\User\Debugprintf -I..\..\User\LogDebug -I..\..\User\app\inc -I..\..\User\app\src -I..\..\User\bsp\inc -I..\..\User\bsp\src -I.\RTE\_Flash -ID:\Keil_v5\ARM\Packs\ARM\CMSIS\5.5.1\CMSIS\Core\Include -ID:\Keil_v5\ARM\Packs\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=527 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_adc.crf ..\..\User\bsp\src\bsp_adc.c]
                          THUMB

                          AREA ||i.ADC_Ctrl_Current_acqdata||, CODE, READONLY, ALIGN=2

                  ADC_Ctrl_Current_acqdata PROC
;;;217    /*************************控制电流采集*****************************/
;;;218    void ADC_Ctrl_Current_acqdata(void)
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;219    {
;;;220    	
;;;221    	float adc0,rms0;
;;;222    	bsp_DelayUS(230);
000004  20e6              MOVS     r0,#0xe6
000006  f7fffffe          BL       bsp_DelayUS
;;;223    	
;;;224    	adc0 = (float)ADC_ConvertedValue[2]/4096*3.3- voltage[0];
00000a  4932              LDR      r1,|L1.212|
00000c  6808              LDR      r0,[r1,#0]  ; voltage
00000e  f7fffffe          BL       __aeabi_f2d
000012  4605              MOV      r5,r0
000014  460e              MOV      r6,r1
000016  4930              LDR      r1,|L1.216|
000018  8888              LDRH     r0,[r1,#4]  ; ADC_ConvertedValue
00001a  f7fffffe          BL       __aeabi_ui2f
00001e  f04f418b          MOV      r1,#0x45800000
000022  9000              STR      r0,[sp,#0]
000024  f7fffffe          BL       __aeabi_fdiv
000028  9001              STR      r0,[sp,#4]
00002a  f7fffffe          BL       __aeabi_f2d
00002e  f04f3266          MOV      r2,#0x66666666
000032  4b2a              LDR      r3,|L1.220|
000034  e9cd0102          STRD     r0,r1,[sp,#8]
000038  f7fffffe          BL       __aeabi_dmul
00003c  4607              MOV      r7,r0
00003e  462a              MOV      r2,r5
000040  4633              MOV      r3,r6
000042  f7fffffe          BL       __aeabi_dsub
000046  4682              MOV      r10,r0
000048  f7fffffe          BL       __aeabi_d2f
00004c  4604              MOV      r4,r0
;;;225    	
;;;226    	adc0 = adc0 * adc0;
00004e  4621              MOV      r1,r4
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       __aeabi_fmul
000056  4604              MOV      r4,r0
;;;227    	sum1 += adc0;
000058  4621              MOV      r1,r4
00005a  4821              LDR      r0,|L1.224|
00005c  6800              LDR      r0,[r0,#0]  ; sum1
00005e  f7fffffe          BL       __aeabi_fadd
000062  491f              LDR      r1,|L1.224|
000064  6008              STR      r0,[r1,#0]  ; sum1
;;;228    	adc_num1++;
000066  481f              LDR      r0,|L1.228|
000068  8800              LDRH     r0,[r0,#0]  ; adc_num1
00006a  1c40              ADDS     r0,r0,#1
00006c  491d              LDR      r1,|L1.228|
00006e  8008              STRH     r0,[r1,#0]
;;;229    	if(adc_num1>154)
000070  4608              MOV      r0,r1
000072  8800              LDRH     r0,[r0,#0]  ; adc_num1
000074  289a              CMP      r0,#0x9a
000076  dd2a              BLE      |L1.206|
;;;230    	{
;;;231    		adc_num1 = 0;
000078  2000              MOVS     r0,#0
00007a  8008              STRH     r0,[r1,#0]
;;;232    		
;;;233    		sum1 = sum1 / 154;
00007c  491a              LDR      r1,|L1.232|
00007e  4818              LDR      r0,|L1.224|
000080  6800              LDR      r0,[r0,#0]  ; sum1
000082  f7fffffe          BL       __aeabi_fdiv
000086  4916              LDR      r1,|L1.224|
000088  6008              STR      r0,[r1,#0]  ; sum1
;;;234    		rms0 = sqrt(sum1);  //平方和取平均，再开方
00008a  4608              MOV      r0,r1
00008c  6800              LDR      r0,[r0,#0]  ; sum1
00008e  f7fffffe          BL       __aeabi_f2d
000092  4607              MOV      r7,r0
000094  f7fffffe          BL       sqrt
000098  4605              MOV      r5,r0
00009a  f7fffffe          BL       __aeabi_d2f
00009e  4681              MOV      r9,r0
;;;235    		ctrl_current = rms0/264*1000*1000; //控制电流.
0000a0  4912              LDR      r1,|L1.236|
0000a2  4648              MOV      r0,r9
0000a4  f7fffffe          BL       __aeabi_fdiv
0000a8  4607              MOV      r7,r0
0000aa  4911              LDR      r1,|L1.240|
0000ac  f7fffffe          BL       __aeabi_fmul
0000b0  4606              MOV      r6,r0
0000b2  490f              LDR      r1,|L1.240|
0000b4  f7fffffe          BL       __aeabi_fmul
0000b8  4605              MOV      r5,r0
0000ba  f7fffffe          BL       __aeabi_f2uiz
0000be  490d              LDR      r1,|L1.244|
0000c0  8008              STRH     r0,[r1,#0]
;;;236    //////		printf("ctrl_current %d",ctrl_current);
;;;237    	if(ctrl_current < 35)
0000c2  4608              MOV      r0,r1
0000c4  8800              LDRH     r0,[r0,#0]  ; ctrl_current
0000c6  2823              CMP      r0,#0x23
0000c8  da01              BGE      |L1.206|
;;;238    	{
;;;239    		ctrl_current = 0;	
0000ca  2000              MOVS     r0,#0
0000cc  8008              STRH     r0,[r1,#0]
                  |L1.206|
;;;240    	}
;;;241    	
;;;242    	}
;;;243    }
0000ce  e8bd9fff          POP      {r0-r12,pc}
;;;244    
                          ENDP

0000d2  0000              DCW      0x0000
                  |L1.212|
                          DCD      voltage
                  |L1.216|
                          DCD      ADC_ConvertedValue
                  |L1.220|
                          DCD      0x400a6666
                  |L1.224|
                          DCD      sum1
                  |L1.228|
                          DCD      adc_num1
                  |L1.232|
                          DCD      0x431a0000
                  |L1.236|
                          DCD      0x43840000
                  |L1.240|
                          DCD      0x447a0000
                  |L1.244|
                          DCD      ctrl_current

                          AREA ||i.ADC_Motor_Current_acqdata||, CODE, READONLY, ALIGN=2

                  ADC_Motor_Current_acqdata PROC
;;;245    /*************************电机电流采集*****************************/
;;;246    void ADC_Motor_Current_acqdata(void)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;247    	{
000004  b089              SUB      sp,sp,#0x24
;;;248    			float adc1,adc2,rms1,rms2;
;;;249    			float Adc_freq_point;
;;;250    			float  adc_time;
;;;251    			float freq;
;;;252    				
;;;253    				
;;;254    			freq = send_data.data.real_freq;
000006  496d              LDR      r1,|L2.444|
000008  f8b1002b          LDRH     r0,[r1,#0x2b]
00000c  f7fffffe          BL       __aeabi_ui2f
000010  9006              STR      r0,[sp,#0x18]
;;;255    			freq = freq/100;
000012  496b              LDR      r1,|L2.448|
000014  9806              LDR      r0,[sp,#0x18]
000016  f7fffffe          BL       __aeabi_fdiv
00001a  9006              STR      r0,[sp,#0x18]
;;;256    			adc_time = 1/freq;
00001c  f04f507e          MOV      r0,#0x3f800000
000020  9906              LDR      r1,[sp,#0x18]
000022  f7fffffe          BL       __aeabi_fdiv
000026  9007              STR      r0,[sp,#0x1c]
;;;257    			adc_time = adc_time*1000;//ms
000028  4966              LDR      r1,|L2.452|
00002a  9807              LDR      r0,[sp,#0x1c]
00002c  f7fffffe          BL       __aeabi_fmul
000030  9007              STR      r0,[sp,#0x1c]
;;;258    			Adc_freq_point = (int)adc_time*2/0.324;
000032  9807              LDR      r0,[sp,#0x1c]
000034  f7fffffe          BL       __aeabi_f2iz
000038  0040              LSLS     r0,r0,#1
00003a  9005              STR      r0,[sp,#0x14]
00003c  f7fffffe          BL       __aeabi_i2d
000040  4682              MOV      r10,r0
000042  4a61              LDR      r2,|L2.456|
000044  4b61              LDR      r3,|L2.460|
000046  f7fffffe          BL       __aeabi_ddiv
00004a  4607              MOV      r7,r0
00004c  f7fffffe          BL       __aeabi_d2f
000050  9008              STR      r0,[sp,#0x20]
;;;259    			
;;;260    			adc1 = (float)ADC_ConvertedValue[3]/4096*3.3 - voltage[1];
000052  495f              LDR      r1,|L2.464|
000054  6848              LDR      r0,[r1,#4]  ; voltage
000056  f7fffffe          BL       __aeabi_f2d
00005a  e9cd0104          STRD     r0,r1,[sp,#0x10]
00005e  495d              LDR      r1,|L2.468|
000060  88c8              LDRH     r0,[r1,#6]  ; ADC_ConvertedValue
000062  f7fffffe          BL       __aeabi_ui2f
000066  f04f418b          MOV      r1,#0x45800000
00006a  9000              STR      r0,[sp,#0]
00006c  f7fffffe          BL       __aeabi_fdiv
000070  9001              STR      r0,[sp,#4]
000072  f7fffffe          BL       __aeabi_f2d
000076  4607              MOV      r7,r0
000078  f04f3266          MOV      r2,#0x66666666
00007c  4b56              LDR      r3,|L2.472|
00007e  f7fffffe          BL       __aeabi_dmul
000082  e9cd0102          STRD     r0,r1,[sp,#8]
000086  e9dd2304          LDRD     r2,r3,[sp,#0x10]
00008a  f7fffffe          BL       __aeabi_dsub
00008e  4682              MOV      r10,r0
000090  f7fffffe          BL       __aeabi_d2f
000094  4604              MOV      r4,r0
;;;261    			adc2 = (float)ADC_ConvertedValue[4]/4096*3.3 - voltage[2];
000096  494e              LDR      r1,|L2.464|
000098  6888              LDR      r0,[r1,#8]  ; voltage
00009a  f7fffffe          BL       __aeabi_f2d
00009e  4682              MOV      r10,r0
0000a0  468b              MOV      r11,r1
0000a2  494c              LDR      r1,|L2.468|
0000a4  8908              LDRH     r0,[r1,#8]  ; ADC_ConvertedValue
0000a6  f7fffffe          BL       __aeabi_ui2f
0000aa  f04f418b          MOV      r1,#0x45800000
0000ae  9000              STR      r0,[sp,#0]
0000b0  f7fffffe          BL       __aeabi_fdiv
0000b4  9001              STR      r0,[sp,#4]
0000b6  f7fffffe          BL       __aeabi_f2d
0000ba  4607              MOV      r7,r0
0000bc  f04f3266          MOV      r2,#0x66666666
0000c0  4b45              LDR      r3,|L2.472|
0000c2  f7fffffe          BL       __aeabi_dmul
0000c6  4652              MOV      r2,r10
0000c8  465b              MOV      r3,r11
0000ca  e9cd0102          STRD     r0,r1,[sp,#8]
0000ce  f7fffffe          BL       __aeabi_dsub
0000d2  e9cd0104          STRD     r0,r1,[sp,#0x10]
0000d6  f7fffffe          BL       __aeabi_d2f
0000da  4605              MOV      r5,r0
;;;262    			
;;;263    			adc2 = adc2 * adc2;
0000dc  4629              MOV      r1,r5
0000de  4628              MOV      r0,r5
0000e0  f7fffffe          BL       __aeabi_fmul
0000e4  4605              MOV      r5,r0
;;;264    			adc1 = adc1 * adc1;
0000e6  4621              MOV      r1,r4
0000e8  4620              MOV      r0,r4
0000ea  f7fffffe          BL       __aeabi_fmul
0000ee  4604              MOV      r4,r0
;;;265    			sum2 += adc1;
0000f0  4621              MOV      r1,r4
0000f2  483a              LDR      r0,|L2.476|
0000f4  6800              LDR      r0,[r0,#0]  ; sum2
0000f6  f7fffffe          BL       __aeabi_fadd
0000fa  4938              LDR      r1,|L2.476|
0000fc  6008              STR      r0,[r1,#0]  ; sum2
;;;266    			sum3 += adc2;
0000fe  4629              MOV      r1,r5
000100  4837              LDR      r0,|L2.480|
000102  6800              LDR      r0,[r0,#0]  ; sum3
000104  f7fffffe          BL       __aeabi_fadd
000108  4935              LDR      r1,|L2.480|
00010a  6008              STR      r0,[r1,#0]  ; sum3
;;;267    			adc_num2++;
00010c  4835              LDR      r0,|L2.484|
00010e  8800              LDRH     r0,[r0,#0]  ; adc_num2
000110  1c40              ADDS     r0,r0,#1
000112  4934              LDR      r1,|L2.484|
000114  8008              STRH     r0,[r1,#0]
;;;268    			
;;;269    			
;;;270    			if(adc_num2 > Adc_freq_point)
000116  4608              MOV      r0,r1
000118  8800              LDRH     r0,[r0,#0]  ; adc_num2
00011a  f7fffffe          BL       __aeabi_ui2f
00011e  4607              MOV      r7,r0
000120  9908              LDR      r1,[sp,#0x20]
000122  f7fffffe          BL       __aeabi_cfrcmple
000126  d246              BCS      |L2.438|
;;;271    			{
;;;272    					adc_num2 = 0;
000128  2000              MOVS     r0,#0
00012a  492e              LDR      r1,|L2.484|
00012c  8008              STRH     r0,[r1,#0]
;;;273    					
;;;274    ////					GPIOE ->ODR ^= GPIO_Pin_6;
;;;275    					sum2 = sum2 / Adc_freq_point;
00012e  482b              LDR      r0,|L2.476|
000130  9908              LDR      r1,[sp,#0x20]
000132  6800              LDR      r0,[r0,#0]  ; sum2
000134  f7fffffe          BL       __aeabi_fdiv
000138  4928              LDR      r1,|L2.476|
00013a  6008              STR      r0,[r1,#0]  ; sum2
;;;276    					sum3 = sum3 / Adc_freq_point;
00013c  4828              LDR      r0,|L2.480|
00013e  9908              LDR      r1,[sp,#0x20]
000140  6800              LDR      r0,[r0,#0]  ; sum3
000142  f7fffffe          BL       __aeabi_fdiv
000146  4926              LDR      r1,|L2.480|
000148  6008              STR      r0,[r1,#0]  ; sum3
;;;277    					rms1 = sqrt(sum2);  //平方和取平均，再开方
00014a  4824              LDR      r0,|L2.476|
00014c  6800              LDR      r0,[r0,#0]  ; sum2
00014e  f7fffffe          BL       __aeabi_f2d
000152  4607              MOV      r7,r0
000154  f7fffffe          BL       sqrt
000158  4682              MOV      r10,r0
00015a  f7fffffe          BL       __aeabi_d2f
00015e  4606              MOV      r6,r0
;;;278    					rms2 = sqrt(sum3);//* 3961.53;
000160  481f              LDR      r0,|L2.480|
000162  6800              LDR      r0,[r0,#0]  ; sum3
000164  f7fffffe          BL       __aeabi_f2d
000168  4682              MOV      r10,r0
00016a  f7fffffe          BL       sqrt
00016e  4607              MOV      r7,r0
000170  f7fffffe          BL       __aeabi_d2f
000174  4681              MOV      r9,r0
;;;279    					Motor_Voltage = rms2 * 22.36 * 102.90;
000176  4648              MOV      r0,r9
000178  f7fffffe          BL       __aeabi_f2d
00017c  4607              MOV      r7,r0
00017e  4a1a              LDR      r2,|L2.488|
000180  4b1a              LDR      r3,|L2.492|
000182  f7fffffe          BL       __aeabi_dmul
000186  4a1a              LDR      r2,|L2.496|
000188  4b1a              LDR      r3,|L2.500|
00018a  e9cd0104          STRD     r0,r1,[sp,#0x10]
00018e  f7fffffe          BL       __aeabi_dmul
000192  4682              MOV      r10,r0
000194  f7fffffe          BL       __aeabi_d2uiz
000198  4917              LDR      r1,|L2.504|
00019a  8008              STRH     r0,[r1,#0]
;;;280    					Motor_Current = rms1/264*10000;  //控制电流.
00019c  4917              LDR      r1,|L2.508|
00019e  4630              MOV      r0,r6
0001a0  f7fffffe          BL       __aeabi_fdiv
0001a4  4680              MOV      r8,r0
0001a6  4916              LDR      r1,|L2.512|
0001a8  f7fffffe          BL       __aeabi_fmul
0001ac  4607              MOV      r7,r0
0001ae  f7fffffe          BL       __aeabi_f2uiz
0001b2  4914              LDR      r1,|L2.516|
0001b4  8008              STRH     r0,[r1,#0]
                  |L2.438|
;;;281    					
;;;282    			
;;;283    ////					printf("adc_initv %x",send_data.AC_voltage_of_floor_motor);
;;;284    			}
;;;285    
;;;286    }
0001b6  b009              ADD      sp,sp,#0x24
0001b8  e8bd8ff0          POP      {r4-r11,pc}
;;;287    
                          ENDP

                  |L2.444|
                          DCD      send_data
                  |L2.448|
                          DCD      0x42c80000
                  |L2.452|
                          DCD      0x447a0000
                  |L2.456|
                          DCD      0x7ef9db23
                  |L2.460|
                          DCD      0x3fd4bc6a
                  |L2.464|
                          DCD      voltage
                  |L2.468|
                          DCD      ADC_ConvertedValue
                  |L2.472|
                          DCD      0x400a6666
                  |L2.476|
                          DCD      sum2
                  |L2.480|
                          DCD      sum3
                  |L2.484|
                          DCD      adc_num2
                  |L2.488|
                          DCD      0xf5c28f5c
                  |L2.492|
                          DCD      0x40365c28
                  |L2.496|
                          DCD      0x9999999a
                  |L2.500|
                          DCD      0x4059b999
                  |L2.504|
                          DCD      Motor_Voltage
                  |L2.508|
                          DCD      0x43840000
                  |L2.512|
                          DCD      0x461c4000
                  |L2.516|
                          DCD      Motor_Current

                          AREA ||i.ADCx_GPIO_Config||, CODE, READONLY, ALIGN=2

                  ADCx_GPIO_Config PROC
;;;34       */
;;;35     static void ADCx_GPIO_Config(void)
000000  b508              PUSH     {r3,lr}
;;;36     {
;;;37     	GPIO_InitTypeDef GPIO_InitStructure;
;;;38     	
;;;39     	// 打开 ADC IO端口时钟
;;;40     	ADC_GPIO_APBxClock_FUN ( ADC_GPIO_CLK, ENABLE ); // 这里似乎缺少对 ADC_PIN1 ，ADC_PIN2的时钟配置
000002  2101              MOVS     r1,#1
000004  2010              MOVS     r0,#0x10
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;41     	
;;;42     	// 配置 ADC IO 引脚模式
;;;43     	GPIO_InitStructure.GPIO_Pin = ADC_PIN1 | ADC_PIN2 | ADC_PIN3  | ADC_PIN4 | ADC_PIN5 ;
00000a  201e              MOVS     r0,#0x1e
00000c  f8ad0000          STRH     r0,[sp,#0]
;;;44     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
000010  2000              MOVS     r0,#0
000012  f88d0003          STRB     r0,[sp,#3]
;;;45     	
;;;46     	// 初始化 ADC IO
;;;47     	GPIO_Init(ADC_PORT1, &GPIO_InitStructure);
000016  4669              MOV      r1,sp
000018  4809              LDR      r0,|L3.64|
00001a  f7fffffe          BL       GPIO_Init
;;;48     	GPIO_Init(ADC_PORT2, &GPIO_InitStructure);
00001e  4669              MOV      r1,sp
000020  4808              LDR      r0,|L3.68|
000022  f7fffffe          BL       GPIO_Init
;;;49     	GPIO_Init(ADC_PORT3, &GPIO_InitStructure);	
000026  4669              MOV      r1,sp
000028  4807              LDR      r0,|L3.72|
00002a  f7fffffe          BL       GPIO_Init
;;;50     	GPIO_Init(ADC_PORT4, &GPIO_InitStructure);	
00002e  4669              MOV      r1,sp
000030  4805              LDR      r0,|L3.72|
000032  f7fffffe          BL       GPIO_Init
;;;51     	GPIO_Init(ADC_PORT5, &GPIO_InitStructure);
000036  4669              MOV      r1,sp
000038  4803              LDR      r0,|L3.72|
00003a  f7fffffe          BL       GPIO_Init
;;;52     }
00003e  bd08              POP      {r3,pc}
;;;53     
                          ENDP

                  |L3.64|
                          DCD      0x40010800
                  |L3.68|
                          DCD      0x40010c00
                  |L3.72|
                          DCD      0x40011000

                          AREA ||i.ADCx_Init||, CODE, READONLY, ALIGN=1

                  ADCx_Init PROC
;;;171    extern void RefreshNumber(uint16_t addr,uint16_t number);
;;;172    void ADCx_Init(void)
000000  b510              PUSH     {r4,lr}
;;;173    {
;;;174    	ADCx_GPIO_Config();
000002  f7fffffe          BL       ADCx_GPIO_Config
;;;175    	ADCx_Mode_Config();
000006  f7fffffe          BL       ADCx_Mode_Config
;;;176    }
00000a  bd10              POP      {r4,pc}
;;;177    
                          ENDP


                          AREA ||i.ADCx_Mode_Config||, CODE, READONLY, ALIGN=2

                  ADCx_Mode_Config PROC
;;;58      *******************************************/
;;;59     static void ADCx_Mode_Config(void)
000000  b500              PUSH     {lr}
;;;60     {
000002  b091              SUB      sp,sp,#0x44
;;;61     	DMA_InitTypeDef DMA_InitStructure;
;;;62     	ADC_InitTypeDef ADC_InitStructure;
;;;63     	
;;;64     	// 打开DMA时钟
;;;65     	RCC_AHBPeriphClockCmd(ADC_DMA_CLK, ENABLE);
000004  2101              MOVS     r1,#1
000006  4608              MOV      r0,r1
000008  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;66     	// 打开ADC时钟
;;;67     	ADC_APBxClock_FUN ( ADC_CLK, ENABLE );
00000c  2101              MOVS     r1,#1
00000e  0248              LSLS     r0,r1,#9
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;68     	
;;;69     	// 复位DMA控制器
;;;70     	DMA_DeInit(ADC_DMA_CHANNEL);
000014  4841              LDR      r0,|L5.284|
000016  f7fffffe          BL       DMA_DeInit
;;;71     	
;;;72     	// 配置 DMA 初始化结构体
;;;73     	// 外设基址为：ADC 数据寄存器地址
;;;74     	DMA_InitStructure.DMA_PeripheralBaseAddr = ( u32 ) ( & ( ADC_x->DR ) );
00001a  4841              LDR      r0,|L5.288|
00001c  9006              STR      r0,[sp,#0x18]
;;;75     	
;;;76     	// 存储器地址
;;;77     	DMA_InitStructure.DMA_MemoryBaseAddr = (u32)ADC_ConvertedValue;
00001e  4841              LDR      r0,|L5.292|
000020  9007              STR      r0,[sp,#0x1c]
;;;78     	
;;;79     	// 数据源来自外设
;;;80     	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
000022  2000              MOVS     r0,#0
000024  9008              STR      r0,[sp,#0x20]
;;;81     	
;;;82     	// 缓冲区大小，应该等于数据目的地的大小
;;;83     	DMA_InitStructure.DMA_BufferSize = NOFCHANEL;
000026  2005              MOVS     r0,#5
000028  9009              STR      r0,[sp,#0x24]
;;;84     	
;;;85     	// 外设寄存器只有一个，地址不用递增
;;;86     	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
00002a  2000              MOVS     r0,#0
00002c  900a              STR      r0,[sp,#0x28]
;;;87     
;;;88     	// 存储器地址递增
;;;89     	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable; 
00002e  2080              MOVS     r0,#0x80
000030  900b              STR      r0,[sp,#0x2c]
;;;90     	
;;;91     	// 外设数据大小为半字，即两个字节
;;;92     	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
000032  0040              LSLS     r0,r0,#1
000034  900c              STR      r0,[sp,#0x30]
;;;93     	
;;;94     	// 内存数据大小也为半字，跟外设数据大小相同
;;;95     	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
000036  0080              LSLS     r0,r0,#2
000038  900d              STR      r0,[sp,#0x34]
;;;96     	
;;;97     	// 循环传输模式
;;;98     	DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;	
00003a  2020              MOVS     r0,#0x20
00003c  900e              STR      r0,[sp,#0x38]
;;;99     
;;;100    	// DMA 传输通道优先级为高，当使用一个DMA通道时，优先级设置不影响
;;;101    	DMA_InitStructure.DMA_Priority = DMA_Priority_High;
00003e  0200              LSLS     r0,r0,#8
000040  900f              STR      r0,[sp,#0x3c]
;;;102    	
;;;103    	// 禁止存储器到存储器模式，因为是从外设到存储器
;;;104    	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
000042  2000              MOVS     r0,#0
000044  9010              STR      r0,[sp,#0x40]
;;;105    	
;;;106    	// 初始化DMA
;;;107    	DMA_Init(ADC_DMA_CHANNEL, &DMA_InitStructure);
000046  a906              ADD      r1,sp,#0x18
000048  4834              LDR      r0,|L5.284|
00004a  f7fffffe          BL       DMA_Init
;;;108    	
;;;109    	// 使能 DMA 通道
;;;110    	DMA_Cmd(ADC_DMA_CHANNEL , ENABLE);
00004e  2101              MOVS     r1,#1
000050  4832              LDR      r0,|L5.284|
000052  f7fffffe          BL       DMA_Cmd
;;;111    	
;;;112    	// ADC 模式配置
;;;113    	// 只使用一个ADC，属于单模式
;;;114    	ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
000056  2000              MOVS     r0,#0
000058  9001              STR      r0,[sp,#4]
;;;115    	
;;;116    	// 扫描模式
;;;117    	ADC_InitStructure.ADC_ScanConvMode = ENABLE ; 
00005a  2001              MOVS     r0,#1
00005c  f88d0008          STRB     r0,[sp,#8]
;;;118    
;;;119    	// 连续转换模式
;;;120    	ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;
000060  f88d0009          STRB     r0,[sp,#9]
;;;121    
;;;122    	// 不用外部触发转换，软件开启即可
;;;123    	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
000064  f44f2060          MOV      r0,#0xe0000
000068  9003              STR      r0,[sp,#0xc]
;;;124    
;;;125    	// 转换结果右对齐
;;;126    	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
00006a  2000              MOVS     r0,#0
00006c  9004              STR      r0,[sp,#0x10]
;;;127    	
;;;128    	// 转换通道个数
;;;129    	ADC_InitStructure.ADC_NbrOfChannel = NOFCHANEL;	
00006e  2005              MOVS     r0,#5
000070  f88d0014          STRB     r0,[sp,#0x14]
;;;130    		
;;;131    	// 初始化ADC
;;;132    	ADC_Init(ADC_x, &ADC_InitStructure);
000074  a901              ADD      r1,sp,#4
000076  482a              LDR      r0,|L5.288|
000078  384c              SUBS     r0,r0,#0x4c
00007a  f7fffffe          BL       ADC_Init
;;;133    	
;;;134    	// 配置ADC时钟ＮPCLK2的8分频，即9MHz
;;;135    	RCC_ADCCLKConfig(RCC_PCLK2_Div8); 
00007e  f44f4040          MOV      r0,#0xc000
000082  f7fffffe          BL       RCC_ADCCLKConfig
;;;136    	
;;;137    	// 配置ADC 通道的转换顺序和采样时间
;;;138    	ADC_RegularChannelConfig(ADC_x, ADC_Channel_4, 1, ADC_SampleTime_55Cycles5);
000086  2305              MOVS     r3,#5
000088  2201              MOVS     r2,#1
00008a  2104              MOVS     r1,#4
00008c  4824              LDR      r0,|L5.288|
00008e  384c              SUBS     r0,r0,#0x4c
000090  f7fffffe          BL       ADC_RegularChannelConfig
;;;139    	ADC_RegularChannelConfig(ADC_x, ADC_Channel_9, 2, ADC_SampleTime_55Cycles5);
000094  2305              MOVS     r3,#5
000096  2202              MOVS     r2,#2
000098  2109              MOVS     r1,#9
00009a  4821              LDR      r0,|L5.288|
00009c  384c              SUBS     r0,r0,#0x4c
00009e  f7fffffe          BL       ADC_RegularChannelConfig
;;;140    	ADC_RegularChannelConfig(ADC_x, ADC_Channel_12, 3, ADC_SampleTime_55Cycles5);
0000a2  2305              MOVS     r3,#5
0000a4  2203              MOVS     r2,#3
0000a6  210c              MOVS     r1,#0xc
0000a8  481d              LDR      r0,|L5.288|
0000aa  384c              SUBS     r0,r0,#0x4c
0000ac  f7fffffe          BL       ADC_RegularChannelConfig
;;;141    	ADC_RegularChannelConfig(ADC_x, ADC_Channel_13, 4, ADC_SampleTime_55Cycles5);
0000b0  2305              MOVS     r3,#5
0000b2  2204              MOVS     r2,#4
0000b4  210d              MOVS     r1,#0xd
0000b6  481a              LDR      r0,|L5.288|
0000b8  384c              SUBS     r0,r0,#0x4c
0000ba  f7fffffe          BL       ADC_RegularChannelConfig
;;;142    	ADC_RegularChannelConfig(ADC_x, ADC_Channel_14, 5, ADC_SampleTime_55Cycles5);
0000be  2305              MOVS     r3,#5
0000c0  461a              MOV      r2,r3
0000c2  210e              MOVS     r1,#0xe
0000c4  4816              LDR      r0,|L5.288|
0000c6  384c              SUBS     r0,r0,#0x4c
0000c8  f7fffffe          BL       ADC_RegularChannelConfig
;;;143    
;;;144    	
;;;145    	// 使能ADC DMA 请求
;;;146    	ADC_DMACmd(ADC_x, ENABLE);
0000cc  2101              MOVS     r1,#1
0000ce  4814              LDR      r0,|L5.288|
0000d0  384c              SUBS     r0,r0,#0x4c
0000d2  f7fffffe          BL       ADC_DMACmd
;;;147    	
;;;148    	// 开启ADC ，并开始转换
;;;149    	ADC_Cmd(ADC_x, ENABLE);
0000d6  2101              MOVS     r1,#1
0000d8  4811              LDR      r0,|L5.288|
0000da  384c              SUBS     r0,r0,#0x4c
0000dc  f7fffffe          BL       ADC_Cmd
;;;150    	
;;;151    	// 初始化ADC 校准寄存器  
;;;152    	ADC_ResetCalibration(ADC_x);
0000e0  480f              LDR      r0,|L5.288|
0000e2  384c              SUBS     r0,r0,#0x4c
0000e4  f7fffffe          BL       ADC_ResetCalibration
;;;153    	// 等待校准寄存器初始化完成
;;;154    	while(ADC_GetResetCalibrationStatus(ADC_x));
0000e8  bf00              NOP      
                  |L5.234|
0000ea  480d              LDR      r0,|L5.288|
0000ec  384c              SUBS     r0,r0,#0x4c
0000ee  f7fffffe          BL       ADC_GetResetCalibrationStatus
0000f2  2800              CMP      r0,#0
0000f4  d1f9              BNE      |L5.234|
;;;155    	
;;;156    	// ADC开始校准
;;;157    	ADC_StartCalibration(ADC_x);
0000f6  480a              LDR      r0,|L5.288|
0000f8  384c              SUBS     r0,r0,#0x4c
0000fa  f7fffffe          BL       ADC_StartCalibration
;;;158    	// 等待校准完成
;;;159    	while(ADC_GetCalibrationStatus(ADC_x));
0000fe  bf00              NOP      
                  |L5.256|
000100  4807              LDR      r0,|L5.288|
000102  384c              SUBS     r0,r0,#0x4c
000104  f7fffffe          BL       ADC_GetCalibrationStatus
000108  2800              CMP      r0,#0
00010a  d1f9              BNE      |L5.256|
;;;160    	
;;;161    	// 由于没有采用外部触发，所以使用软件触发ADC转换 
;;;162    	ADC_SoftwareStartConvCmd(ADC_x, ENABLE);
00010c  2101              MOVS     r1,#1
00010e  4804              LDR      r0,|L5.288|
000110  384c              SUBS     r0,r0,#0x4c
000112  f7fffffe          BL       ADC_SoftwareStartConvCmd
;;;163    }
000116  b011              ADD      sp,sp,#0x44
000118  bd00              POP      {pc}
;;;164    
                          ENDP

00011a  0000              DCW      0x0000
                  |L5.284|
                          DCD      0x40020008
                  |L5.288|
                          DCD      0x4001244c
                  |L5.292|
                          DCD      ADC_ConvertedValue

                          AREA ||i.Initialvoltagevalue||, CODE, READONLY, ALIGN=2

                  Initialvoltagevalue PROC
;;;192    //****************偏置电压采集*****************//
;;;193    void Initialvoltagevalue(void)	
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;194    {
;;;195    	u16 i;
;;;196    	u32 s0,s1,s2;
;;;197    	
;;;198    	s0 = 0;
000004  2400              MOVS     r4,#0
;;;199    	s1 = 0;
000006  2500              MOVS     r5,#0
;;;200    	s2 = 0;
000008  2600              MOVS     r6,#0
;;;201    	for(i=0;i<512;i++)
00000a  46a1              MOV      r9,r4
00000c  e00f              B        |L6.46|
                  |L6.14|
;;;202    	{
;;;203    		s0 += ADC_ConvertedValue[2];
00000e  482d              LDR      r0,|L6.196|
000010  8880              LDRH     r0,[r0,#4]  ; ADC_ConvertedValue
000012  4404              ADD      r4,r4,r0
;;;204    		s1 += ADC_ConvertedValue[3];
000014  482b              LDR      r0,|L6.196|
000016  88c0              LDRH     r0,[r0,#6]  ; ADC_ConvertedValue
000018  4405              ADD      r5,r5,r0
;;;205    		s2 += ADC_ConvertedValue[4];
00001a  482a              LDR      r0,|L6.196|
00001c  8900              LDRH     r0,[r0,#8]  ; ADC_ConvertedValue
00001e  4406              ADD      r6,r6,r0
;;;206    		bsp_DelayUS(100);
000020  2064              MOVS     r0,#0x64
000022  f7fffffe          BL       bsp_DelayUS
000026  f1090001          ADD      r0,r9,#1              ;201
00002a  fa1ff980          UXTH     r9,r0                 ;201
                  |L6.46|
00002e  f5b97f00          CMP      r9,#0x200             ;201
000032  dbec              BLT      |L6.14|
;;;207    	}
;;;208    	s0 = s0 >> 9;
000034  0a64              LSRS     r4,r4,#9
;;;209    	s1 = s1 >> 9;
000036  0a6d              LSRS     r5,r5,#9
;;;210    	s2 = s2 >> 9;
000038  0a76              LSRS     r6,r6,#9
;;;211    	voltage[0] = (float)s0/4096*3.3;	
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       __aeabi_ui2f
000040  f04f418b          MOV      r1,#0x45800000
000044  9000              STR      r0,[sp,#0]
000046  f7fffffe          BL       __aeabi_fdiv
00004a  9001              STR      r0,[sp,#4]
00004c  f7fffffe          BL       __aeabi_f2d
000050  4682              MOV      r10,r0
000052  f04f3266          MOV      r2,#0x66666666
000056  4b1c              LDR      r3,|L6.200|
000058  f7fffffe          BL       __aeabi_dmul
00005c  4607              MOV      r7,r0
00005e  f7fffffe          BL       __aeabi_d2f
000062  491a              LDR      r1,|L6.204|
000064  6008              STR      r0,[r1,#0]  ; voltage
;;;212    	voltage[1] = (float)s1/4096*3.3;
000066  4628              MOV      r0,r5
000068  f7fffffe          BL       __aeabi_ui2f
00006c  4683              MOV      r11,r0
00006e  f04f418b          MOV      r1,#0x45800000
000072  f7fffffe          BL       __aeabi_fdiv
000076  4682              MOV      r10,r0
000078  f7fffffe          BL       __aeabi_f2d
00007c  f04f3266          MOV      r2,#0x66666666
000080  4b11              LDR      r3,|L6.200|
000082  e9cd0100          STRD     r0,r1,[sp,#0]
000086  f7fffffe          BL       __aeabi_dmul
00008a  4607              MOV      r7,r0
00008c  f7fffffe          BL       __aeabi_d2f
000090  490e              LDR      r1,|L6.204|
000092  6048              STR      r0,[r1,#4]  ; voltage
;;;213    	voltage[2] = (float)s2/4096*3.3;	
000094  4630              MOV      r0,r6
000096  f7fffffe          BL       __aeabi_ui2f
00009a  f04f418b          MOV      r1,#0x45800000
00009e  9000              STR      r0,[sp,#0]
0000a0  f7fffffe          BL       __aeabi_fdiv
0000a4  9001              STR      r0,[sp,#4]
0000a6  f7fffffe          BL       __aeabi_f2d
0000aa  4607              MOV      r7,r0
0000ac  f04f3266          MOV      r2,#0x66666666
0000b0  4b05              LDR      r3,|L6.200|
0000b2  f7fffffe          BL       __aeabi_dmul
0000b6  4682              MOV      r10,r0
0000b8  f7fffffe          BL       __aeabi_d2f
0000bc  4903              LDR      r1,|L6.204|
0000be  6088              STR      r0,[r1,#8]  ; voltage
;;;214    }
0000c0  e8bd9ffc          POP      {r2-r12,pc}
;;;215    uint8_t send_flag = 0;
                          ENDP

                  |L6.196|
                          DCD      ADC_ConvertedValue
                  |L6.200|
                          DCD      0x400a6666
                  |L6.204|
                          DCD      voltage

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  ADC_ConvertedValue
                          %        12
                  voltage
                          %        20
                  adc_buf
                          %        2560

                          AREA ||.data||, DATA, ALIGN=2

                  i
000000  00                DCB      0x00
                  j
000001  00                DCB      0x00
                  m
000002  0000              DCB      0x00,0x00
                  adc_num1
000004  0000              DCB      0x00,0x00
                  adc_num2
000006  0000              DCB      0x00,0x00
                  adc_num3
000008  00000000          DCB      0x00,0x00,0x00,0x00
                  t
                          DCD      0x00000000
                  sum1
                          DCD      0x00000000
                  sum2
                          DCD      0x00000000
                  sum3
                          DCD      0x00000000
                  ctrl_current
00001c  0000              DCB      0x00,0x00
                  Motor_Current
00001e  0000              DCB      0x00,0x00
                  motor_voltage
000020  0000              DCB      0x00,0x00
                  Motor_Voltage
000022  0000              DCB      0x00,0x00
                  adc_initv
                          DCD      0x00000000
                  send_flag
000028  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_adc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_bsp_adc_c_937cc199____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___9_bsp_adc_c_937cc199____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_bsp_adc_c_937cc199____REVSH|
#line 128
|__asm___9_bsp_adc_c_937cc199____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\ott2001a.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\ott2001a.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\FatFS\src -I..\..\User\Mass_Storage\inc -I..\..\User\LCD_Driver -I..\..\User\SYSTEM\sys -I..\..\User\Debugprintf -I..\..\User\LogDebug -I..\..\User\app\inc -I..\..\User\app\src -I..\..\User\bsp\inc -I..\..\User\bsp\src -I.\RTE\_Flash -ID:\Keil_v5\ARM\Packs\ARM\CMSIS\5.5.1\CMSIS\Core\Include -ID:\Keil_v5\ARM\Packs\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=527 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\ott2001a.crf ..\..\User\LCD_Driver\ott2001a.c]
                          THUMB

                          AREA ||i.OTT2001A_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  OTT2001A_Init PROC
;;;76     //返回值:0,初始化成功;1,初始化失败 
;;;77     u8 OTT2001A_Init(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;78     {
;;;79      	u8 regval=0;  
000002  2000              MOVS     r0,#0
000004  9001              STR      r0,[sp,#4]
;;;80      	GPIO_InitTypeDef  GPIO_InitStructure;	
;;;81     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOF, ENABLE);	 //使能PF端口时钟
000006  2101              MOVS     r1,#1
000008  2080              MOVS     r0,#0x80
00000a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;82     
;;;83     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;				 // PF11端口配置
00000e  f44f6000          MOV      r0,#0x800
000012  f8ad0000          STRH     r0,[sp,#0]
;;;84       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; 		 //推挽输出
000016  2010              MOVS     r0,#0x10
000018  f88d0003          STRB     r0,[sp,#3]
;;;85     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00001c  2003              MOVS     r0,#3
00001e  f88d0002          STRB     r0,[sp,#2]
;;;86     	GPIO_Init(GPIOF, &GPIO_InitStructure);//PF11推挽输出
000022  4669              MOV      r1,sp
000024  481d              LDR      r0,|L1.156|
000026  f7fffffe          BL       GPIO_Init
;;;87     	GPIO_SetBits(GPIOF,GPIO_Pin_1);//上拉
00002a  2102              MOVS     r1,#2
00002c  481b              LDR      r0,|L1.156|
00002e  f7fffffe          BL       GPIO_SetBits
;;;88     		
;;;89       GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;				 // PB2端口配置
000032  f44f6080          MOV      r0,#0x400
000036  f8ad0000          STRH     r0,[sp,#0]
;;;90     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; 		 //上拉输入
00003a  2048              MOVS     r0,#0x48
00003c  f88d0003          STRB     r0,[sp,#3]
;;;91     	GPIO_Init(GPIOF, &GPIO_InitStructure);//PF10上拉输入
000040  4669              MOV      r1,sp
000042  4816              LDR      r0,|L1.156|
000044  f7fffffe          BL       GPIO_Init
;;;92     	GPIO_SetBits(GPIOF,GPIO_Pin_10);//上拉		
000048  f44f6180          MOV      r1,#0x400
00004c  4813              LDR      r0,|L1.156|
00004e  f7fffffe          BL       GPIO_SetBits
;;;93     		 						 
;;;94      
;;;95     	CT_IIC_Init();      	//初始化电容屏的I2C总线  
000052  f7fffffe          BL       CT_IIC_Init
;;;96     	OTT_RST=0;				//复位
000056  2000              MOVS     r0,#0
000058  4911              LDR      r1,|L1.160|
00005a  6008              STR      r0,[r1,#0]
;;;97     	bsp_DelayMS(100);
00005c  2064              MOVS     r0,#0x64
00005e  f7fffffe          BL       bsp_DelayMS
;;;98      	OTT_RST=1;				//释放复位		    
000062  2001              MOVS     r0,#1
000064  490f              LDR      r1,|L1.164|
000066  f8c101ac          STR      r0,[r1,#0x1ac]
;;;99     	bsp_DelayMS(100); 
00006a  2064              MOVS     r0,#0x64
00006c  f7fffffe          BL       bsp_DelayMS
;;;100    	OTT2001A_SensorControl(1);//打开传感器 
000070  2001              MOVS     r0,#1
000072  f7fffffe          BL       OTT2001A_SensorControl
;;;101    	OTT2001A_RD_Reg(OTT_CTRL_REG,&regval,1);//读取传感器运行寄存器的值来判断I2C通信是否正常
000076  2201              MOVS     r2,#1
000078  a901              ADD      r1,sp,#4
00007a  f44f6050          MOV      r0,#0xd00
00007e  f7fffffe          BL       OTT2001A_RD_Reg
;;;102    	printf("CTP ID:%x\r\n",regval);
000082  f89d1004          LDRB     r1,[sp,#4]
000086  a008              ADR      r0,|L1.168|
000088  f7fffffe          BL       __2printf
;;;103        if(regval==0x80)return 0;
00008c  f89d0004          LDRB     r0,[sp,#4]
000090  2880              CMP      r0,#0x80
000092  d101              BNE      |L1.152|
000094  2000              MOVS     r0,#0
                  |L1.150|
;;;104    	return 1;
;;;105    }
000096  bd1c              POP      {r2-r4,pc}
                  |L1.152|
000098  2001              MOVS     r0,#1                 ;104
00009a  e7fc              B        |L1.150|
;;;106    
                          ENDP

                  |L1.156|
                          DCD      0x40011c00
                  |L1.160|
                          DCD      0x422381ac
                  |L1.164|
                          DCD      0x42238000
                  |L1.168|
0000a8  43545020          DCB      "CTP ID:%x\r\n",0
0000ac  49443a25
0000b0  780d0a00

                          AREA ||i.OTT2001A_RD_Reg||, CODE, READONLY, ALIGN=1

                  OTT2001A_RD_Reg PROC
;;;47     //len:读数据长度			  
;;;48     void OTT2001A_RD_Reg(u16 reg,u8 *buf,u8 len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;49     {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
;;;50     	u8 i; 
;;;51      	CT_IIC_Start();	
00000a  f7fffffe          BL       CT_IIC_Start
;;;52      	CT_IIC_Send_Byte(OTT_CMD_WR);   //发送写命令 	 
00000e  20b2              MOVS     r0,#0xb2
000010  f7fffffe          BL       CT_IIC_Send_Byte
;;;53     	CT_IIC_Wait_Ack();
000014  f7fffffe          BL       CT_IIC_Wait_Ack
;;;54      	CT_IIC_Send_Byte(reg>>8);   	//发送高8位地址
000018  1228              ASRS     r0,r5,#8
00001a  f7fffffe          BL       CT_IIC_Send_Byte
;;;55     	CT_IIC_Wait_Ack(); 	 										  		   
00001e  f7fffffe          BL       CT_IIC_Wait_Ack
;;;56      	CT_IIC_Send_Byte(reg&0XFF);   	//发送低8位地址
000022  b2e8              UXTB     r0,r5
000024  f7fffffe          BL       CT_IIC_Send_Byte
;;;57     	CT_IIC_Wait_Ack();  
000028  f7fffffe          BL       CT_IIC_Wait_Ack
;;;58      	CT_IIC_Start();  	 	   
00002c  f7fffffe          BL       CT_IIC_Start
;;;59     	CT_IIC_Send_Byte(OTT_CMD_RD);   //发送读命令		   
000030  20b3              MOVS     r0,#0xb3
000032  f7fffffe          BL       CT_IIC_Send_Byte
;;;60     	CT_IIC_Wait_Ack();	   
000036  f7fffffe          BL       CT_IIC_Wait_Ack
;;;61     	for(i=0;i<len;i++)
00003a  2400              MOVS     r4,#0
00003c  e00b              B        |L2.86|
                  |L2.62|
;;;62     	{	   
;;;63         	buf[i]=CT_IIC_Read_Byte(i==(len-1)?0:1); //发数据	  
00003e  1e71              SUBS     r1,r6,#1
000040  42a1              CMP      r1,r4
000042  d001              BEQ      |L2.72|
000044  2101              MOVS     r1,#1
000046  e000              B        |L2.74|
                  |L2.72|
000048  2100              MOVS     r1,#0
                  |L2.74|
00004a  4608              MOV      r0,r1
00004c  f7fffffe          BL       CT_IIC_Read_Byte
000050  5538              STRB     r0,[r7,r4]
000052  1c60              ADDS     r0,r4,#1              ;61
000054  b2c4              UXTB     r4,r0                 ;61
                  |L2.86|
000056  42b4              CMP      r4,r6                 ;61
000058  dbf1              BLT      |L2.62|
;;;64     	} 
;;;65         CT_IIC_Stop();//产生一个停止条件    
00005a  f7fffffe          BL       CT_IIC_Stop
;;;66     }
00005e  e8bd81f0          POP      {r4-r8,pc}
;;;67     //传感器打开/关闭操作
                          ENDP


                          AREA ||i.OTT2001A_Scan||, CODE, READONLY, ALIGN=2

                  OTT2001A_Scan PROC
;;;111    //0,触屏无触摸;1,触屏有触摸
;;;112    u8 OTT2001A_Scan(u8 mode)
000000  e92d4ff1          PUSH     {r0,r4-r11,lr}
;;;113    {
000004  b082              SUB      sp,sp,#8
;;;114    	u8 buf[4];
;;;115    	u8 i=0;
000006  f04f0a00          MOV      r10,#0
;;;116    	u8 res=0;
00000a  46d3              MOV      r11,r10
;;;117    	static u8 t=0;//控制查询间隔,从而降低CPU占用率   
;;;118    	t++;
00000c  486c              LDR      r0,|L3.448|
00000e  7800              LDRB     r0,[r0,#0]  ; t
000010  1c40              ADDS     r0,r0,#1
000012  496b              LDR      r1,|L3.448|
000014  7008              STRB     r0,[r1,#0]
;;;119    	if((t%10)==0||t<10)//空闲时,每进入10次CTP_Scan函数才检测1次,从而节省CPU使用率
000016  4608              MOV      r0,r1
000018  7800              LDRB     r0,[r0,#0]  ; t
00001a  210a              MOVS     r1,#0xa
00001c  fb90f2f1          SDIV     r2,r0,r1
000020  fb010012          MLS      r0,r1,r2,r0
000024  b118              CBZ      r0,|L3.46|
000026  4866              LDR      r0,|L3.448|
000028  7800              LDRB     r0,[r0,#0]  ; t
00002a  280a              CMP      r0,#0xa
00002c  da7e              BGE      |L3.300|
                  |L3.46|
;;;120    	{
;;;121    		OTT2001A_RD_Reg(OTT_GSTID_REG,&mode,1);//读取触摸点的状态  
00002e  2201              MOVS     r2,#1
000030  a902              ADD      r1,sp,#8
000032  2000              MOVS     r0,#0
000034  f7fffffe          BL       OTT2001A_RD_Reg
;;;122    		if(mode&0X1F)
000038  f89d0008          LDRB     r0,[sp,#8]
00003c  f000001f          AND      r0,r0,#0x1f
000040  2800              CMP      r0,#0
000042  d073              BEQ      |L3.300|
;;;123    		{
;;;124    			tp_dev.sta=(mode&0X1F)|TP_PRES_DOWN|TP_CATH_PRES;
000044  f89d0008          LDRB     r0,[sp,#8]
000048  f000001f          AND      r0,r0,#0x1f
00004c  f04000c0          ORR      r0,r0,#0xc0
000050  495c              LDR      r1,|L3.452|
000052  f8810020          STRB     r0,[r1,#0x20]
;;;125    			for(i=0;i<5;i++)
000056  f04f0a00          MOV      r10,#0
00005a  e076              B        |L3.330|
                  |L3.92|
;;;126    			{
;;;127    				if(tp_dev.sta&(1<<i))	//触摸有效?
00005c  4859              LDR      r0,|L3.452|
00005e  f8900020          LDRB     r0,[r0,#0x20]  ; tp_dev
000062  2101              MOVS     r1,#1
000064  fa01f10a          LSL      r1,r1,r10
000068  4008              ANDS     r0,r0,r1
00006a  2800              CMP      r0,#0
00006c  d069              BEQ      |L3.322|
;;;128    				{
;;;129    					OTT2001A_RD_Reg(OTT_TPX_TBL[i],buf,4);	//读取XY坐标值
00006e  4956              LDR      r1,|L3.456|
000070  f831001a          LDRH     r0,[r1,r10,LSL #1]
000074  2204              MOVS     r2,#4
000076  a901              ADD      r1,sp,#4
000078  f7fffffe          BL       OTT2001A_RD_Reg
;;;130    					if(tp_dev.touchtype&0X01)//横屏
00007c  4851              LDR      r0,|L3.452|
00007e  f8900030          LDRB     r0,[r0,#0x30]  ; tp_dev
000082  f0000001          AND      r0,r0,#1
000086  b378              CBZ      r0,|L3.232|
;;;131    					{
;;;132    						tp_dev.y[i]=(((u16)buf[2]<<8)+buf[3])*OTT_SCAL_Y;
000088  f89d1007          LDRB     r1,[sp,#7]
00008c  f89d2006          LDRB     r2,[sp,#6]
000090  eb012002          ADD      r0,r1,r2,LSL #8
000094  f7fffffe          BL       __aeabi_i2d
000098  4606              MOV      r6,r0
00009a  4a4c              LDR      r2,|L3.460|
00009c  4b4c              LDR      r3,|L3.464|
00009e  f7fffffe          BL       __aeabi_dmul
0000a2  4604              MOV      r4,r0
0000a4  f7fffffe          BL       __aeabi_d2uiz
0000a8  b281              UXTH     r1,r0
0000aa  4846              LDR      r0,|L3.452|
0000ac  3016              ADDS     r0,r0,#0x16
0000ae  f820101a          STRH     r1,[r0,r10,LSL #1]
;;;133    						tp_dev.x[i]=800-((((u16)buf[0]<<8)+buf[1])*OTT_SCAL_X);
0000b2  f89d1005          LDRB     r1,[sp,#5]
0000b6  f89d2004          LDRB     r2,[sp,#4]
0000ba  eb012002          ADD      r0,r1,r2,LSL #8
0000be  f7fffffe          BL       __aeabi_i2d
0000c2  4606              MOV      r6,r0
0000c4  4a43              LDR      r2,|L3.468|
0000c6  4b44              LDR      r3,|L3.472|
0000c8  f7fffffe          BL       __aeabi_dmul
0000cc  4680              MOV      r8,r0
0000ce  2200              MOVS     r2,#0
0000d0  4b42              LDR      r3,|L3.476|
0000d2  f7fffffe          BL       __aeabi_drsub
0000d6  4604              MOV      r4,r0
0000d8  f7fffffe          BL       __aeabi_d2uiz
0000dc  b281              UXTH     r1,r0
0000de  4839              LDR      r0,|L3.452|
0000e0  300c              ADDS     r0,r0,#0xc
0000e2  f820101a          STRH     r1,[r0,r10,LSL #1]
0000e6  e02c              B        |L3.322|
                  |L3.232|
0000e8  e7ff              B        |L3.234|
                  |L3.234|
;;;134    					}else
;;;135    					{
;;;136    						tp_dev.x[i]=(((u16)buf[2]<<8)+buf[3])*OTT_SCAL_Y;
0000ea  f89d1007          LDRB     r1,[sp,#7]
0000ee  f89d2006          LDRB     r2,[sp,#6]
0000f2  eb012002          ADD      r0,r1,r2,LSL #8
0000f6  f7fffffe          BL       __aeabi_i2d
0000fa  4606              MOV      r6,r0
0000fc  4a33              LDR      r2,|L3.460|
0000fe  4b34              LDR      r3,|L3.464|
000100  f7fffffe          BL       __aeabi_dmul
000104  4604              MOV      r4,r0
000106  f7fffffe          BL       __aeabi_d2uiz
00010a  b281              UXTH     r1,r0
00010c  482d              LDR      r0,|L3.452|
00010e  300c              ADDS     r0,r0,#0xc
000110  f820101a          STRH     r1,[r0,r10,LSL #1]
;;;137    						tp_dev.y[i]=(((u16)buf[0]<<8)+buf[1])*OTT_SCAL_X;
000114  f89d1005          LDRB     r1,[sp,#5]
000118  f89d2004          LDRB     r2,[sp,#4]
00011c  eb012002          ADD      r0,r1,r2,LSL #8
000120  f7fffffe          BL       __aeabi_i2d
000124  4606              MOV      r6,r0
000126  4a2b              LDR      r2,|L3.468|
000128  4b2b              LDR      r3,|L3.472|
00012a  e000              B        |L3.302|
                  |L3.300|
00012c  e01d              B        |L3.362|
                  |L3.302|
00012e  f7fffffe          BL       __aeabi_dmul
000132  4604              MOV      r4,r0
000134  f7fffffe          BL       __aeabi_d2uiz
000138  b281              UXTH     r1,r0
00013a  4822              LDR      r0,|L3.452|
00013c  3016              ADDS     r0,r0,#0x16
00013e  f820101a          STRH     r1,[r0,r10,LSL #1]
                  |L3.322|
000142  f10a0001          ADD      r0,r10,#1             ;125
000146  f0000aff          AND      r10,r0,#0xff          ;125
                  |L3.330|
00014a  f1ba0f05          CMP      r10,#5                ;125
00014e  db85              BLT      |L3.92|
;;;138    					}  
;;;139    					//printf("x[%d]:%d,y[%d]:%d\r\n",i,tp_dev.x[i],i,tp_dev.y[i]);
;;;140    				}			
;;;141    			} 
;;;142    			res=1;
000150  f04f0b01          MOV      r11,#1
;;;143    			if(tp_dev.x[0]==0 && tp_dev.y[0]==0)mode=0;	//读到的数据都是0,则忽略此次数据
000154  481b              LDR      r0,|L3.452|
000156  8980              LDRH     r0,[r0,#0xc]  ; tp_dev
000158  b920              CBNZ     r0,|L3.356|
00015a  481a              LDR      r0,|L3.452|
00015c  8ac0              LDRH     r0,[r0,#0x16]  ; tp_dev
00015e  b908              CBNZ     r0,|L3.356|
000160  2000              MOVS     r0,#0
000162  9002              STR      r0,[sp,#8]
                  |L3.356|
;;;144    			t=0;		//触发一次,则会最少连续监测10次,从而提高命中率
000164  2000              MOVS     r0,#0
000166  4916              LDR      r1,|L3.448|
000168  7008              STRB     r0,[r1,#0]
                  |L3.362|
;;;145    		}
;;;146    	}
;;;147    	if((mode&0X1F)==0)//无触摸点按下
00016a  f89d0008          LDRB     r0,[sp,#8]
00016e  f000001f          AND      r0,r0,#0x1f
000172  b9d0              CBNZ     r0,|L3.426|
;;;148    	{ 
;;;149    		if(tp_dev.sta&TP_PRES_DOWN)	//之前是被按下的
000174  4813              LDR      r0,|L3.452|
000176  f8900020          LDRB     r0,[r0,#0x20]  ; tp_dev
00017a  f0000080          AND      r0,r0,#0x80
00017e  b140              CBZ      r0,|L3.402|
;;;150    		{
;;;151    			tp_dev.sta&=~(1<<7);	//标记按键松开
000180  4810              LDR      r0,|L3.452|
000182  f8900020          LDRB     r0,[r0,#0x20]  ; tp_dev
000186  f0200080          BIC      r0,r0,#0x80
00018a  490e              LDR      r1,|L3.452|
00018c  f8810020          STRB     r0,[r1,#0x20]
000190  e00b              B        |L3.426|
                  |L3.402|
;;;152    		}else						//之前就没有被按下
;;;153    		{ 
;;;154    			tp_dev.x[0]=0xffff;
000192  f64f70ff          MOV      r0,#0xffff
000196  490b              LDR      r1,|L3.452|
000198  8188              STRH     r0,[r1,#0xc]
;;;155    			tp_dev.y[0]=0xffff;
00019a  82c8              STRH     r0,[r1,#0x16]
;;;156    			tp_dev.sta&=0XE0;	//清除点有效标记	
00019c  4608              MOV      r0,r1
00019e  f8900020          LDRB     r0,[r0,#0x20]  ; tp_dev
0001a2  f00000e0          AND      r0,r0,#0xe0
0001a6  f8810020          STRB     r0,[r1,#0x20]
                  |L3.426|
;;;157    		}	 
;;;158    	} 	
;;;159    	if(t>240)t=10;//重新从10开始计数
0001aa  4805              LDR      r0,|L3.448|
0001ac  7800              LDRB     r0,[r0,#0]  ; t
0001ae  28f0              CMP      r0,#0xf0
0001b0  dd02              BLE      |L3.440|
0001b2  200a              MOVS     r0,#0xa
0001b4  4902              LDR      r1,|L3.448|
0001b6  7008              STRB     r0,[r1,#0]
                  |L3.440|
;;;160    	return res;
0001b8  4658              MOV      r0,r11
;;;161    }
0001ba  e8bd8ffe          POP      {r1-r11,pc}
;;;162     
                          ENDP

0001be  0000              DCW      0x0000
                  |L3.448|
                          DCD      t
                  |L3.452|
                          DCD      tp_dev
                  |L3.456|
                          DCD      OTT_TPX_TBL
                  |L3.460|
                          DCD      0x47ae147b
                  |L3.464|
                          DCD      0x3fd47ae1
                  |L3.468|
                          DCD      0x467381d8
                  |L3.472|
                          DCD      0x3fd2f694
                  |L3.476|
                          DCD      0x40890000

                          AREA ||i.OTT2001A_SensorControl||, CODE, READONLY, ALIGN=1

                  OTT2001A_SensorControl PROC
;;;68     //cmd:1,打开传感器;0,关闭传感器
;;;69     void OTT2001A_SensorControl(u8 cmd)
000000  b538              PUSH     {r3-r5,lr}
;;;70     {
000002  4604              MOV      r4,r0
;;;71     	u8 regval=0X00;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;72     	if(cmd)regval=0X80;
000008  b10c              CBZ      r4,|L4.14|
00000a  2080              MOVS     r0,#0x80
00000c  9000              STR      r0,[sp,#0]
                  |L4.14|
;;;73     	OTT2001A_WR_Reg(OTT_CTRL_REG,&regval,1); 
00000e  2201              MOVS     r2,#1
000010  4669              MOV      r1,sp
000012  f44f6050          MOV      r0,#0xd00
000016  f7fffffe          BL       OTT2001A_WR_Reg
;;;74     } 
00001a  bd38              POP      {r3-r5,pc}
;;;75     //初始化触摸屏
                          ENDP


                          AREA ||i.OTT2001A_WR_Reg||, CODE, READONLY, ALIGN=1

                  OTT2001A_WR_Reg PROC
;;;23     //返回值:0,成功;1,失败.
;;;24     u8 OTT2001A_WR_Reg(u16 reg,u8 *buf,u8 len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;25     {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;26     	u8 i;
;;;27     	u8 ret=0;
00000a  f04f0800          MOV      r8,#0
;;;28     	CT_IIC_Start();	
00000e  f7fffffe          BL       CT_IIC_Start
;;;29      	CT_IIC_Send_Byte(OTT_CMD_WR);   //发送写命令 	 
000012  20b2              MOVS     r0,#0xb2
000014  f7fffffe          BL       CT_IIC_Send_Byte
;;;30     	CT_IIC_Wait_Ack();
000018  f7fffffe          BL       CT_IIC_Wait_Ack
;;;31     	CT_IIC_Send_Byte(reg>>8);   	//发送高8位地址
00001c  1220              ASRS     r0,r4,#8
00001e  f7fffffe          BL       CT_IIC_Send_Byte
;;;32     	CT_IIC_Wait_Ack(); 	 										  		   
000022  f7fffffe          BL       CT_IIC_Wait_Ack
;;;33     	CT_IIC_Send_Byte(reg&0XFF);   	//发送低8位地址
000026  b2e0              UXTB     r0,r4
000028  f7fffffe          BL       CT_IIC_Send_Byte
;;;34     	CT_IIC_Wait_Ack();  
00002c  f7fffffe          BL       CT_IIC_Wait_Ack
;;;35     	for(i=0;i<len;i++)
000030  2500              MOVS     r5,#0
000032  e00b              B        |L5.76|
                  |L5.52|
;;;36     	{	   
;;;37         	CT_IIC_Send_Byte(buf[i]);  	//发数据
000034  5d70              LDRB     r0,[r6,r5]
000036  f7fffffe          BL       CT_IIC_Send_Byte
;;;38     		ret=CT_IIC_Wait_Ack();
00003a  f7fffffe          BL       CT_IIC_Wait_Ack
00003e  4680              MOV      r8,r0
;;;39     		if(ret)break;  
000040  f1b80f00          CMP      r8,#0
000044  d000              BEQ      |L5.72|
000046  e003              B        |L5.80|
                  |L5.72|
000048  1c68              ADDS     r0,r5,#1              ;35
00004a  b2c5              UXTB     r5,r0                 ;35
                  |L5.76|
00004c  42bd              CMP      r5,r7                 ;35
00004e  dbf1              BLT      |L5.52|
                  |L5.80|
000050  bf00              NOP      
;;;40     	}
;;;41         CT_IIC_Stop();					//产生一个停止条件	    
000052  f7fffffe          BL       CT_IIC_Stop
;;;42     	return ret; 
000056  4640              MOV      r0,r8
;;;43     }
000058  e8bd81f0          POP      {r4-r8,pc}
;;;44     //从OTT2001A读出一次数据
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=1

                  OTT_TPX_TBL
000000  01000500          DCW      0x0100,0x0500
000004  10001400          DCW      0x1000,0x1400
000008  1800              DCW      0x1800

                          AREA ||.data||, DATA, ALIGN=0

                  t
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\LCD_Driver\\ott2001a.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_ott2001a_c_6b0d66b2____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___10_ott2001a_c_6b0d66b2____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_ott2001a_c_6b0d66b2____REVSH|
#line 128
|__asm___10_ott2001a_c_6b0d66b2____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_uart_fifo.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_uart_fifo.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\FatFS\src -I..\..\User\Mass_Storage\inc -I..\..\User\LCD_Driver -I..\..\User\SYSTEM\sys -I..\..\User\Debugprintf -I..\..\User\LogDebug -I..\..\User\app\inc -I..\..\User\app\src -I..\..\User\bsp\inc -I..\..\User\bsp\src -I.\RTE\_Flash -ID:\Keil_v5\ARM\Packs\ARM\CMSIS\5.5.1\CMSIS\Core\Include -ID:\Keil_v5\ARM\Packs\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=527 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_uart_fifo.crf ..\..\User\bsp\src\bsp_uart_fifo.c]
                          THUMB

                          AREA ||i.ComToUart||, CODE, READONLY, ALIGN=2

                  ComToUart PROC
;;;87     */
;;;88     UART_T *ComToUart(COM_PORT_E _ucPort)
000000  4601              MOV      r1,r0
;;;89     {
;;;90     	if (_ucPort == COM1)
000002  b909              CBNZ     r1,|L1.8|
;;;91     	{
;;;92     		#if UART1_FIFO_EN == 1
;;;93     			return &g_tUart1;
000004  4809              LDR      r0,|L1.44|
                  |L1.6|
;;;94     		#else
;;;95     			return 0;
;;;96     		#endif
;;;97     	}
;;;98     	else if (_ucPort == COM2)
;;;99     	{
;;;100    		#if UART2_FIFO_EN == 1
;;;101    			return &g_tUart2;
;;;102    		#else
;;;103    			return 0;
;;;104    		#endif
;;;105    	}
;;;106    	else if (_ucPort == COM3)
;;;107    	{
;;;108    		#if UART3_FIFO_EN == 1
;;;109    			return &g_tUart3;
;;;110    		#else
;;;111    			return 0;
;;;112    		#endif
;;;113    	}
;;;114    	else if (_ucPort == COM4)
;;;115    	{
;;;116    		#if UART4_FIFO_EN == 1
;;;117    			return &g_tUart4;
;;;118    		#else
;;;119    			return 0;
;;;120    		#endif
;;;121    	}
;;;122    	else if (_ucPort == COM5)
;;;123    	{
;;;124    		#if UART5_FIFO_EN == 1
;;;125    			return &g_tUart5;
;;;126    		#else
;;;127    			return 0;
;;;128    		#endif
;;;129    	}
;;;130    	else
;;;131    	{
;;;132    		/* 不做任何处理 */
;;;133    		return 0;
;;;134    	}
;;;135    }
000006  4770              BX       lr
                  |L1.8|
000008  2901              CMP      r1,#1                 ;98
00000a  d101              BNE      |L1.16|
00000c  4808              LDR      r0,|L1.48|
00000e  e7fa              B        |L1.6|
                  |L1.16|
000010  2902              CMP      r1,#2                 ;106
000012  d101              BNE      |L1.24|
000014  4807              LDR      r0,|L1.52|
000016  e7f6              B        |L1.6|
                  |L1.24|
000018  2903              CMP      r1,#3                 ;114
00001a  d101              BNE      |L1.32|
00001c  2000              MOVS     r0,#0                 ;119
00001e  e7f2              B        |L1.6|
                  |L1.32|
000020  2904              CMP      r1,#4                 ;122
000022  d101              BNE      |L1.40|
000024  4804              LDR      r0,|L1.56|
000026  e7ee              B        |L1.6|
                  |L1.40|
000028  2000              MOVS     r0,#0                 ;133
00002a  e7ec              B        |L1.6|
;;;136    
                          ENDP

                  |L1.44|
                          DCD      g_tUart1
                  |L1.48|
                          DCD      g_tUart2
                  |L1.52|
                          DCD      g_tUart3
                  |L1.56|
                          DCD      g_tUart5

                          AREA ||i.ConfigUartNVIC||, CODE, READONLY, ALIGN=1

                  ConfigUartNVIC PROC
;;;780    */
;;;781    static void ConfigUartNVIC(void)
000000  b508              PUSH     {r3,lr}
;;;782    {
;;;783    	NVIC_InitTypeDef NVIC_InitStructure;
;;;784    
;;;785    	/* Configure the NVIC Preemption Priority Bits */
;;;786    	/*	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);  --- 在 bsp.c 中 bsp_Init() 中配置中断优先级组 */
;;;787    
;;;788    #if UART1_FIFO_EN == 1
;;;789    	/* 使能串口1中断 */
;;;790    	NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
000002  2025              MOVS     r0,#0x25
000004  f88d0000          STRB     r0,[sp,#0]
;;;791    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
000008  2001              MOVS     r0,#1
00000a  f88d0001          STRB     r0,[sp,#1]
;;;792    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
00000e  2000              MOVS     r0,#0
000010  f88d0002          STRB     r0,[sp,#2]
;;;793    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000014  2001              MOVS     r0,#1
000016  f88d0003          STRB     r0,[sp,#3]
;;;794    	NVIC_Init(&NVIC_InitStructure);
00001a  4668              MOV      r0,sp
00001c  f7fffffe          BL       NVIC_Init
;;;795    #endif
;;;796    
;;;797    #if UART2_FIFO_EN == 1
;;;798    	/* 使能串口2中断 */
;;;799    	NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;
000020  2026              MOVS     r0,#0x26
000022  f88d0000          STRB     r0,[sp,#0]
;;;800    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
000026  2001              MOVS     r0,#1
000028  f88d0001          STRB     r0,[sp,#1]
;;;801    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
00002c  2000              MOVS     r0,#0
00002e  f88d0002          STRB     r0,[sp,#2]
;;;802    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000032  2001              MOVS     r0,#1
000034  f88d0003          STRB     r0,[sp,#3]
;;;803    	NVIC_Init(&NVIC_InitStructure);
000038  4668              MOV      r0,sp
00003a  f7fffffe          BL       NVIC_Init
;;;804    #endif
;;;805    
;;;806    #if UART3_FIFO_EN == 1
;;;807    	/* 使能串口3中断t */
;;;808    	NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQn;
00003e  2027              MOVS     r0,#0x27
000040  f88d0000          STRB     r0,[sp,#0]
;;;809    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
000044  2001              MOVS     r0,#1
000046  f88d0001          STRB     r0,[sp,#1]
;;;810    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
00004a  2000              MOVS     r0,#0
00004c  f88d0002          STRB     r0,[sp,#2]
;;;811    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000050  2001              MOVS     r0,#1
000052  f88d0003          STRB     r0,[sp,#3]
;;;812    	NVIC_Init(&NVIC_InitStructure);
000056  4668              MOV      r0,sp
000058  f7fffffe          BL       NVIC_Init
;;;813    #endif
;;;814    
;;;815    #if UART4_FIFO_EN == 1
;;;816    	/* 使能串口4中断t */
;;;817    	NVIC_InitStructure.NVIC_IRQChannel = UART4_IRQn;
;;;818    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
;;;819    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
;;;820    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;821    	NVIC_Init(&NVIC_InitStructure);
;;;822    #endif
;;;823    
;;;824    #if UART5_FIFO_EN == 1
;;;825    	/* 使能串口5中断t */
;;;826    	NVIC_InitStructure.NVIC_IRQChannel = UART5_IRQn;
00005c  2035              MOVS     r0,#0x35
00005e  f88d0000          STRB     r0,[sp,#0]
;;;827    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
000062  2001              MOVS     r0,#1
000064  f88d0001          STRB     r0,[sp,#1]
;;;828    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000068  2000              MOVS     r0,#0
00006a  f88d0002          STRB     r0,[sp,#2]
;;;829    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00006e  2001              MOVS     r0,#1
000070  f88d0003          STRB     r0,[sp,#3]
;;;830    	NVIC_Init(&NVIC_InitStructure);
000074  4668              MOV      r0,sp
000076  f7fffffe          BL       NVIC_Init
;;;831    #endif
;;;832    
;;;833    #if UART6_FIFO_EN == 1
;;;834    	/* 使能串口6中断t */
;;;835    	NVIC_InitStructure.NVIC_IRQChannel = USART6_IRQn;
;;;836    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
;;;837    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
;;;838    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;839    	NVIC_Init(&NVIC_InitStructure);
;;;840    #endif
;;;841    }
00007a  bd08              POP      {r3,pc}
;;;842    
                          ENDP


                          AREA ||i.InitHardUart||, CODE, READONLY, ALIGN=2

                  InitHardUart PROC
;;;547    */
;;;548    static void InitHardUart(void)
000000  b500              PUSH     {lr}
;;;549    {
000002  b085              SUB      sp,sp,#0x14
;;;550    	GPIO_InitTypeDef GPIO_InitStructure;
;;;551    	USART_InitTypeDef USART_InitStructure;
;;;552    
;;;553    #if UART1_FIFO_EN == 1		/* 串口1 TX = PA9   RX = PA10 */
;;;554    
;;;555    	/* 第1步：打开GPIO和USART部件的时钟 */
;;;556    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);
000004  2101              MOVS     r1,#1
000006  2005              MOVS     r0,#5
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;557    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  0388              LSLS     r0,r1,#14
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;558    
;;;559    	/* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
;;;560    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
000014  f44f7000          MOV      r0,#0x200
000018  f8ad0010          STRH     r0,[sp,#0x10]
;;;561    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
00001c  2018              MOVS     r0,#0x18
00001e  f88d0013          STRB     r0,[sp,#0x13]
;;;562    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000022  2003              MOVS     r0,#3
000024  f88d0012          STRB     r0,[sp,#0x12]
;;;563    	GPIO_Init(GPIOA, &GPIO_InitStructure);
000028  a904              ADD      r1,sp,#0x10
00002a  487d              LDR      r0,|L3.544|
00002c  f7fffffe          BL       GPIO_Init
;;;564    
;;;565    	/* 第3步：将USART Rx的GPIO配置为浮空输入模式
;;;566    		由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;567    		但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;568    	*/
;;;569    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
000030  f44f6080          MOV      r0,#0x400
000034  f8ad0010          STRH     r0,[sp,#0x10]
;;;570    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000038  2004              MOVS     r0,#4
00003a  f88d0013          STRB     r0,[sp,#0x13]
;;;571    	GPIO_Init(GPIOA, &GPIO_InitStructure);
00003e  a904              ADD      r1,sp,#0x10
000040  4877              LDR      r0,|L3.544|
000042  f7fffffe          BL       GPIO_Init
;;;572    	
;;;573    	/* 第4步： 配置串口硬件参数 */
;;;574    	USART_InitStructure.USART_BaudRate = UART1_BAUD;	/* 波特率 */
000046  f44f30e1          MOV      r0,#0x1c200
00004a  9000              STR      r0,[sp,#0]
;;;575    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
00004c  2000              MOVS     r0,#0
00004e  f8ad0004          STRH     r0,[sp,#4]
;;;576    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
000052  f8ad0006          STRH     r0,[sp,#6]
;;;577    	USART_InitStructure.USART_Parity = USART_Parity_No ;
000056  f8ad0008          STRH     r0,[sp,#8]
;;;578    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
00005a  f8ad000c          STRH     r0,[sp,#0xc]
;;;579    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00005e  200c              MOVS     r0,#0xc
000060  f8ad000a          STRH     r0,[sp,#0xa]
;;;580    	USART_Init(USART1, &USART_InitStructure);
000064  4669              MOV      r1,sp
000066  486f              LDR      r0,|L3.548|
000068  f7fffffe          BL       USART_Init
;;;581    
;;;582    	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
00006c  2201              MOVS     r2,#1
00006e  f2405125          MOV      r1,#0x525
000072  486c              LDR      r0,|L3.548|
000074  f7fffffe          BL       USART_ITConfig
;;;583    	/*
;;;584    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;585    		注意: 不要在此处打开发送中断
;;;586    		发送中断使能在SendUart()函数打开
;;;587    	*/
;;;588    	USART_Cmd(USART1, ENABLE);		/* 使能串口 */
000078  2101              MOVS     r1,#1
00007a  486a              LDR      r0,|L3.548|
00007c  f7fffffe          BL       USART_Cmd
;;;589    
;;;590    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;591    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;592    	USART_ClearFlag(USART1, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
000080  2140              MOVS     r1,#0x40
000082  4868              LDR      r0,|L3.548|
000084  f7fffffe          BL       USART_ClearFlag
;;;593    #endif
;;;594    
;;;595    #if UART2_FIFO_EN == 1		/* 串口2 TX = PA2， RX = PA3  */
;;;596    	/* 第1步：打开GPIO和USART部件的时钟 */
;;;597    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);
000088  2101              MOVS     r1,#1
00008a  2005              MOVS     r0,#5
00008c  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;598    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
000090  2101              MOVS     r1,#1
000092  0448              LSLS     r0,r1,#17
000094  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;599    	//GPIO_PinRemapConfig(GPIO_Remap_USART2,ENABLE);			/* 重映射要在时钟使能之后 */
;;;600    
;;;601    	/* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
;;;602    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
000098  2004              MOVS     r0,#4
00009a  f8ad0010          STRH     r0,[sp,#0x10]
;;;603    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
00009e  2018              MOVS     r0,#0x18
0000a0  f88d0013          STRB     r0,[sp,#0x13]
;;;604    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
0000a4  2003              MOVS     r0,#3
0000a6  f88d0012          STRB     r0,[sp,#0x12]
;;;605    	GPIO_Init(GPIOA, &GPIO_InitStructure);
0000aa  a904              ADD      r1,sp,#0x10
0000ac  485c              LDR      r0,|L3.544|
0000ae  f7fffffe          BL       GPIO_Init
;;;606    
;;;607    	/* 第3步：将USART Rx的GPIO配置为浮空输入模式
;;;608    		由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;609    		但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;610    	*/
;;;611    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
0000b2  2008              MOVS     r0,#8
0000b4  f8ad0010          STRH     r0,[sp,#0x10]
;;;612    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
0000b8  2004              MOVS     r0,#4
0000ba  f88d0013          STRB     r0,[sp,#0x13]
;;;613    	GPIO_Init(GPIOA, &GPIO_InitStructure);
0000be  a904              ADD      r1,sp,#0x10
0000c0  4857              LDR      r0,|L3.544|
0000c2  f7fffffe          BL       GPIO_Init
;;;614    	/*  第3步已经做了，因此这步可以不做
;;;615    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;616    	*/
;;;617    //	GPIO_Init(GPIOD, &GPIO_InitStructure);
;;;618    
;;;619    	/* 第4步： 配置串口硬件参数 */
;;;620    	USART_InitStructure.USART_BaudRate = UART2_BAUD;	/* 波特率 */
0000c6  f44f5016          MOV      r0,#0x2580
0000ca  9000              STR      r0,[sp,#0]
;;;621    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
0000cc  2000              MOVS     r0,#0
0000ce  f8ad0004          STRH     r0,[sp,#4]
;;;622    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
0000d2  f8ad0006          STRH     r0,[sp,#6]
;;;623    	USART_InitStructure.USART_Parity = USART_Parity_No;
0000d6  f8ad0008          STRH     r0,[sp,#8]
;;;624    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
0000da  f8ad000c          STRH     r0,[sp,#0xc]
;;;625    	USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;		/* 仅选择接收模式 */
0000de  200c              MOVS     r0,#0xc
0000e0  f8ad000a          STRH     r0,[sp,#0xa]
;;;626    	USART_Init(USART2, &USART_InitStructure);
0000e4  4669              MOV      r1,sp
0000e6  4850              LDR      r0,|L3.552|
0000e8  f7fffffe          BL       USART_Init
;;;627    
;;;628    	USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
0000ec  2201              MOVS     r2,#1
0000ee  f2405125          MOV      r1,#0x525
0000f2  484d              LDR      r0,|L3.552|
0000f4  f7fffffe          BL       USART_ITConfig
;;;629    	/*
;;;630    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;631    		注意: 不要在此处打开发送中断
;;;632    		发送中断使能在SendUart()函数打开
;;;633    	*/
;;;634    	USART_Cmd(USART2, ENABLE);		/* 使能串口 */
0000f8  2101              MOVS     r1,#1
0000fa  484b              LDR      r0,|L3.552|
0000fc  f7fffffe          BL       USART_Cmd
;;;635    
;;;636    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;637    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;638    	USART_ClearFlag(USART2, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
000100  2140              MOVS     r1,#0x40
000102  4849              LDR      r0,|L3.552|
000104  f7fffffe          BL       USART_ClearFlag
;;;639    #endif
;;;640    
;;;641    #if UART3_FIFO_EN == 1			/* 串口3 TX = PD8   RX = PD9 */
;;;642    
;;;643    	
;;;644    
;;;645    	/* 第1步： 开启GPIO和UART时钟 */
;;;646    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD | RCC_APB2Periph_AFIO, ENABLE);
000108  2101              MOVS     r1,#1
00010a  2021              MOVS     r0,#0x21
00010c  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;647    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
000110  2101              MOVS     r1,#1
000112  0488              LSLS     r0,r1,#18
000114  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;648    	GPIO_PinRemapConfig(GPIO_FullRemap_USART3,ENABLE);
000118  2101              MOVS     r1,#1
00011a  4844              LDR      r0,|L3.556|
00011c  f7fffffe          BL       GPIO_PinRemapConfig
;;;649    	/* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
;;;650    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;
000120  f44f7080          MOV      r0,#0x100
000124  f8ad0010          STRH     r0,[sp,#0x10]
;;;651    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
000128  2018              MOVS     r0,#0x18
00012a  f88d0013          STRB     r0,[sp,#0x13]
;;;652    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00012e  2003              MOVS     r0,#3
000130  f88d0012          STRB     r0,[sp,#0x12]
;;;653    	GPIO_Init(GPIOD, &GPIO_InitStructure);
000134  a904              ADD      r1,sp,#0x10
000136  483e              LDR      r0,|L3.560|
000138  f7fffffe          BL       GPIO_Init
;;;654    
;;;655    	/* 第3步：将USART Rx的GPIO配置为浮空输入模式
;;;656    		由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;657    		但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;658    	*/
;;;659    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
00013c  f44f7000          MOV      r0,#0x200
000140  f8ad0010          STRH     r0,[sp,#0x10]
;;;660    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000144  2004              MOVS     r0,#4
000146  f88d0013          STRB     r0,[sp,#0x13]
;;;661    	GPIO_Init(GPIOD, &GPIO_InitStructure);
00014a  a904              ADD      r1,sp,#0x10
00014c  4838              LDR      r0,|L3.560|
00014e  f7fffffe          BL       GPIO_Init
;;;662    	/*  第3步已经做了，因此这步可以不做
;;;663    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;664    	*/
;;;665    	GPIO_Init(GPIOD, &GPIO_InitStructure);
000152  a904              ADD      r1,sp,#0x10
000154  4836              LDR      r0,|L3.560|
000156  f7fffffe          BL       GPIO_Init
;;;666    
;;;667    	/* 第4步： 配置串口硬件参数 */
;;;668    	USART_InitStructure.USART_BaudRate = UART3_BAUD;	/* 波特率 */
00015a  f44f30e1          MOV      r0,#0x1c200
00015e  9000              STR      r0,[sp,#0]
;;;669    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000160  2000              MOVS     r0,#0
000162  f8ad0004          STRH     r0,[sp,#4]
;;;670    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
000166  f8ad0006          STRH     r0,[sp,#6]
;;;671    	USART_InitStructure.USART_Parity = USART_Parity_No ;
00016a  f8ad0008          STRH     r0,[sp,#8]
;;;672    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
00016e  f8ad000c          STRH     r0,[sp,#0xc]
;;;673    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000172  200c              MOVS     r0,#0xc
000174  f8ad000a          STRH     r0,[sp,#0xa]
;;;674    	USART_Init(USART3, &USART_InitStructure);
000178  4669              MOV      r1,sp
00017a  482e              LDR      r0,|L3.564|
00017c  f7fffffe          BL       USART_Init
;;;675    
;;;676    	USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
000180  2201              MOVS     r2,#1
000182  f2405125          MOV      r1,#0x525
000186  482b              LDR      r0,|L3.564|
000188  f7fffffe          BL       USART_ITConfig
;;;677    	/*
;;;678    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;679    		注意: 不要在此处打开发送中断
;;;680    		发送中断使能在SendUart()函数打开
;;;681    	*/
;;;682    	USART_Cmd(USART3, ENABLE);		/* 使能串口 */
00018c  2101              MOVS     r1,#1
00018e  4829              LDR      r0,|L3.564|
000190  f7fffffe          BL       USART_Cmd
;;;683    
;;;684    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;685    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;686    	USART_ClearFlag(USART3, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
000194  2140              MOVS     r1,#0x40
000196  4827              LDR      r0,|L3.564|
000198  f7fffffe          BL       USART_ClearFlag
;;;687    #endif
;;;688    
;;;689    #if UART4_FIFO_EN == 1			/* 串口4 TX = PC10   RX = PC11 */
;;;690    	/* 第1步： 开启GPIO和UART时钟 */
;;;691    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC | RCC_APB2Periph_AFIO, ENABLE);
;;;692    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4, ENABLE);
;;;693    
;;;694    	/* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
;;;695    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
;;;696    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
;;;697    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;698    	GPIO_Init(GPIOC, &GPIO_InitStructure);
;;;699    
;;;700    	/* 第3步：将USART Rx的GPIO配置为浮空输入模式
;;;701    		由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;702    		但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;703    	*/
;;;704    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
;;;705    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
;;;706    	GPIO_Init(GPIOC, &GPIO_InitStructure);
;;;707    
;;;708    	/* 第4步： 配置串口硬件参数 */
;;;709    	USART_InitStructure.USART_BaudRate = UART4_BAUD;	/* 波特率 */
;;;710    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
;;;711    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;712    	USART_InitStructure.USART_Parity = USART_Parity_No ;
;;;713    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
;;;714    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
;;;715    	USART_Init(UART4, &USART_InitStructure);
;;;716    
;;;717    	USART_ITConfig(UART4, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
;;;718    	/*
;;;719    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;720    		注意: 不要在此处打开发送中断
;;;721    		发送中断使能在SendUart()函数打开
;;;722    	*/
;;;723    	USART_Cmd(UART4, ENABLE);		/* 使能串口 */
;;;724    
;;;725    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;726    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;727    	USART_ClearFlag(UART4, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
;;;728    #endif
;;;729    
;;;730    #if UART5_FIFO_EN == 1			/* 串口5 TX = PC12   RX = PD2 */
;;;731    	/* 第1步： 开启GPIO和UART时钟 */
;;;732    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC | RCC_APB2Periph_GPIOD | RCC_APB2Periph_AFIO, ENABLE);
00019c  2101              MOVS     r1,#1
00019e  2031              MOVS     r0,#0x31
0001a0  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;733    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART5, ENABLE);
0001a4  2101              MOVS     r1,#1
0001a6  0508              LSLS     r0,r1,#20
0001a8  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;734    
;;;735    	/* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
;;;736    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
0001ac  f44f5080          MOV      r0,#0x1000
0001b0  f8ad0010          STRH     r0,[sp,#0x10]
;;;737    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
0001b4  2018              MOVS     r0,#0x18
0001b6  f88d0013          STRB     r0,[sp,#0x13]
;;;738    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
0001ba  2003              MOVS     r0,#3
0001bc  f88d0012          STRB     r0,[sp,#0x12]
;;;739    	GPIO_Init(GPIOC, &GPIO_InitStructure);
0001c0  a904              ADD      r1,sp,#0x10
0001c2  481d              LDR      r0,|L3.568|
0001c4  f7fffffe          BL       GPIO_Init
;;;740    
;;;741    	/* 第3步：将USART Rx的GPIO配置为浮空输入模式
;;;742    		由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;743    		但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;744    	*/
;;;745    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
0001c8  2004              MOVS     r0,#4
0001ca  f8ad0010          STRH     r0,[sp,#0x10]
;;;746    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
0001ce  f88d0013          STRB     r0,[sp,#0x13]
;;;747    	GPIO_Init(GPIOD, &GPIO_InitStructure);
0001d2  a904              ADD      r1,sp,#0x10
0001d4  4816              LDR      r0,|L3.560|
0001d6  f7fffffe          BL       GPIO_Init
;;;748    
;;;749    
;;;750    	/* 第4步： 配置串口硬件参数 */
;;;751    	USART_InitStructure.USART_BaudRate = UART5_BAUD;	/* 波特率 */
0001da  f44f4096          MOV      r0,#0x4b00
0001de  9000              STR      r0,[sp,#0]
;;;752    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
0001e0  2000              MOVS     r0,#0
0001e2  f8ad0004          STRH     r0,[sp,#4]
;;;753    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
0001e6  f8ad0006          STRH     r0,[sp,#6]
;;;754    	USART_InitStructure.USART_Parity = USART_Parity_No ;
0001ea  f8ad0008          STRH     r0,[sp,#8]
;;;755    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
0001ee  f8ad000c          STRH     r0,[sp,#0xc]
;;;756    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
0001f2  200c              MOVS     r0,#0xc
0001f4  f8ad000a          STRH     r0,[sp,#0xa]
;;;757    	USART_Init(UART5, &USART_InitStructure);
0001f8  4669              MOV      r1,sp
0001fa  4810              LDR      r0,|L3.572|
0001fc  f7fffffe          BL       USART_Init
;;;758    
;;;759    	USART_ITConfig(UART5, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
000200  2201              MOVS     r2,#1
000202  f2405125          MOV      r1,#0x525
000206  480d              LDR      r0,|L3.572|
000208  f7fffffe          BL       USART_ITConfig
;;;760    	/*
;;;761    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;762    		注意: 不要在此处打开发送中断
;;;763    		发送中断使能在SendUart()函数打开
;;;764    	*/
;;;765    	USART_Cmd(UART5, ENABLE);		/* 使能串口 */
00020c  2101              MOVS     r1,#1
00020e  480b              LDR      r0,|L3.572|
000210  f7fffffe          BL       USART_Cmd
;;;766    
;;;767    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;768    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;769    	USART_ClearFlag(UART5, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
000214  2140              MOVS     r1,#0x40
000216  4809              LDR      r0,|L3.572|
000218  f7fffffe          BL       USART_ClearFlag
;;;770    #endif
;;;771    }
00021c  b005              ADD      sp,sp,#0x14
00021e  bd00              POP      {pc}
;;;772    
                          ENDP

                  |L3.544|
                          DCD      0x40010800
                  |L3.548|
                          DCD      0x40013800
                  |L3.552|
                          DCD      0x40004400
                  |L3.556|
                          DCD      0x00140030
                  |L3.560|
                          DCD      0x40011400
                  |L3.564|
                          DCD      0x40004800
                  |L3.568|
                          DCD      0x40011000
                  |L3.572|
                          DCD      0x40005000

                          AREA ||i.RS485_InitTXE||, CODE, READONLY, ALIGN=2

                  RS485_InitTXE PROC
;;;338    */
;;;339    void RS485_InitTXE(void)
000000  b508              PUSH     {r3,lr}
;;;340    {
;;;341    	GPIO_InitTypeDef GPIO_InitStructure;
;;;342    
;;;343    	RCC_APB2PeriphClockCmd(RCC_RS485_TXEN, ENABLE);	/* 打开GPIO时钟 */
000002  2101              MOVS     r1,#1
000004  2004              MOVS     r0,#4
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;344    
;;;345    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00000a  2003              MOVS     r0,#3
00000c  f88d0002          STRB     r0,[sp,#2]
;;;346    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;	/* 推挽输出模式 */
000010  2010              MOVS     r0,#0x10
000012  f88d0003          STRB     r0,[sp,#3]
;;;347    	GPIO_InitStructure.GPIO_Pin = PIN_RS485_TXEN;
000016  2002              MOVS     r0,#2
000018  f8ad0000          STRH     r0,[sp,#0]
;;;348    	GPIO_Init(PORT_RS485_TXEN, &GPIO_InitStructure);
00001c  4669              MOV      r1,sp
00001e  4802              LDR      r0,|L4.40|
000020  f7fffffe          BL       GPIO_Init
;;;349    }
000024  bd08              POP      {r3,pc}
;;;350    
                          ENDP

000026  0000              DCW      0x0000
                  |L4.40|
                          DCD      0x40010800

                          AREA ||i.RS485_ReciveNew||, CODE, READONLY, ALIGN=1

                  RS485_ReciveNew PROC
;;;438    extern void MODBUS_ReciveNew(uint8_t _byte);
;;;439    void RS485_ReciveNew(uint8_t _byte)
000000  4770              BX       lr
;;;440    {
;;;441    	//MODBUS_ReciveNew(_byte);
;;;442    }
;;;443    
                          ENDP


                          AREA ||i.RS485_SendBefor||, CODE, READONLY, ALIGN=2

                  RS485_SendBefor PROC
;;;381    */
;;;382    void RS485_SendBefor(void)
000000  2002              MOVS     r0,#2
;;;383    {
;;;384    	RS485_TX_EN();	/* 切换RS485收发芯片为发送模式 */
000002  4901              LDR      r1,|L6.8|
000004  6008              STR      r0,[r1,#0]
;;;385    }
000006  4770              BX       lr
;;;386    
                          ENDP

                  |L6.8|
                          DCD      0x40010810

                          AREA ||i.RS485_SendBuf||, CODE, READONLY, ALIGN=1

                  RS485_SendBuf PROC
;;;409    */
;;;410    void RS485_SendBuf(uint8_t *_ucaBuf, uint16_t _usLen)
000000  b570              PUSH     {r4-r6,lr}
;;;411    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;412    	comSendBuf(COM2, _ucaBuf, _usLen);
000006  462a              MOV      r2,r5
000008  4621              MOV      r1,r4
00000a  2001              MOVS     r0,#1
00000c  f7fffffe          BL       comSendBuf
;;;413    }
000010  bd70              POP      {r4-r6,pc}
;;;414    
                          ENDP


                          AREA ||i.RS485_SendOver||, CODE, READONLY, ALIGN=2

                  RS485_SendOver PROC
;;;395    */
;;;396    void RS485_SendOver(void)
000000  2002              MOVS     r0,#2
;;;397    {
;;;398    	RS485_RX_EN();	/* 切换RS485收发芯片为接收模式 */
000002  4901              LDR      r1,|L8.8|
000004  6008              STR      r0,[r1,#0]
;;;399    }
000006  4770              BX       lr
;;;400    
                          ENDP

                  |L8.8|
                          DCD      0x40010814

                          AREA ||i.RS485_SendStr||, CODE, READONLY, ALIGN=1

                  RS485_SendStr PROC
;;;424    */
;;;425    void RS485_SendStr(char *_pBuf)
000000  b570              PUSH     {r4-r6,lr}
;;;426    {
000002  4604              MOV      r4,r0
;;;427    	RS485_SendBuf((uint8_t *)_pBuf, strlen(_pBuf));
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       strlen
00000a  b285              UXTH     r5,r0
00000c  4629              MOV      r1,r5
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       RS485_SendBuf
;;;428    }
000014  bd70              POP      {r4-r6,pc}
;;;429    
                          ENDP


                          AREA ||i.UART5_IRQHandler||, CODE, READONLY, ALIGN=2

                  UART5_IRQHandler PROC
;;;1089   #if UART5_FIFO_EN == 1
;;;1090   void UART5_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;1091   {
;;;1092   	UartIRQ(&g_tUart5);
000002  4802              LDR      r0,|L10.12|
000004  f7fffffe          BL       UartIRQ
;;;1093   }
000008  bd10              POP      {r4,pc}
;;;1094   #endif
                          ENDP

00000a  0000              DCW      0x0000
                  |L10.12|
                          DCD      g_tUart5

                          AREA ||i.USART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART1_IRQHandler PROC
;;;1061   #if UART1_FIFO_EN == 1
;;;1062   void USART1_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;1063   {
;;;1064   	UartIRQ(&g_tUart1);
000002  4802              LDR      r0,|L11.12|
000004  f7fffffe          BL       UartIRQ
;;;1065   }
000008  bd10              POP      {r4,pc}
;;;1066   #endif
                          ENDP

00000a  0000              DCW      0x0000
                  |L11.12|
                          DCD      g_tUart1

                          AREA ||i.USART2_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART2_IRQHandler PROC
;;;1068   #if UART2_FIFO_EN == 1
;;;1069   void USART2_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;1070   {
;;;1071   	UartIRQ(&g_tUart2);
000002  4802              LDR      r0,|L12.12|
000004  f7fffffe          BL       UartIRQ
;;;1072   }
000008  bd10              POP      {r4,pc}
;;;1073   #endif
                          ENDP

00000a  0000              DCW      0x0000
                  |L12.12|
                          DCD      g_tUart2

                          AREA ||i.USART3_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART3_IRQHandler PROC
;;;1075   #if UART3_FIFO_EN == 1
;;;1076   void USART3_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;1077   {
;;;1078   	UartIRQ(&g_tUart3);
000002  4802              LDR      r0,|L13.12|
000004  f7fffffe          BL       UartIRQ
;;;1079   }
000008  bd10              POP      {r4,pc}
;;;1080   #endif
                          ENDP

00000a  0000              DCW      0x0000
                  |L13.12|
                          DCD      g_tUart3

                          AREA ||i.UartGetChar||, CODE, READONLY, ALIGN=1

                  UartGetChar PROC
;;;929    */
;;;930    static uint8_t UartGetChar(UART_T *_pUart, uint8_t *_pByte)
000000  b570              PUSH     {r4-r6,lr}
;;;931    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;932    	uint16_t usCount;
;;;933    
;;;934    	/* usRxWrite 变量在中断函数中被改写，主程序读取该变量时，必须进行临界区保护 */
;;;935    	DISABLE_INT();                            //若不关中断，数据还会进入，防止计数错误
000006  2001              MOVS     r0,#1
000008  f7fffffe          BL       __set_PRIMASK
;;;936    	usCount = _pUart->usRxCount;              //结构体指针
00000c  8b66              LDRH     r6,[r4,#0x1a]
;;;937    	ENABLE_INT();
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       __set_PRIMASK
;;;938    
;;;939    	/* 如果读和写索引相同，则返回0 */
;;;940    	//if (_pUart->usRxRead == usRxWrite)
;;;941    	if (usCount == 0)	/* 已经没有数据 */
000014  b90e              CBNZ     r6,|L14.26|
;;;942    	{
;;;943    		return 0;
000016  2000              MOVS     r0,#0
                  |L14.24|
;;;944    	}
;;;945    	else
;;;946    	{
;;;947    		*_pByte = _pUart->pRxBuf[_pUart->usRxRead];		/* 从串口接收FIFO取1个数据 */
;;;948    
;;;949    		/* 改写FIFO读索引 */
;;;950    		DISABLE_INT();
;;;951    		if (++_pUart->usRxRead >= _pUart->usRxBufSize)
;;;952    		{
;;;953    			_pUart->usRxRead = 0;
;;;954    		}
;;;955    		_pUart->usRxCount--;   // 每读取一个数据，都要减一
;;;956    		ENABLE_INT();
;;;957    		return 1;
;;;958    	}
;;;959    }
000018  bd70              POP      {r4-r6,pc}
                  |L14.26|
00001a  8b21              LDRH     r1,[r4,#0x18]         ;947
00001c  68a0              LDR      r0,[r4,#8]            ;947
00001e  5c40              LDRB     r0,[r0,r1]            ;947
000020  7028              STRB     r0,[r5,#0]            ;947
000022  2001              MOVS     r0,#1                 ;950
000024  f7fffffe          BL       __set_PRIMASK
000028  8b20              LDRH     r0,[r4,#0x18]         ;951
00002a  1c40              ADDS     r0,r0,#1              ;951
00002c  b280              UXTH     r0,r0                 ;951
00002e  8320              STRH     r0,[r4,#0x18]         ;951
000030  89e1              LDRH     r1,[r4,#0xe]          ;951
000032  4288              CMP      r0,r1                 ;951
000034  db01              BLT      |L14.58|
000036  2000              MOVS     r0,#0                 ;953
000038  8320              STRH     r0,[r4,#0x18]         ;953
                  |L14.58|
00003a  8b60              LDRH     r0,[r4,#0x1a]         ;955
00003c  1e40              SUBS     r0,r0,#1              ;955
00003e  8360              STRH     r0,[r4,#0x1a]         ;955
000040  2000              MOVS     r0,#0                 ;956
000042  f7fffffe          BL       __set_PRIMASK
000046  2001              MOVS     r0,#1                 ;957
000048  e7e6              B        |L14.24|
;;;960    
                          ENDP


                          AREA ||i.UartIRQ||, CODE, READONLY, ALIGN=1

                  UartIRQ PROC
;;;968    */
;;;969    static void UartIRQ(UART_T *_pUart)
000000  b570              PUSH     {r4-r6,lr}
;;;970    {
000002  4604              MOV      r4,r0
;;;971    	/* 处理接收中断  */
;;;972    	if (USART_GetITStatus(_pUart->uart, USART_IT_RXNE) != RESET)
000004  f2405125          MOV      r1,#0x525
000008  6820              LDR      r0,[r4,#0]
00000a  f7fffffe          BL       USART_GetITStatus
00000e  b1e0              CBZ      r0,|L15.74|
;;;973    	{
;;;974    		/* 从串口接收数据寄存器读取数据存放到接收FIFO */
;;;975    		uint8_t ch;
;;;976    
;;;977    		ch = USART_ReceiveData(_pUart->uart);
000010  6820              LDR      r0,[r4,#0]
000012  f7fffffe          BL       USART_ReceiveData
000016  b2c5              UXTB     r5,r0
;;;978    		_pUart->pRxBuf[_pUart->usRxWrite] = ch;
000018  8ae1              LDRH     r1,[r4,#0x16]
00001a  68a0              LDR      r0,[r4,#8]
00001c  5445              STRB     r5,[r0,r1]
;;;979    		if (++_pUart->usRxWrite >= _pUart->usRxBufSize)
00001e  8ae0              LDRH     r0,[r4,#0x16]
000020  1c40              ADDS     r0,r0,#1
000022  b280              UXTH     r0,r0
000024  82e0              STRH     r0,[r4,#0x16]
000026  89e1              LDRH     r1,[r4,#0xe]
000028  4288              CMP      r0,r1
00002a  db01              BLT      |L15.48|
;;;980    		{
;;;981    			_pUart->usRxWrite = 0;
00002c  2000              MOVS     r0,#0
00002e  82e0              STRH     r0,[r4,#0x16]
                  |L15.48|
;;;982    		}
;;;983    		if (_pUart->usRxCount < _pUart->usRxBufSize)
000030  8b60              LDRH     r0,[r4,#0x1a]
000032  89e1              LDRH     r1,[r4,#0xe]
000034  4288              CMP      r0,r1
000036  da02              BGE      |L15.62|
;;;984    		{
;;;985    			_pUart->usRxCount++;
000038  8b60              LDRH     r0,[r4,#0x1a]
00003a  1c40              ADDS     r0,r0,#1
00003c  8360              STRH     r0,[r4,#0x1a]
                  |L15.62|
;;;986    		}
;;;987    
;;;988    		/* 回调函数,通知应用程序收到新数据,一般是发送1个消息或者设置一个标记 */
;;;989    		//if (_pUart->usRxWrite == _pUart->usRxRead)
;;;990    		//if (_pUart->usRxCount == 1)
;;;991    		{
;;;992    			if (_pUart->ReciveNew)
00003e  6a60              LDR      r0,[r4,#0x24]
000040  b110              CBZ      r0,|L15.72|
;;;993    			{
;;;994    				_pUart->ReciveNew(ch);
000042  4628              MOV      r0,r5
000044  6a61              LDR      r1,[r4,#0x24]
000046  4788              BLX      r1
                  |L15.72|
;;;995    			}
;;;996    		}
;;;997    	}
000048  bf00              NOP      
                  |L15.74|
;;;998    
;;;999    	/* 处理发送缓冲区空中断 */
;;;1000   	if (USART_GetITStatus(_pUart->uart, USART_IT_TXE) != RESET)
00004a  f2407127          MOV      r1,#0x727
00004e  6820              LDR      r0,[r4,#0]
000050  f7fffffe          BL       USART_GetITStatus
000054  b308              CBZ      r0,|L15.154|
;;;1001   	{
;;;1002   		//if (_pUart->usTxRead == _pUart->usTxWrite)
;;;1003   		if (_pUart->usTxCount == 0)
000056  8aa0              LDRH     r0,[r4,#0x14]
000058  b960              CBNZ     r0,|L15.116|
;;;1004   		{
;;;1005   			/* 发送缓冲区的数据已取完时， 禁止发送缓冲区空中断 （注意：此时最后1个数据还未真正发送完毕）*/
;;;1006   			USART_ITConfig(_pUart->uart, USART_IT_TXE, DISABLE);
00005a  2200              MOVS     r2,#0
00005c  f2407127          MOV      r1,#0x727
000060  6820              LDR      r0,[r4,#0]
000062  f7fffffe          BL       USART_ITConfig
;;;1007   
;;;1008   			/* 使能数据发送完毕中断 */
;;;1009   			USART_ITConfig(_pUart->uart, USART_IT_TC, ENABLE);
000066  2201              MOVS     r2,#1
000068  f2406126          MOV      r1,#0x626
00006c  6820              LDR      r0,[r4,#0]
00006e  f7fffffe          BL       USART_ITConfig
000072  e037              B        |L15.228|
                  |L15.116|
;;;1010   		}
;;;1011   		else
;;;1012   		{
;;;1013   			/* 从发送FIFO取1个字节写入串口发送数据寄存器 */
;;;1014   			USART_SendData(_pUart->uart, _pUart->pTxBuf[_pUart->usTxRead]);
000074  8a63              LDRH     r3,[r4,#0x12]
000076  6862              LDR      r2,[r4,#4]
000078  5cd1              LDRB     r1,[r2,r3]
00007a  6820              LDR      r0,[r4,#0]
00007c  f7fffffe          BL       USART_SendData
;;;1015   			if (++_pUart->usTxRead >= _pUart->usTxBufSize)
000080  8a60              LDRH     r0,[r4,#0x12]
000082  1c40              ADDS     r0,r0,#1
000084  b280              UXTH     r0,r0
000086  8260              STRH     r0,[r4,#0x12]
000088  89a1              LDRH     r1,[r4,#0xc]
00008a  4288              CMP      r0,r1
00008c  db01              BLT      |L15.146|
;;;1016   			{
;;;1017   				_pUart->usTxRead = 0;
00008e  2000              MOVS     r0,#0
000090  8260              STRH     r0,[r4,#0x12]
                  |L15.146|
;;;1018   			}
;;;1019   			_pUart->usTxCount--;
000092  8aa0              LDRH     r0,[r4,#0x14]
000094  1e40              SUBS     r0,r0,#1
000096  82a0              STRH     r0,[r4,#0x14]
000098  e024              B        |L15.228|
                  |L15.154|
;;;1020   		}
;;;1021   
;;;1022   	}
;;;1023   	/* 数据bit位全部发送完毕的中断 */
;;;1024   	else if (USART_GetITStatus(_pUart->uart, USART_IT_TC) != RESET)
00009a  f2406126          MOV      r1,#0x626
00009e  6820              LDR      r0,[r4,#0]
0000a0  f7fffffe          BL       USART_GetITStatus
0000a4  b1f0              CBZ      r0,|L15.228|
;;;1025   	{
;;;1026   		//if (_pUart->usTxRead == _pUart->usTxWrite)
;;;1027   		if (_pUart->usTxCount == 0)
0000a6  8aa0              LDRH     r0,[r4,#0x14]
0000a8  b950              CBNZ     r0,|L15.192|
;;;1028   		{
;;;1029   			/* 如果发送FIFO的数据全部发送完毕，禁止数据发送完毕中断 */
;;;1030   			USART_ITConfig(_pUart->uart, USART_IT_TC, DISABLE);
0000aa  2200              MOVS     r2,#0
0000ac  f2406126          MOV      r1,#0x626
0000b0  6820              LDR      r0,[r4,#0]
0000b2  f7fffffe          BL       USART_ITConfig
;;;1031   
;;;1032   			/* 回调函数, 一般用来处理RS485通信，将RS485芯片设置为接收模式，避免抢占总线 */
;;;1033   			if (_pUart->SendOver)
0000b6  6a20              LDR      r0,[r4,#0x20]
0000b8  b1a0              CBZ      r0,|L15.228|
;;;1034   			{
;;;1035   				_pUart->SendOver();
0000ba  6a20              LDR      r0,[r4,#0x20]
0000bc  4780              BLX      r0
0000be  e011              B        |L15.228|
                  |L15.192|
;;;1036   			}
;;;1037   		}
;;;1038   		else
;;;1039   		{
;;;1040   			/* 正常情况下，不会进入此分支 */
;;;1041   
;;;1042   			/* 如果发送FIFO的数据还未完毕，则从发送FIFO取1个数据写入发送数据寄存器 */
;;;1043   			USART_SendData(_pUart->uart, _pUart->pTxBuf[_pUart->usTxRead]);
0000c0  8a63              LDRH     r3,[r4,#0x12]
0000c2  6862              LDR      r2,[r4,#4]
0000c4  5cd1              LDRB     r1,[r2,r3]
0000c6  6820              LDR      r0,[r4,#0]
0000c8  f7fffffe          BL       USART_SendData
;;;1044   			if (++_pUart->usTxRead >= _pUart->usTxBufSize)
0000cc  8a60              LDRH     r0,[r4,#0x12]
0000ce  1c40              ADDS     r0,r0,#1
0000d0  b280              UXTH     r0,r0
0000d2  8260              STRH     r0,[r4,#0x12]
0000d4  89a1              LDRH     r1,[r4,#0xc]
0000d6  4288              CMP      r0,r1
0000d8  db01              BLT      |L15.222|
;;;1045   			{
;;;1046   				_pUart->usTxRead = 0;
0000da  2000              MOVS     r0,#0
0000dc  8260              STRH     r0,[r4,#0x12]
                  |L15.222|
;;;1047   			}
;;;1048   			_pUart->usTxCount--;
0000de  8aa0              LDRH     r0,[r4,#0x14]
0000e0  1e40              SUBS     r0,r0,#1
0000e2  82a0              STRH     r0,[r4,#0x14]
                  |L15.228|
;;;1049   		}
;;;1050   	}
;;;1051   }
0000e4  bd70              POP      {r4-r6,pc}
;;;1052   
                          ENDP


                          AREA ||i.UartSend||, CODE, READONLY, ALIGN=1

                  UartSend PROC
;;;850    */
;;;851    static void UartSend(UART_T *_pUart, uint8_t *_ucaBuf, uint16_t _usLen)
000000  b5f8              PUSH     {r3-r7,lr}
;;;852    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4617              MOV      r7,r2
;;;853    	uint16_t i;
;;;854    
;;;855    	for (i = 0; i < _usLen; i++)
000008  2500              MOVS     r5,#0
00000a  e039              B        |L16.128|
                  |L16.12|
;;;856    	{
;;;857    		/* 如果发送缓冲区已经满了，则等待缓冲区空 */
;;;858    	#if 0
;;;859    		/*
;;;860    			在调试GPRS例程时，下面的代码出现死机，while 死循环
;;;861    			原因： 发送第1个字节时 _pUart->usTxWrite = 1；_pUart->usTxRead = 0;
;;;862    			将导致while(1) 无法退出
;;;863    		*/
;;;864    		while (1)
;;;865    		{
;;;866    			uint16_t usRead;
;;;867    
;;;868    			DISABLE_INT();
;;;869    			usRead = _pUart->usTxRead;
;;;870    			ENABLE_INT();
;;;871    
;;;872    			if (++usRead >= _pUart->usTxBufSize)
;;;873    			{
;;;874    				usRead = 0;
;;;875    			}
;;;876    
;;;877    			if (usRead != _pUart->usTxWrite)  ////
;;;878    			{
;;;879    				break;
;;;880    			}
;;;881    		}
;;;882    	#else
;;;883    		/* 如果发送缓冲区已经满了，则等待缓冲区空 */
;;;884    		while (1)
00000c  e01e              B        |L16.76|
                  |L16.14|
;;;885    		{
;;;886    			__IO uint16_t usCount;
;;;887    
;;;888    			DISABLE_INT();
00000e  2001              MOVS     r0,#1
000010  f7fffffe          BL       __set_PRIMASK
;;;889    			usCount = _pUart->usTxCount;
000014  8aa0              LDRH     r0,[r4,#0x14]
000016  9000              STR      r0,[sp,#0]
;;;890    			ENABLE_INT();
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       __set_PRIMASK
;;;891    
;;;892    			if (usCount < _pUart->usTxBufSize)
00001e  89a0              LDRH     r0,[r4,#0xc]
000020  f8bd1000          LDRH     r1,[sp,#0]
000024  4288              CMP      r0,r1
000026  dd00              BLE      |L16.42|
;;;893    			{
;;;894    				break;
000028  e011              B        |L16.78|
                  |L16.42|
;;;895    			}
;;;896    			else if(usCount == _pUart->usTxBufSize)/* 数据已填满缓冲区 */
00002a  89a0              LDRH     r0,[r4,#0xc]
00002c  f8bd1000          LDRH     r1,[sp,#0]
000030  4288              CMP      r0,r1
000032  d10a              BNE      |L16.74|
;;;897    			{
;;;898    				if((_pUart->uart->CR1 & USART_CR1_TXEIE) == 0)   //如果为0，中断未打开，
000034  6820              LDR      r0,[r4,#0]
000036  8980              LDRH     r0,[r0,#0xc]
000038  f0000080          AND      r0,r0,#0x80
00003c  b928              CBNZ     r0,|L16.74|
;;;899    				{
;;;900    					USART_ITConfig(_pUart->uart, USART_IT_TXE, ENABLE);   //打开中断，发送数据
00003e  2201              MOVS     r2,#1
000040  f2407127          MOV      r1,#0x727
000044  6820              LDR      r0,[r4,#0]
000046  f7fffffe          BL       USART_ITConfig
                  |L16.74|
;;;901    				}  
;;;902    			}
;;;903    		}
00004a  bf00              NOP      
                  |L16.76|
00004c  e7df              B        |L16.14|
                  |L16.78|
00004e  bf00              NOP                            ;894
;;;904    	#endif
;;;905    
;;;906    		/* 将新数据填入发送缓冲区 */
;;;907    		_pUart->pTxBuf[_pUart->usTxWrite] = _ucaBuf[i];
000050  5d70              LDRB     r0,[r6,r5]
000052  8a22              LDRH     r2,[r4,#0x10]
000054  6861              LDR      r1,[r4,#4]
000056  5488              STRB     r0,[r1,r2]
;;;908    
;;;909    		DISABLE_INT();
000058  2001              MOVS     r0,#1
00005a  f7fffffe          BL       __set_PRIMASK
;;;910    		if (++_pUart->usTxWrite >= _pUart->usTxBufSize)
00005e  8a20              LDRH     r0,[r4,#0x10]
000060  1c40              ADDS     r0,r0,#1
000062  b280              UXTH     r0,r0
000064  8220              STRH     r0,[r4,#0x10]
000066  89a1              LDRH     r1,[r4,#0xc]
000068  4288              CMP      r0,r1
00006a  db01              BLT      |L16.112|
;;;911    		{
;;;912    			_pUart->usTxWrite = 0;
00006c  2000              MOVS     r0,#0
00006e  8220              STRH     r0,[r4,#0x10]
                  |L16.112|
;;;913    		}
;;;914    		_pUart->usTxCount++;
000070  8aa0              LDRH     r0,[r4,#0x14]
000072  1c40              ADDS     r0,r0,#1
000074  82a0              STRH     r0,[r4,#0x14]
;;;915    		ENABLE_INT();
000076  2000              MOVS     r0,#0
000078  f7fffffe          BL       __set_PRIMASK
00007c  1c68              ADDS     r0,r5,#1              ;855
00007e  b285              UXTH     r5,r0                 ;855
                  |L16.128|
000080  42bd              CMP      r5,r7                 ;855
000082  dbc3              BLT      |L16.12|
;;;916    	}
;;;917    
;;;918    	USART_ITConfig(_pUart->uart, USART_IT_TXE, ENABLE);
000084  2201              MOVS     r2,#1
000086  f2407127          MOV      r1,#0x727
00008a  6820              LDR      r0,[r4,#0]
00008c  f7fffffe          BL       USART_ITConfig
;;;919    }
000090  bdf8              POP      {r3-r7,pc}
;;;920    
                          ENDP


                          AREA ||i.UartVarInit||, CODE, READONLY, ALIGN=2

                  UartVarInit PROC
;;;451    */
;;;452    static void UartVarInit(void)
000000  482b              LDR      r0,|L17.176|
;;;453    {
;;;454    #if UART1_FIFO_EN == 1
;;;455    	g_tUart1.uart = USART1;						/* STM32 串口设备 */
000002  492c              LDR      r1,|L17.180|
000004  6008              STR      r0,[r1,#0]  ; g_tUart1
;;;456    	g_tUart1.pTxBuf = g_TxBuf1;					/* 发送缓冲区指针 */
000006  482c              LDR      r0,|L17.184|
000008  6048              STR      r0,[r1,#4]  ; g_tUart1
;;;457    	g_tUart1.pRxBuf = g_RxBuf1;					/* 接收缓冲区指针 */
00000a  482c              LDR      r0,|L17.188|
00000c  6088              STR      r0,[r1,#8]  ; g_tUart1
;;;458    	g_tUart1.usTxBufSize = UART1_TX_BUF_SIZE;	/* 发送缓冲区大小 */
00000e  f44f6080          MOV      r0,#0x400
000012  8188              STRH     r0,[r1,#0xc]
;;;459    	g_tUart1.usRxBufSize = UART1_RX_BUF_SIZE;	/* 接收缓冲区大小 */
000014  81c8              STRH     r0,[r1,#0xe]
;;;460    	g_tUart1.usTxWrite = 0;						/* 发送FIFO写索引 */
000016  2000              MOVS     r0,#0
000018  8208              STRH     r0,[r1,#0x10]
;;;461    	g_tUart1.usTxRead = 0;						/* 发送FIFO读索引 */
00001a  8248              STRH     r0,[r1,#0x12]
;;;462    	g_tUart1.usRxWrite = 0;						/* 接收FIFO写索引 */
00001c  82c8              STRH     r0,[r1,#0x16]
;;;463    	g_tUart1.usRxRead = 0;						/* 接收FIFO读索引 */
00001e  8308              STRH     r0,[r1,#0x18]
;;;464    	g_tUart1.usRxCount = 0;						/* 接收到的新数据个数 */
000020  8348              STRH     r0,[r1,#0x1a]
;;;465    	g_tUart1.usTxCount = 0;						/* 待发送的数据个数 */
000022  8288              STRH     r0,[r1,#0x14]
;;;466    	g_tUart1.SendBefor = 0;						/* 发送数据前的回调函数 */
000024  61c8              STR      r0,[r1,#0x1c]  ; g_tUart1
;;;467    	g_tUart1.SendOver = 0;						/* 发送完毕后的回调函数 */
000026  6208              STR      r0,[r1,#0x20]  ; g_tUart1
;;;468    	g_tUart1.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
000028  6248              STR      r0,[r1,#0x24]  ; g_tUart1
;;;469    #endif
;;;470    
;;;471    #if UART2_FIFO_EN == 1
;;;472    	g_tUart2.uart = USART2;						/* STM32 串口设备 */
00002a  4825              LDR      r0,|L17.192|
00002c  4925              LDR      r1,|L17.196|
00002e  6008              STR      r0,[r1,#0]  ; g_tUart2
;;;473    	g_tUart2.pTxBuf = g_TxBuf2;					/* 发送缓冲区指针 */
000030  4825              LDR      r0,|L17.200|
000032  6048              STR      r0,[r1,#4]  ; g_tUart2
;;;474    	g_tUart2.pRxBuf = g_RxBuf2;					/* 接收缓冲区指针 */
000034  4825              LDR      r0,|L17.204|
000036  6088              STR      r0,[r1,#8]  ; g_tUart2
;;;475    	g_tUart2.usTxBufSize = UART2_TX_BUF_SIZE;	/* 发送缓冲区大小 */
000038  f44f6080          MOV      r0,#0x400
00003c  8188              STRH     r0,[r1,#0xc]
;;;476    	g_tUart2.usRxBufSize = UART2_RX_BUF_SIZE;	/* 接收缓冲区大小 */
00003e  81c8              STRH     r0,[r1,#0xe]
;;;477    	g_tUart2.usTxWrite = 0;						/* 发送FIFO写索引 */
000040  2000              MOVS     r0,#0
000042  8208              STRH     r0,[r1,#0x10]
;;;478    	g_tUart2.usTxRead = 0;						/* 发送FIFO读索引 */
000044  8248              STRH     r0,[r1,#0x12]
;;;479    	g_tUart2.usRxWrite = 0;						/* 接收FIFO写索引 */
000046  82c8              STRH     r0,[r1,#0x16]
;;;480    	g_tUart2.usRxRead = 0;						/* 接收FIFO读索引 */
000048  8308              STRH     r0,[r1,#0x18]
;;;481    	g_tUart2.usRxCount = 0;						/* 接收到的新数据个数 */
00004a  8348              STRH     r0,[r1,#0x1a]
;;;482    	g_tUart2.usTxCount = 0;						/* 待发送的数据个数 */
00004c  8288              STRH     r0,[r1,#0x14]
;;;483    	g_tUart2.SendBefor = RS485_SendBefor;						/* 发送数据前的回调函数 */
00004e  4820              LDR      r0,|L17.208|
000050  61c8              STR      r0,[r1,#0x1c]  ; g_tUart2
;;;484    	g_tUart2.SendOver = RS485_SendOver;						/* 发送完毕后的回调函数 */
000052  4820              LDR      r0,|L17.212|
000054  6208              STR      r0,[r1,#0x20]  ; g_tUart2
;;;485    	g_tUart2.ReciveNew = RS485_ReciveNew;						/* 接收到新数据后的回调函数 */
000056  4820              LDR      r0,|L17.216|
000058  6248              STR      r0,[r1,#0x24]  ; g_tUart2
;;;486    #endif
;;;487    
;;;488    #if UART3_FIFO_EN == 1
;;;489    	g_tUart3.uart = USART3;						/* STM32 串口设备 */
00005a  4820              LDR      r0,|L17.220|
00005c  4920              LDR      r1,|L17.224|
00005e  6008              STR      r0,[r1,#0]  ; g_tUart3
;;;490    	g_tUart3.pTxBuf = g_TxBuf3;					/* 发送缓冲区指针 */
000060  4820              LDR      r0,|L17.228|
000062  6048              STR      r0,[r1,#4]  ; g_tUart3
;;;491    	g_tUart3.pRxBuf = g_RxBuf3;					/* 接收缓冲区指针 */
000064  4820              LDR      r0,|L17.232|
000066  6088              STR      r0,[r1,#8]  ; g_tUart3
;;;492    	g_tUart3.usTxBufSize = UART3_TX_BUF_SIZE;	/* 发送缓冲区大小 */
000068  f44f6080          MOV      r0,#0x400
00006c  8188              STRH     r0,[r1,#0xc]
;;;493    	g_tUart3.usRxBufSize = UART3_RX_BUF_SIZE;	/* 接收缓冲区大小 */
00006e  81c8              STRH     r0,[r1,#0xe]
;;;494    	g_tUart3.usTxWrite = 0;						/* 发送FIFO写索引 */
000070  2000              MOVS     r0,#0
000072  8208              STRH     r0,[r1,#0x10]
;;;495    	g_tUart3.usTxRead = 0;						/* 发送FIFO读索引 */
000074  8248              STRH     r0,[r1,#0x12]
;;;496    	g_tUart3.usRxWrite = 0;						/* 接收FIFO写索引 */
000076  82c8              STRH     r0,[r1,#0x16]
;;;497    	g_tUart3.usRxRead = 0;						/* 接收FIFO读索引 */
000078  8308              STRH     r0,[r1,#0x18]
;;;498    	g_tUart3.usRxCount = 0;						/* 接收到的新数据个数 */
00007a  8348              STRH     r0,[r1,#0x1a]
;;;499    	g_tUart3.usTxCount = 0;						/* 待发送的数据个数 */
00007c  8288              STRH     r0,[r1,#0x14]
;;;500    	g_tUart3.SendBefor = 0;						/* 发送数据前的回调函数 */
00007e  61c8              STR      r0,[r1,#0x1c]  ; g_tUart3
;;;501    	g_tUart3.SendOver = 0;						/* 发送完毕后的回调函数 */
000080  6208              STR      r0,[r1,#0x20]  ; g_tUart3
;;;502    	g_tUart3.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
000082  6248              STR      r0,[r1,#0x24]  ; g_tUart3
;;;503    #endif
;;;504    
;;;505    #if UART4_FIFO_EN == 1
;;;506    	g_tUart4.uart = UART4;						/* STM32 串口设备 */
;;;507    	g_tUart4.pTxBuf = g_TxBuf4;					/* 发送缓冲区指针 */
;;;508    	g_tUart4.pRxBuf = g_RxBuf4;					/* 接收缓冲区指针 */
;;;509    	g_tUart4.usTxBufSize = UART4_TX_BUF_SIZE;	/* 发送缓冲区大小 */
;;;510    	g_tUart4.usRxBufSize = UART4_RX_BUF_SIZE;	/* 接收缓冲区大小 */
;;;511    	g_tUart4.usTxWrite = 0;						/* 发送FIFO写索引 */
;;;512    	g_tUart4.usTxRead = 0;						/* 发送FIFO读索引 */
;;;513    	g_tUart4.usRxWrite = 0;						/* 接收FIFO写索引 */
;;;514    	g_tUart4.usRxRead = 0;						/* 接收FIFO读索引 */
;;;515    	g_tUart4.usRxCount = 0;						/* 接收到的新数据个数 */
;;;516    	g_tUart4.usTxCount = 0;						/* 待发送的数据个数 */
;;;517    	g_tUart4.SendBefor = 0;						/* 发送数据前的回调函数 */
;;;518    	g_tUart4.SendOver = 0;						/* 发送完毕后的回调函数 */
;;;519    	g_tUart4.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
;;;520    #endif
;;;521    
;;;522    #if UART5_FIFO_EN == 1
;;;523    	g_tUart5.uart = UART5;						/* STM32 串口设备 */
000084  4819              LDR      r0,|L17.236|
000086  491a              LDR      r1,|L17.240|
000088  6008              STR      r0,[r1,#0]  ; g_tUart5
;;;524    	g_tUart5.pTxBuf = g_TxBuf5;					/* 发送缓冲区指针 */
00008a  481a              LDR      r0,|L17.244|
00008c  6048              STR      r0,[r1,#4]  ; g_tUart5
;;;525    	g_tUart5.pRxBuf = g_RxBuf5;					/* 接收缓冲区指针 */
00008e  481a              LDR      r0,|L17.248|
000090  6088              STR      r0,[r1,#8]  ; g_tUart5
;;;526    	g_tUart5.usTxBufSize = UART5_TX_BUF_SIZE;	/* 发送缓冲区大小 */
000092  f44f6080          MOV      r0,#0x400
000096  8188              STRH     r0,[r1,#0xc]
;;;527    	g_tUart5.usRxBufSize = UART5_RX_BUF_SIZE;	/* 接收缓冲区大小 */
000098  81c8              STRH     r0,[r1,#0xe]
;;;528    	g_tUart5.usTxWrite = 0;						/* 发送FIFO写索引 */
00009a  2000              MOVS     r0,#0
00009c  8208              STRH     r0,[r1,#0x10]
;;;529    	g_tUart5.usTxRead = 0;						/* 发送FIFO读索引 */
00009e  8248              STRH     r0,[r1,#0x12]
;;;530    	g_tUart5.usRxWrite = 0;						/* 接收FIFO写索引 */
0000a0  82c8              STRH     r0,[r1,#0x16]
;;;531    	g_tUart5.usRxRead = 0;						/* 接收FIFO读索引 */
0000a2  8308              STRH     r0,[r1,#0x18]
;;;532    	g_tUart5.usRxCount = 0;						/* 接收到的新数据个数 */
0000a4  8348              STRH     r0,[r1,#0x1a]
;;;533    	g_tUart5.usTxCount = 0;						/* 待发送的数据个数 */
0000a6  8288              STRH     r0,[r1,#0x14]
;;;534    	g_tUart5.SendBefor = 0;						/* 发送数据前的回调函数 */
0000a8  61c8              STR      r0,[r1,#0x1c]  ; g_tUart5
;;;535    	g_tUart5.SendOver = 0;						/* 发送完毕后的回调函数 */
0000aa  6208              STR      r0,[r1,#0x20]  ; g_tUart5
;;;536    	g_tUart5.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
0000ac  6248              STR      r0,[r1,#0x24]  ; g_tUart5
;;;537    #endif
;;;538    }
0000ae  4770              BX       lr
;;;539    
                          ENDP

                  |L17.176|
                          DCD      0x40013800
                  |L17.180|
                          DCD      g_tUart1
                  |L17.184|
                          DCD      g_TxBuf1
                  |L17.188|
                          DCD      g_RxBuf1
                  |L17.192|
                          DCD      0x40004400
                  |L17.196|
                          DCD      g_tUart2
                  |L17.200|
                          DCD      g_TxBuf2
                  |L17.204|
                          DCD      g_RxBuf2
                  |L17.208|
                          DCD      RS485_SendBefor
                  |L17.212|
                          DCD      RS485_SendOver
                  |L17.216|
                          DCD      RS485_ReciveNew
                  |L17.220|
                          DCD      0x40004800
                  |L17.224|
                          DCD      g_tUart3
                  |L17.228|
                          DCD      g_TxBuf3
                  |L17.232|
                          DCD      g_RxBuf3
                  |L17.236|
                          DCD      0x40005000
                  |L17.240|
                          DCD      g_tUart5
                  |L17.244|
                          DCD      g_TxBuf5
                  |L17.248|
                          DCD      g_RxBuf5

                          AREA ||i.__set_PRIMASK||, CODE, READONLY, ALIGN=1

                  __set_PRIMASK PROC
;;;179     */
;;;180    __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
000000  f3808810          MSR      PRIMASK,r0
;;;181    {
;;;182      register uint32_t __regPriMask         __ASM("primask");
;;;183      __regPriMask = (priMask);
;;;184    }
000004  4770              BX       lr
;;;185    
                          ENDP


                          AREA ||i.bsp_InitUart||, CODE, READONLY, ALIGN=1

                  bsp_InitUart PROC
;;;68     */
;;;69     void bsp_InitUart(void)
000000  b510              PUSH     {r4,lr}
;;;70     {
;;;71     	UartVarInit();		/* 必须先初始化全局变量,再配置硬件 */
000002  f7fffffe          BL       UartVarInit
;;;72     
;;;73     	InitHardUart();		/* 配置串口的硬件参数(波特率等) */
000006  f7fffffe          BL       InitHardUart
;;;74     
;;;75     	RS485_InitTXE();	/* 配置RS485芯片的发送使能硬件，配置为推挽输出 */
00000a  f7fffffe          BL       RS485_InitTXE
;;;76     
;;;77     	ConfigUartNVIC();	/* 配置串口中断 */
00000e  f7fffffe          BL       ConfigUartNVIC
;;;78     }
000012  bd10              POP      {r4,pc}
;;;79     
                          ENDP


                          AREA ||i.bsp_Set485Baud||, CODE, READONLY, ALIGN=2

                  bsp_Set485Baud PROC
;;;358    */
;;;359    void bsp_Set485Baud(uint32_t _baud)
000000  b51f              PUSH     {r0-r4,lr}
;;;360    {
000002  4604              MOV      r4,r0
;;;361    	USART_InitTypeDef USART_InitStructure;
;;;362    
;;;363    	/* 第2步： 配置串口硬件参数 */
;;;364    	USART_InitStructure.USART_BaudRate = _baud;	/* 波特率 */
000004  9400              STR      r4,[sp,#0]
;;;365    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000006  2000              MOVS     r0,#0
000008  f8ad0004          STRH     r0,[sp,#4]
;;;366    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
00000c  f8ad0006          STRH     r0,[sp,#6]
;;;367    	USART_InitStructure.USART_Parity = USART_Parity_No ;
000010  f8ad0008          STRH     r0,[sp,#8]
;;;368    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000014  f8ad000c          STRH     r0,[sp,#0xc]
;;;369    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000018  200c              MOVS     r0,#0xc
00001a  f8ad000a          STRH     r0,[sp,#0xa]
;;;370    	USART_Init(USART2, &USART_InitStructure);
00001e  4669              MOV      r1,sp
000020  4801              LDR      r0,|L20.40|
000022  f7fffffe          BL       USART_Init
;;;371    }
000026  bd1f              POP      {r0-r4,pc}
;;;372    
                          ENDP

                  |L20.40|
                          DCD      0x40004400

                          AREA ||i.comClearRxFifo||, CODE, READONLY, ALIGN=1

                  comClearRxFifo PROC
;;;231    */
;;;232    void comClearRxFifo(COM_PORT_E _ucPort)
000000  b500              PUSH     {lr}
;;;233    {
000002  4603              MOV      r3,r0
;;;234    	UART_T *pUart;
;;;235    
;;;236    	pUart = ComToUart(_ucPort);
000004  4618              MOV      r0,r3
000006  f7fffffe          BL       ComToUart
00000a  4602              MOV      r2,r0
;;;237    	if (pUart == 0)
00000c  b902              CBNZ     r2,|L21.16|
                  |L21.14|
;;;238    	{
;;;239    		return;
;;;240    	}
;;;241    
;;;242    	pUart->usRxWrite = 0;
;;;243    	pUart->usRxRead = 0;
;;;244    	pUart->usRxCount = 0;
;;;245    }
00000e  bd00              POP      {pc}
                  |L21.16|
000010  2000              MOVS     r0,#0                 ;242
000012  82d0              STRH     r0,[r2,#0x16]         ;242
000014  8310              STRH     r0,[r2,#0x18]         ;243
000016  8350              STRH     r0,[r2,#0x1a]         ;244
000018  bf00              NOP      
00001a  e7f8              B        |L21.14|
;;;246    
                          ENDP


                          AREA ||i.comClearTxFifo||, CODE, READONLY, ALIGN=1

                  comClearTxFifo PROC
;;;208    */
;;;209    void comClearTxFifo(COM_PORT_E _ucPort)
000000  b500              PUSH     {lr}
;;;210    {
000002  4603              MOV      r3,r0
;;;211    	UART_T *pUart;
;;;212    
;;;213    	pUart = ComToUart(_ucPort);
000004  4618              MOV      r0,r3
000006  f7fffffe          BL       ComToUart
00000a  4602              MOV      r2,r0
;;;214    	if (pUart == 0)
00000c  b902              CBNZ     r2,|L22.16|
                  |L22.14|
;;;215    	{
;;;216    		return;
;;;217    	}
;;;218    
;;;219    	pUart->usTxWrite = 0;
;;;220    	pUart->usTxRead = 0;
;;;221    	pUart->usTxCount = 0;
;;;222    }
00000e  bd00              POP      {pc}
                  |L22.16|
000010  2000              MOVS     r0,#0                 ;219
000012  8210              STRH     r0,[r2,#0x10]         ;219
000014  8250              STRH     r0,[r2,#0x12]         ;220
000016  8290              STRH     r0,[r2,#0x14]         ;221
000018  bf00              NOP      
00001a  e7f8              B        |L22.14|
;;;223    
                          ENDP


                          AREA ||i.comGetChar||, CODE, READONLY, ALIGN=1

                  comGetChar PROC
;;;187    */
;;;188    uint8_t comGetChar(COM_PORT_E _ucPort, uint8_t *_pByte)
000000  b570              PUSH     {r4-r6,lr}
;;;189    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;190    	UART_T *pUart;
;;;191    
;;;192    	pUart = ComToUart(_ucPort);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       ComToUart
00000c  4604              MOV      r4,r0
;;;193    	if (pUart == 0)
00000e  b90c              CBNZ     r4,|L23.20|
;;;194    	{
;;;195    		return 0;
000010  2000              MOVS     r0,#0
                  |L23.18|
;;;196    	}
;;;197    
;;;198    	return UartGetChar(pUart, _pByte);
;;;199    }
000012  bd70              POP      {r4-r6,pc}
                  |L23.20|
000014  4631              MOV      r1,r6                 ;198
000016  4620              MOV      r0,r4                 ;198
000018  f7fffffe          BL       UartGetChar
00001c  e7f9              B        |L23.18|
;;;200    
                          ENDP


                          AREA ||i.comSendBuf||, CODE, READONLY, ALIGN=1

                  comSendBuf PROC
;;;146    */
;;;147    void comSendBuf(COM_PORT_E _ucPort, uint8_t *_ucaBuf, uint16_t _usLen)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;148    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;149    	UART_T *pUart;
;;;150    
;;;151    	pUart = ComToUart(_ucPort);
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       ComToUart
000010  4604              MOV      r4,r0
;;;152    	if (pUart == 0)
000012  b90c              CBNZ     r4,|L24.24|
                  |L24.20|
;;;153    	{
;;;154    		return;
;;;155    	}
;;;156    
;;;157    	if (pUart->SendBefor != 0)
;;;158    	{
;;;159    		pUart->SendBefor();		/* 如果是RS485通信，可以在这个函数中将RS485设置为发送模式 */
;;;160    	}
;;;161    
;;;162    	UartSend(pUart, _ucaBuf, _usLen);
;;;163    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L24.24|
000018  69e0              LDR      r0,[r4,#0x1c]         ;157
00001a  b108              CBZ      r0,|L24.32|
00001c  69e0              LDR      r0,[r4,#0x1c]         ;159
00001e  4780              BLX      r0                    ;159
                  |L24.32|
000020  463a              MOV      r2,r7                 ;162
000022  4631              MOV      r1,r6                 ;162
000024  4620              MOV      r0,r4                 ;162
000026  f7fffffe          BL       UartSend
00002a  bf00              NOP      
00002c  e7f2              B        |L24.20|
;;;164    
                          ENDP


                          AREA ||i.comSendChar||, CODE, READONLY, ALIGN=1

                  comSendChar PROC
;;;173    */
;;;174    void comSendChar(COM_PORT_E _ucPort, uint8_t _ucByte)
000000  b513              PUSH     {r0,r1,r4,lr}
;;;175    {
000002  4604              MOV      r4,r0
;;;176    	comSendBuf(_ucPort, &_ucByte, 1);
000004  2201              MOVS     r2,#1
000006  a901              ADD      r1,sp,#4
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       comSendBuf
;;;177    }
00000e  bd1c              POP      {r2-r4,pc}
;;;178    
                          ENDP


                          AREA ||i.fgetc||, CODE, READONLY, ALIGN=1

                  fgetc PROC
;;;1136   */
;;;1137   int fgetc(FILE *f)
000000  b538              PUSH     {r3-r5,lr}
;;;1138   {
000002  4604              MOV      r4,r0
;;;1139   
;;;1140   #if 1	/* 从串口接收FIFO中取1个数据, 只有取到数据才返回 */
;;;1141   	uint8_t ucData;
;;;1142   
;;;1143   	while(comGetChar(COM1, &ucData) == 0);
000004  bf00              NOP      
                  |L26.6|
000006  4669              MOV      r1,sp
000008  2000              MOVS     r0,#0
00000a  f7fffffe          BL       comGetChar
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L26.6|
;;;1144   
;;;1145   	return ucData;
000012  f89d0000          LDRB     r0,[sp,#0]
;;;1146   #else
;;;1147   	/* 等待串口1输入数据 */
;;;1148   	while (USART_GetFlagStatus(USART1, USART_FLAG_RXNE) == RESET);
;;;1149   
;;;1150   	return (int)USART_ReceiveData(USART1);
;;;1151   #endif
;;;1152   }
000016  bd38              POP      {r3-r5,pc}
;;;1153   
                          ENDP


                          AREA ||i.fputc||, CODE, READONLY, ALIGN=1

                  fputc PROC
;;;1110   */
;;;1111   int fputc(int ch, FILE *f)
000000  b570              PUSH     {r4-r6,lr}
;;;1112   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1113   #if 1	/* 将需要printf的字符通过串口中断FIFO发送出去，printf函数会立即返回 */
;;;1114   	comSendChar(COM1, ch);
000006  b2e1              UXTB     r1,r4
000008  2000              MOVS     r0,#0
00000a  f7fffffe          BL       comSendChar
;;;1115   
;;;1116   	return ch;
00000e  4620              MOV      r0,r4
;;;1117   #else	/* 采用阻塞方式发送每个字符,等待数据发送完毕 */
;;;1118   	/* 写一个字节到USART1 */
;;;1119   	USART_SendData(USART2, (uint8_t) ch);
;;;1120   
;;;1121   	/* 等待发送结束 */
;;;1122   	while (USART_GetFlagStatus(USART2, USART_FLAG_TC) == RESET)
;;;1123   	{}
;;;1124   
;;;1125   	return ch;
;;;1126   #endif
;;;1127   }
000010  bd70              POP      {r4-r6,pc}
;;;1128   
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  g_tUart1
                          %        40
                  g_TxBuf1
                          %        1024
                  g_RxBuf1
                          %        1024
                  g_tUart2
                          %        40
                  g_TxBuf2
                          %        1024
                  g_RxBuf2
                          %        1024
                  g_tUart3
                          %        40
                  g_TxBuf3
                          %        1024
                  g_RxBuf3
                          %        1024
                  g_tUart5
                          %        40
                  g_TxBuf5
                          %        1024
                  g_RxBuf5
                          %        1024

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_uart_fifo.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_bsp_uart_fifo_c_b28b0d00____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_bsp_uart_fifo_c_b28b0d00____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_bsp_uart_fifo_c_b28b0d00____REVSH|
#line 128
|__asm___15_bsp_uart_fifo_c_b28b0d00____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

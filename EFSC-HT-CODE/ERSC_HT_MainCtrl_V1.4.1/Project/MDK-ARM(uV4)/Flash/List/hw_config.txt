; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\hw_config.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\hw_config.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\FatFS\src -I..\..\User\Mass_Storage\inc -I..\..\User\LCD_Driver -I..\..\User\SYSTEM\sys -I..\..\User\Debugprintf -I..\..\User\LogDebug -I..\..\User\app\inc -I..\..\User\app\src -I..\..\User\bsp\inc -I..\..\User\bsp\src -I.\RTE\_Flash -ID:\Keil_v5\ARM\Packs\ARM\CMSIS\5.5.1\CMSIS\Core\Include -ID:\Keil_v5\ARM\Packs\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=527 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\hw_config.crf ..\..\User\Mass_Storage\src\hw_config.c]
                          THUMB

                          AREA ||i.Enter_LowPowerMode||, CODE, READONLY, ALIGN=2

                  Enter_LowPowerMode PROC
;;;91     *******************************************************************************/
;;;92     void Enter_LowPowerMode(void)
000000  2003              MOVS     r0,#3
;;;93     {
;;;94       /* Set the device state to suspend */
;;;95       bDeviceState = SUSPENDED;
000002  4901              LDR      r1,|L1.8|
000004  6008              STR      r0,[r1,#0]  ; bDeviceState
;;;96     }
000006  4770              BX       lr
;;;97     
                          ENDP

                  |L1.8|
                          DCD      bDeviceState

                          AREA ||i.Get_SerialNum||, CODE, READONLY, ALIGN=2

                  Get_SerialNum PROC
;;;207    *******************************************************************************/
;;;208    void Get_SerialNum(void)
000000  b570              PUSH     {r4-r6,lr}
;;;209    {
;;;210      uint32_t Device_Serial0, Device_Serial1, Device_Serial2;
;;;211    
;;;212      Device_Serial0 = *(__IO uint32_t*)(0x1FFFF7E8);
000002  480a              LDR      r0,|L2.44|
000004  6804              LDR      r4,[r0,#0]
;;;213      Device_Serial1 = *(__IO uint32_t*)(0x1FFFF7EC);
000006  1d00              ADDS     r0,r0,#4
000008  6805              LDR      r5,[r0,#0]
;;;214      Device_Serial2 = *(__IO uint32_t*)(0x1FFFF7F0);
00000a  1d00              ADDS     r0,r0,#4
00000c  6806              LDR      r6,[r0,#0]
;;;215    
;;;216      Device_Serial0 += Device_Serial2;
00000e  4434              ADD      r4,r4,r6
;;;217    
;;;218      if (Device_Serial0 != 0)
000010  b154              CBZ      r4,|L2.40|
;;;219      {
;;;220        IntToUnicode (Device_Serial0, &MASS_StringSerial[2] , 8);
000012  2208              MOVS     r2,#8
000014  4906              LDR      r1,|L2.48|
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       IntToUnicode
;;;221        IntToUnicode (Device_Serial1, &MASS_StringSerial[18], 4);
00001c  2204              MOVS     r2,#4
00001e  4904              LDR      r1,|L2.48|
000020  3110              ADDS     r1,r1,#0x10
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       IntToUnicode
                  |L2.40|
;;;222      }
;;;223    }
000028  bd70              POP      {r4-r6,pc}
;;;224    
                          ENDP

00002a  0000              DCW      0x0000
                  |L2.44|
                          DCD      0x1ffff7e8
                  |L2.48|
                          DCD      MASS_StringSerial+0x2

                          AREA ||i.IntToUnicode||, CODE, READONLY, ALIGN=1

                  IntToUnicode PROC
;;;231    *******************************************************************************/
;;;232    static void IntToUnicode (uint32_t value , uint8_t *pbuf , uint8_t len)
000000  b530              PUSH     {r4,r5,lr}
;;;233    {
000002  460b              MOV      r3,r1
;;;234      uint8_t idx = 0;
000004  2100              MOVS     r1,#0
;;;235      
;;;236      for( idx = 0 ; idx < len ; idx ++)
000006  bf00              NOP      
000008  e016              B        |L3.56|
                  |L3.10|
;;;237      {
;;;238        if( ((value >> 28)) < 0xA )
00000a  240a              MOVS     r4,#0xa
00000c  ebb47f10          CMP      r4,r0,LSR #28
000010  d905              BLS      |L3.30|
;;;239        {
;;;240          pbuf[ 2* idx] = (value >> 28) + '0';
000012  2430              MOVS     r4,#0x30
000014  eb047410          ADD      r4,r4,r0,LSR #28
000018  f8034011          STRB     r4,[r3,r1,LSL #1]
00001c  e005              B        |L3.42|
                  |L3.30|
;;;241        }
;;;242        else
;;;243        {
;;;244          pbuf[2* idx] = (value >> 28) + 'A' - 10; 
00001e  2441              MOVS     r4,#0x41
000020  eb047410          ADD      r4,r4,r0,LSR #28
000024  3c0a              SUBS     r4,r4,#0xa
000026  f8034011          STRB     r4,[r3,r1,LSL #1]
                  |L3.42|
;;;245        }
;;;246        
;;;247        value = value << 4;
00002a  0100              LSLS     r0,r0,#4
;;;248        
;;;249        pbuf[ 2* idx + 1] = 0;
00002c  2500              MOVS     r5,#0
00002e  004c              LSLS     r4,r1,#1
000030  1c64              ADDS     r4,r4,#1
000032  551d              STRB     r5,[r3,r4]
000034  1c4c              ADDS     r4,r1,#1              ;236
000036  b2e1              UXTB     r1,r4                 ;236
                  |L3.56|
000038  4291              CMP      r1,r2                 ;236
00003a  dbe6              BLT      |L3.10|
;;;250      }
;;;251    }
00003c  bd30              POP      {r4,r5,pc}
;;;252    
                          ENDP


                          AREA ||i.Leave_LowPowerMode||, CODE, READONLY, ALIGN=2

                  Leave_LowPowerMode PROC
;;;103    *******************************************************************************/
;;;104    void Leave_LowPowerMode(void)
000000  4805              LDR      r0,|L4.24|
;;;105    {
;;;106      DEVICE_INFO *pInfo = &Device_Info;
;;;107    
;;;108      /* Set the device state to the correct state */
;;;109      if (pInfo->Current_Configuration != 0)
000002  7a81              LDRB     r1,[r0,#0xa]
000004  b119              CBZ      r1,|L4.14|
;;;110      {
;;;111        /* Device configured */
;;;112        bDeviceState = CONFIGURED;
000006  2105              MOVS     r1,#5
000008  4a04              LDR      r2,|L4.28|
00000a  6011              STR      r1,[r2,#0]  ; bDeviceState
00000c  e002              B        |L4.20|
                  |L4.14|
;;;113      }
;;;114      else
;;;115      {
;;;116        bDeviceState = ATTACHED;
00000e  2101              MOVS     r1,#1
000010  4a02              LDR      r2,|L4.28|
000012  6011              STR      r1,[r2,#0]  ; bDeviceState
                  |L4.20|
;;;117      }
;;;118    
;;;119    }
000014  4770              BX       lr
;;;120    
                          ENDP

000016  0000              DCW      0x0000
                  |L4.24|
                          DCD      Device_Info
                  |L4.28|
                          DCD      bDeviceState

                          AREA ||i.MAL_Config||, CODE, READONLY, ALIGN=1

                  MAL_Config PROC
;;;258    *******************************************************************************/
;;;259    void MAL_Config(void)
000000  b510              PUSH     {r4,lr}
;;;260    {
;;;261      MAL_Init(0);
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       MAL_Init
;;;262    }
000008  bd10              POP      {r4,pc}
;;;263    
                          ENDP


                          AREA ||i.Set_System||, CODE, READONLY, ALIGN=1

                  Set_System PROC
;;;56     *******************************************************************************/
;;;57     void Set_System(void)
000000  b510              PUSH     {r4,lr}
;;;58     {
;;;59       /*!< At this stage the microcontroller clock setting is already configured, 
;;;60            this is done through SystemInit() function which is called from startup
;;;61            file (startup_stm32f10x_xx.s) before to branch to application main.
;;;62            To reconfigure the default setting of SystemInit() function, refer to
;;;63            system_stm32f10x.c file
;;;64          */ 
;;;65     
;;;66       /* MAL configuration */
;;;67       MAL_Config();
000002  f7fffffe          BL       MAL_Config
;;;68     }
000006  bd10              POP      {r4,pc}
;;;69     
                          ENDP


                          AREA ||i.Set_USBClock||, CODE, READONLY, ALIGN=1

                  Set_USBClock PROC
;;;75     *******************************************************************************/
;;;76     void Set_USBClock(void)
000000  b510              PUSH     {r4,lr}
;;;77     {
;;;78     
;;;79       RCC_USBCLKConfig(RCC_USBCLKSource_PLLCLK_1Div5);
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       RCC_USBCLKConfig
;;;80       
;;;81       /* Enable the USB clock */
;;;82       RCC_APB1PeriphClockCmd(RCC_APB1Periph_USB, ENABLE);
000008  2101              MOVS     r1,#1
00000a  05c8              LSLS     r0,r1,#23
00000c  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;83     
;;;84     }
000010  bd10              POP      {r4,pc}
;;;85     
                          ENDP


                          AREA ||i.USB_Cable_Config||, CODE, READONLY, ALIGN=2

                  USB_Cable_Config PROC
;;;160    *******************************************************************************/
;;;161    void USB_Cable_Config (FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;162    {
000002  4604              MOV      r4,r0
;;;163    #if 0
;;;164     	GPIO_InitTypeDef GPIO_InitStructure;
;;;165    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD, ENABLE);
;;;166    
;;;167      /* PD3 输出 0 时 D+ 接上拉电阻工作于全速模式 */ 
;;;168      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
;;;169      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;170      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;	   /* 开漏输出 */
;;;171      GPIO_Init(GPIOD, &GPIO_InitStructure);
;;;172      
;;;173      if (NewState!=DISABLE)
;;;174      {
;;;175        GPIO_ResetBits(GPIOD, GPIO_Pin_3);	   //连接USB ,开发板上的USB_EN接的是PD3
;;;176      }
;;;177      else
;;;178      {
;;;179        GPIO_SetBits(GPIOD, GPIO_Pin_3);	//断开USB
;;;180      }
;;;181    #endif
;;;182    #if 1
;;;183    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);    //使能PORTA时钟		
000004  2101              MOVS     r1,#1
000006  2004              MOVS     r0,#4
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;184    	if (NewState!=DISABLE)
00000c  b154              CBZ      r4,|L8.36|
;;;185    	{
;;;186    		_SetCNTR(_GetCNTR()&(~(1<<1)));//退出断电模式
00000e  4813              LDR      r0,|L8.92|
000010  6800              LDR      r0,[r0,#0]
000012  b280              UXTH     r0,r0
000014  f0200002          BIC      r0,r0,#2
000018  4910              LDR      r1,|L8.92|
00001a  6008              STR      r0,[r1,#0]
;;;187    		printf("usb pull up enable\r\n"); 
00001c  a010              ADR      r0,|L8.96|
00001e  f7fffffe          BL       __2printf
000022  e019              B        |L8.88|
                  |L8.36|
;;;188    	}
;;;189    			
;;;190    	else 
;;;191    	{
;;;192    		_SetCNTR(_GetCNTR()|(1<<1));  // 断电模式
000024  480d              LDR      r0,|L8.92|
000026  6800              LDR      r0,[r0,#0]
000028  b280              UXTH     r0,r0
00002a  f0400002          ORR      r0,r0,#2
00002e  490b              LDR      r1,|L8.92|
000030  6008              STR      r0,[r1,#0]
;;;193    		GPIOA->CRH&=0XFFF00FFF;
000032  4811              LDR      r0,|L8.120|
000034  6800              LDR      r0,[r0,#0]
000036  f420207f          BIC      r0,r0,#0xff000
00003a  490f              LDR      r1,|L8.120|
00003c  6008              STR      r0,[r1,#0]
;;;194    		GPIOA->CRH|=0X00033000;
00003e  4608              MOV      r0,r1
000040  6800              LDR      r0,[r0,#0]
000042  f440304c          ORR      r0,r0,#0x33000
000046  6008              STR      r0,[r1,#0]
;;;195    		GPIO_ResetBits(GPIOA,GPIO_Pin_12);
000048  1489              ASRS     r1,r1,#18
00004a  480b              LDR      r0,|L8.120|
00004c  1f00              SUBS     r0,r0,#4
00004e  f7fffffe          BL       GPIO_ResetBits
;;;196    		printf("usb pull up disable\r\n");
000052  a00a              ADR      r0,|L8.124|
000054  f7fffffe          BL       __2printf
                  |L8.88|
;;;197    	}	
;;;198    #endif 
;;;199    } 
000058  bd10              POP      {r4,pc}
;;;200    
                          ENDP

00005a  0000              DCW      0x0000
                  |L8.92|
                          DCD      0x40005c40
                  |L8.96|
000060  75736220          DCB      "usb pull up enable\r\n",0
000064  70756c6c
000068  20757020
00006c  656e6162
000070  6c650d0a
000074  00      
000075  00                DCB      0
000076  00                DCB      0
000077  00                DCB      0
                  |L8.120|
                          DCD      0x40010804
                  |L8.124|
00007c  75736220          DCB      "usb pull up disable\r\n",0
000080  70756c6c
000084  20757020
000088  64697361
00008c  626c650d
000090  0a00    
000092  00                DCB      0
000093  00                DCB      0

                          AREA ||i.USB_Interrupts_Config||, CODE, READONLY, ALIGN=1

                  USB_Interrupts_Config PROC
;;;126    *******************************************************************************/
;;;127    void USB_Interrupts_Config(void)
000000  b508              PUSH     {r3,lr}
;;;128    {
;;;129      NVIC_InitTypeDef NVIC_InitStructure;
;;;130    
;;;131      NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
000002  f44f60c0          MOV      r0,#0x600
000006  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;132    
;;;133    
;;;134      NVIC_InitStructure.NVIC_IRQChannel = USB_LP_CAN1_RX0_IRQn;
00000a  2014              MOVS     r0,#0x14
00000c  f88d0000          STRB     r0,[sp,#0]
;;;135      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
000010  2001              MOVS     r0,#1
000012  f88d0001          STRB     r0,[sp,#1]
;;;136      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
000016  f88d0002          STRB     r0,[sp,#2]
;;;137      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00001a  f88d0003          STRB     r0,[sp,#3]
;;;138      NVIC_Init(&NVIC_InitStructure);
00001e  4668              MOV      r0,sp
000020  f7fffffe          BL       NVIC_Init
;;;139    
;;;140      NVIC_InitStructure.NVIC_IRQChannel = USB_HP_CAN1_TX_IRQn;
000024  2013              MOVS     r0,#0x13
000026  f88d0000          STRB     r0,[sp,#0]
;;;141      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
00002a  2001              MOVS     r0,#1
00002c  f88d0001          STRB     r0,[sp,#1]
;;;142      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000030  2000              MOVS     r0,#0
000032  f88d0002          STRB     r0,[sp,#2]
;;;143      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000036  2001              MOVS     r0,#1
000038  f88d0003          STRB     r0,[sp,#3]
;;;144      NVIC_Init(&NVIC_InitStructure);
00003c  4668              MOV      r0,sp
00003e  f7fffffe          BL       NVIC_Init
;;;145      
;;;146      NVIC_InitStructure.NVIC_IRQChannel = SDIO_IRQn;
000042  2031              MOVS     r0,#0x31
000044  f88d0000          STRB     r0,[sp,#0]
;;;147      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
000048  2000              MOVS     r0,#0
00004a  f88d0001          STRB     r0,[sp,#1]
;;;148      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
00004e  f88d0002          STRB     r0,[sp,#2]
;;;149      NVIC_Init(&NVIC_InitStructure); 
000052  4668              MOV      r0,sp
000054  f7fffffe          BL       NVIC_Init
;;;150    }
000058  bd08              POP      {r3,pc}
;;;151    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=0

                  HSEStartUpStatus
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\Mass_Storage\\src\\hw_config.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_hw_config_c_25f922fc____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___11_hw_config_c_25f922fc____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_hw_config_c_25f922fc____REVSH|
#line 128
|__asm___11_hw_config_c_25f922fc____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

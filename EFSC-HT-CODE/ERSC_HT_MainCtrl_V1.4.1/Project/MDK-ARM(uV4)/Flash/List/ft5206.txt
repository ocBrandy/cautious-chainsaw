; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\ft5206.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\ft5206.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\FatFS\src -I..\..\User\Mass_Storage\inc -I..\..\User\LCD_Driver -I..\..\User\SYSTEM\sys -I..\..\User\Debugprintf -I..\..\User\LogDebug -I..\..\User\app\inc -I..\..\User\app\src -I..\..\User\bsp\inc -I..\..\User\bsp\src -I.\RTE\_Flash -ID:\Keil_v5\ARM\Packs\ARM\CMSIS\5.5.1\CMSIS\Core\Include -ID:\Keil_v5\ARM\Packs\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=527 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\ft5206.crf ..\..\User\LCD_Driver\ft5206.c]
                          THUMB

                          AREA ||i.FT5206_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  FT5206_Init PROC
;;;60     //返回值:0,初始化成功;1,初始化失败 
;;;61     u8 FT5206_Init(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;62     {
;;;63     	u8 temp[2];  		
;;;64      	GPIO_InitTypeDef  GPIO_InitStructure;	
;;;65     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOF, ENABLE);	 //使能PF端口时钟
000002  2101              MOVS     r1,#1
000004  2080              MOVS     r0,#0x80
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;66     
;;;67     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;				 // PF11端口配置
00000a  f44f6000          MOV      r0,#0x800
00000e  f8ad0000          STRH     r0,[sp,#0]
;;;68       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; 		 //推挽输出
000012  2010              MOVS     r0,#0x10
000014  f88d0003          STRB     r0,[sp,#3]
;;;69     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000018  2003              MOVS     r0,#3
00001a  f88d0002          STRB     r0,[sp,#2]
;;;70     	GPIO_Init(GPIOF, &GPIO_InitStructure);//PF11推挽输出
00001e  4669              MOV      r1,sp
000020  482d              LDR      r0,|L1.216|
000022  f7fffffe          BL       GPIO_Init
;;;71     	GPIO_SetBits(GPIOF,GPIO_Pin_1);//上拉
000026  2102              MOVS     r1,#2
000028  482b              LDR      r0,|L1.216|
00002a  f7fffffe          BL       GPIO_SetBits
;;;72     		
;;;73       GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;				 // PB2端口配置
00002e  f44f6080          MOV      r0,#0x400
000032  f8ad0000          STRH     r0,[sp,#0]
;;;74     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; 		 //上拉输入
000036  2048              MOVS     r0,#0x48
000038  f88d0003          STRB     r0,[sp,#3]
;;;75     	GPIO_Init(GPIOF, &GPIO_InitStructure);//PF10上拉输入
00003c  4669              MOV      r1,sp
00003e  4826              LDR      r0,|L1.216|
000040  f7fffffe          BL       GPIO_Init
;;;76     	GPIO_SetBits(GPIOF,GPIO_Pin_10);//上拉		
000044  f44f6180          MOV      r1,#0x400
000048  4823              LDR      r0,|L1.216|
00004a  f7fffffe          BL       GPIO_SetBits
;;;77     
;;;78     	CT_IIC_Init();      	//初始化电容屏的I2C总线  
00004e  f7fffffe          BL       CT_IIC_Init
;;;79     	FT_RST=0;				//复位
000052  2000              MOVS     r0,#0
000054  4921              LDR      r1,|L1.220|
000056  6008              STR      r0,[r1,#0]
;;;80     	bsp_DelayMS(20);
000058  2014              MOVS     r0,#0x14
00005a  f7fffffe          BL       bsp_DelayMS
;;;81      	FT_RST=1;				//释放复位		    
00005e  2001              MOVS     r0,#1
000060  491f              LDR      r1,|L1.224|
000062  f8c101ac          STR      r0,[r1,#0x1ac]
;;;82     	bsp_DelayMS(50);  	
000066  2032              MOVS     r0,#0x32
000068  f7fffffe          BL       bsp_DelayMS
;;;83     	temp[0]=0;
00006c  2000              MOVS     r0,#0
00006e  f88d0004          STRB     r0,[sp,#4]
;;;84     	FT5206_WR_Reg(FT_DEVIDE_MODE,temp,1);	//进入正常操作模式 
000072  2201              MOVS     r2,#1
000074  a901              ADD      r1,sp,#4
000076  f7fffffe          BL       FT5206_WR_Reg
;;;85     	FT5206_WR_Reg(FT_ID_G_MODE,temp,1);		//查询模式 
00007a  2201              MOVS     r2,#1
00007c  a901              ADD      r1,sp,#4
00007e  20a4              MOVS     r0,#0xa4
000080  f7fffffe          BL       FT5206_WR_Reg
;;;86     	temp[0]=22;								//触摸有效值，22，越小越灵敏	
000084  2016              MOVS     r0,#0x16
000086  f88d0004          STRB     r0,[sp,#4]
;;;87     	FT5206_WR_Reg(FT_ID_G_THGROUP,temp,1);	//设置触摸有效值
00008a  2201              MOVS     r2,#1
00008c  a901              ADD      r1,sp,#4
00008e  2080              MOVS     r0,#0x80
000090  f7fffffe          BL       FT5206_WR_Reg
;;;88     	temp[0]=12;								//激活周期，不能小于12，最大14
000094  200c              MOVS     r0,#0xc
000096  f88d0004          STRB     r0,[sp,#4]
;;;89     	FT5206_WR_Reg(FT_ID_G_PERIODACTIVE,temp,1); 
00009a  2201              MOVS     r2,#1
00009c  a901              ADD      r1,sp,#4
00009e  2088              MOVS     r0,#0x88
0000a0  f7fffffe          BL       FT5206_WR_Reg
;;;90     	//读取版本号，参考值：0x3003
;;;91     	FT5206_RD_Reg(FT_ID_G_LIB_VERSION,&temp[0],2);  
0000a4  2202              MOVS     r2,#2
0000a6  a901              ADD      r1,sp,#4
0000a8  20a1              MOVS     r0,#0xa1
0000aa  f7fffffe          BL       FT5206_RD_Reg
;;;92     	if(temp[0]==0X30&&temp[1]==0X03)//版本:0X3003
0000ae  f89d0004          LDRB     r0,[sp,#4]
0000b2  2830              CMP      r0,#0x30
0000b4  d10e              BNE      |L1.212|
0000b6  f89d0005          LDRB     r0,[sp,#5]
0000ba  2803              CMP      r0,#3
0000bc  d10a              BNE      |L1.212|
;;;93     	{ 
;;;94     		printf("CTP ID:%x\r\n",((u16)temp[0]<<8)+temp[1]);
0000be  f89d0005          LDRB     r0,[sp,#5]
0000c2  f89d2004          LDRB     r2,[sp,#4]
0000c6  eb002102          ADD      r1,r0,r2,LSL #8
0000ca  a006              ADR      r0,|L1.228|
0000cc  f7fffffe          BL       __2printf
;;;95     		return 0;
0000d0  2000              MOVS     r0,#0
                  |L1.210|
;;;96     	} 
;;;97     	return 1;
;;;98     }
0000d2  bd1c              POP      {r2-r4,pc}
                  |L1.212|
0000d4  2001              MOVS     r0,#1                 ;97
0000d6  e7fc              B        |L1.210|
;;;99     const u16 FT5206_TPX_TBL[5]={FT_TP1_REG,FT_TP2_REG,FT_TP3_REG,FT_TP4_REG,FT_TP5_REG};
                          ENDP

                  |L1.216|
                          DCD      0x40011c00
                  |L1.220|
                          DCD      0x422381ac
                  |L1.224|
                          DCD      0x42238000
                  |L1.228|
0000e4  43545020          DCB      "CTP ID:%x\r\n",0
0000e8  49443a25
0000ec  780d0a00

                          AREA ||i.FT5206_RD_Reg||, CODE, READONLY, ALIGN=1

                  FT5206_RD_Reg PROC
;;;41     //len:读数据长度			  
;;;42     void FT5206_RD_Reg(u16 reg,u8 *buf,u8 len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;43     {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;44     	u8 i; 
;;;45      	CT_IIC_Start();	
00000a  f7fffffe          BL       CT_IIC_Start
;;;46      	CT_IIC_Send_Byte(FT_CMD_WR);   	//发送写命令 	 
00000e  2070              MOVS     r0,#0x70
000010  f7fffffe          BL       CT_IIC_Send_Byte
;;;47     	CT_IIC_Wait_Ack(); 	 										  		   
000014  f7fffffe          BL       CT_IIC_Wait_Ack
;;;48      	CT_IIC_Send_Byte(reg&0XFF);   	//发送低8位地址
000018  b2f0              UXTB     r0,r6
00001a  f7fffffe          BL       CT_IIC_Send_Byte
;;;49     	CT_IIC_Wait_Ack();  
00001e  f7fffffe          BL       CT_IIC_Wait_Ack
;;;50      	CT_IIC_Start();  	 	   
000022  f7fffffe          BL       CT_IIC_Start
;;;51     	CT_IIC_Send_Byte(FT_CMD_RD);   	//发送读命令		   
000026  2071              MOVS     r0,#0x71
000028  f7fffffe          BL       CT_IIC_Send_Byte
;;;52     	CT_IIC_Wait_Ack();	   
00002c  f7fffffe          BL       CT_IIC_Wait_Ack
;;;53     	for(i=0;i<len;i++)
000030  2400              MOVS     r4,#0
000032  e00b              B        |L2.76|
                  |L2.52|
;;;54     	{	   
;;;55         	buf[i]=CT_IIC_Read_Byte(i==(len-1)?0:1); //发数据	  
000034  1e69              SUBS     r1,r5,#1
000036  42a1              CMP      r1,r4
000038  d001              BEQ      |L2.62|
00003a  2101              MOVS     r1,#1
00003c  e000              B        |L2.64|
                  |L2.62|
00003e  2100              MOVS     r1,#0
                  |L2.64|
000040  4608              MOV      r0,r1
000042  f7fffffe          BL       CT_IIC_Read_Byte
000046  5538              STRB     r0,[r7,r4]
000048  1c60              ADDS     r0,r4,#1              ;53
00004a  b2c4              UXTB     r4,r0                 ;53
                  |L2.76|
00004c  42ac              CMP      r4,r5                 ;53
00004e  dbf1              BLT      |L2.52|
;;;56     	} 
;;;57         CT_IIC_Stop();//产生一个停止条件     
000050  f7fffffe          BL       CT_IIC_Stop
;;;58     } 
000054  e8bd81f0          POP      {r4-r8,pc}
;;;59     //初始化FT5206触摸屏
                          ENDP


                          AREA ||i.FT5206_Scan||, CODE, READONLY, ALIGN=2

                  FT5206_Scan PROC
;;;103    //0,触屏无触摸;1,触屏有触摸
;;;104    u8 FT5206_Scan(u8 mode)
000000  b571              PUSH     {r0,r4-r6,lr}
;;;105    {
000002  b081              SUB      sp,sp,#4
;;;106    	u8 buf[4];
;;;107    	u8 i=0;
000004  2400              MOVS     r4,#0
;;;108    	u8 res=0;
000006  2600              MOVS     r6,#0
;;;109    	u8 temp;
;;;110    	static u8 t=0;//控制查询间隔,从而降低CPU占用率   
;;;111    	t++;
000008  4861              LDR      r0,|L3.400|
00000a  7800              LDRB     r0,[r0,#0]  ; t
00000c  1c40              ADDS     r0,r0,#1
00000e  4960              LDR      r1,|L3.400|
000010  7008              STRB     r0,[r1,#0]
;;;112    	if((t%10)==0||t<10)//空闲时,每进入10次CTP_Scan函数才检测1次,从而节省CPU使用率
000012  4608              MOV      r0,r1
000014  7800              LDRB     r0,[r0,#0]  ; t
000016  210a              MOVS     r1,#0xa
000018  fb90f2f1          SDIV     r2,r0,r1
00001c  fb010012          MLS      r0,r1,r2,r0
000020  b118              CBZ      r0,|L3.42|
000022  485b              LDR      r0,|L3.400|
000024  7800              LDRB     r0,[r0,#0]  ; t
000026  280a              CMP      r0,#0xa
000028  da67              BGE      |L3.250|
                  |L3.42|
;;;113    	{
;;;114    		FT5206_RD_Reg(FT_REG_NUM_FINGER,&mode,1);//读取触摸点的状态  
00002a  2201              MOVS     r2,#1
00002c  a901              ADD      r1,sp,#4
00002e  2002              MOVS     r0,#2
000030  f7fffffe          BL       FT5206_RD_Reg
;;;115    		if((mode&0XF)&&((mode&0XF)<6))
000034  f89d0004          LDRB     r0,[sp,#4]
000038  f000000f          AND      r0,r0,#0xf
00003c  2800              CMP      r0,#0
00003e  d07e              BEQ      |L3.318|
000040  f89d0004          LDRB     r0,[sp,#4]
000044  f000000f          AND      r0,r0,#0xf
000048  2806              CMP      r0,#6
00004a  da78              BGE      |L3.318|
;;;116    		{
;;;117    			temp=0XFF<<(mode&0XF);//将点的个数转换为1的位数,匹配tp_dev.sta定义 
00004c  f89d0004          LDRB     r0,[sp,#4]
000050  f000010f          AND      r1,r0,#0xf
000054  20ff              MOVS     r0,#0xff
000056  4088              LSLS     r0,r0,r1
000058  b2c5              UXTB     r5,r0
;;;118    			tp_dev.sta=(~temp)|TP_PRES_DOWN|TP_CATH_PRES; 
00005a  43e8              MVNS     r0,r5
00005c  b2c0              UXTB     r0,r0
00005e  f04000c0          ORR      r0,r0,#0xc0
000062  494c              LDR      r1,|L3.404|
000064  f8810020          STRB     r0,[r1,#0x20]
;;;119    			for(i=0;i<5;i++)
000068  2400              MOVS     r4,#0
00006a  e05a              B        |L3.290|
                  |L3.108|
;;;120    			{
;;;121    				if(tp_dev.sta&(1<<i))	//触摸有效?
00006c  4849              LDR      r0,|L3.404|
00006e  f8900020          LDRB     r0,[r0,#0x20]  ; tp_dev
000072  2101              MOVS     r1,#1
000074  40a1              LSLS     r1,r1,r4
000076  4008              ANDS     r0,r0,r1
000078  b3f0              CBZ      r0,|L3.248|
;;;122    				{
;;;123    					FT5206_RD_Reg(FT5206_TPX_TBL[i],buf,4);	//读取XY坐标值 
00007a  4947              LDR      r1,|L3.408|
00007c  f8310014          LDRH     r0,[r1,r4,LSL #1]
000080  2204              MOVS     r2,#4
000082  4669              MOV      r1,sp
000084  f7fffffe          BL       FT5206_RD_Reg
;;;124    					if(tp_dev.touchtype&0X01)//横屏
000088  4842              LDR      r0,|L3.404|
00008a  f8900030          LDRB     r0,[r0,#0x30]  ; tp_dev
00008e  f0000001          AND      r0,r0,#1
000092  b1c0              CBZ      r0,|L3.198|
;;;125    					{
;;;126    						tp_dev.y[i]=((u16)(buf[0]&0X0F)<<8)+buf[1];
000094  f89d0001          LDRB     r0,[sp,#1]
000098  f89d1000          LDRB     r1,[sp,#0]
00009c  f001010f          AND      r1,r1,#0xf
0000a0  eb002001          ADD      r0,r0,r1,LSL #8
0000a4  493b              LDR      r1,|L3.404|
0000a6  3116              ADDS     r1,r1,#0x16
0000a8  f8210014          STRH     r0,[r1,r4,LSL #1]
;;;127    						tp_dev.x[i]=((u16)(buf[2]&0X0F)<<8)+buf[3];
0000ac  f89d0003          LDRB     r0,[sp,#3]
0000b0  f89d1002          LDRB     r1,[sp,#2]
0000b4  f001010f          AND      r1,r1,#0xf
0000b8  eb002101          ADD      r1,r0,r1,LSL #8
0000bc  4835              LDR      r0,|L3.404|
0000be  300c              ADDS     r0,r0,#0xc
0000c0  f8201014          STRH     r1,[r0,r4,LSL #1]
0000c4  e01d              B        |L3.258|
                  |L3.198|
;;;128    					}else
;;;129    					{
;;;130    						tp_dev.x[i]=480-(((u16)(buf[0]&0X0F)<<8)+buf[1]);
0000c6  f89d0001          LDRB     r0,[sp,#1]
0000ca  f89d1000          LDRB     r1,[sp,#0]
0000ce  f001010f          AND      r1,r1,#0xf
0000d2  eb002001          ADD      r0,r0,r1,LSL #8
0000d6  f5c070f0          RSB      r0,r0,#0x1e0
0000da  b281              UXTH     r1,r0
0000dc  482d              LDR      r0,|L3.404|
0000de  300c              ADDS     r0,r0,#0xc
0000e0  f8201014          STRH     r1,[r0,r4,LSL #1]
;;;131    						tp_dev.y[i]=((u16)(buf[2]&0X0F)<<8)+buf[3];
0000e4  f89d0003          LDRB     r0,[sp,#3]
0000e8  f89d1002          LDRB     r1,[sp,#2]
0000ec  f001010f          AND      r1,r1,#0xf
0000f0  eb002101          ADD      r1,r0,r1,LSL #8
0000f4  4827              LDR      r0,|L3.404|
0000f6  e001              B        |L3.252|
                  |L3.248|
0000f8  e011              B        |L3.286|
                  |L3.250|
0000fa  e020              B        |L3.318|
                  |L3.252|
0000fc  3016              ADDS     r0,r0,#0x16
0000fe  f8201014          STRH     r1,[r0,r4,LSL #1]
                  |L3.258|
;;;132    					}  
;;;133    					if((buf[0]&0XF0)!=0X80)tp_dev.x[i]=tp_dev.y[i]=0;//必须是contact事件，才认为有效
000102  f89d0000          LDRB     r0,[sp,#0]
000106  f00000f0          AND      r0,r0,#0xf0
00010a  2880              CMP      r0,#0x80
00010c  d007              BEQ      |L3.286|
00010e  2100              MOVS     r1,#0
000110  4820              LDR      r0,|L3.404|
000112  3016              ADDS     r0,r0,#0x16
000114  f8201014          STRH     r1,[r0,r4,LSL #1]
000118  380a              SUBS     r0,r0,#0xa
00011a  f8201014          STRH     r1,[r0,r4,LSL #1]
                  |L3.286|
00011e  1c60              ADDS     r0,r4,#1              ;119
000120  b2c4              UXTB     r4,r0                 ;119
                  |L3.290|
000122  2c05              CMP      r4,#5                 ;119
000124  dba2              BLT      |L3.108|
;;;134    					//printf("x[%d]:%d,y[%d]:%d\r\n",i,tp_dev.x[i],i,tp_dev.y[i]);
;;;135    				}			
;;;136    			} 
;;;137    			res=1;
000126  2601              MOVS     r6,#1
;;;138    			if(tp_dev.x[0]==0 && tp_dev.y[0]==0)mode=0;	//读到的数据都是0,则忽略此次数据
000128  481a              LDR      r0,|L3.404|
00012a  8980              LDRH     r0,[r0,#0xc]  ; tp_dev
00012c  b920              CBNZ     r0,|L3.312|
00012e  4819              LDR      r0,|L3.404|
000130  8ac0              LDRH     r0,[r0,#0x16]  ; tp_dev
000132  b908              CBNZ     r0,|L3.312|
000134  2000              MOVS     r0,#0
000136  9001              STR      r0,[sp,#4]
                  |L3.312|
;;;139    			t=0;		//触发一次,则会最少连续监测10次,从而提高命中率
000138  2000              MOVS     r0,#0
00013a  4915              LDR      r1,|L3.400|
00013c  7008              STRB     r0,[r1,#0]
                  |L3.318|
;;;140    		}
;;;141    	}
;;;142    	if((mode&0X1F)==0)//无触摸点按下
00013e  f89d0004          LDRB     r0,[sp,#4]
000142  f000001f          AND      r0,r0,#0x1f
000146  b9d0              CBNZ     r0,|L3.382|
;;;143    	{ 
;;;144    		if(tp_dev.sta&TP_PRES_DOWN)	//之前是被按下的
000148  4812              LDR      r0,|L3.404|
00014a  f8900020          LDRB     r0,[r0,#0x20]  ; tp_dev
00014e  f0000080          AND      r0,r0,#0x80
000152  b140              CBZ      r0,|L3.358|
;;;145    		{
;;;146    			tp_dev.sta&=~(1<<7);	//标记按键松开
000154  480f              LDR      r0,|L3.404|
000156  f8900020          LDRB     r0,[r0,#0x20]  ; tp_dev
00015a  f0200080          BIC      r0,r0,#0x80
00015e  490d              LDR      r1,|L3.404|
000160  f8810020          STRB     r0,[r1,#0x20]
000164  e00b              B        |L3.382|
                  |L3.358|
;;;147    		}else						//之前就没有被按下
;;;148    		{ 
;;;149    			tp_dev.x[0]=0xffff;
000166  f64f70ff          MOV      r0,#0xffff
00016a  490a              LDR      r1,|L3.404|
00016c  8188              STRH     r0,[r1,#0xc]
;;;150    			tp_dev.y[0]=0xffff;
00016e  82c8              STRH     r0,[r1,#0x16]
;;;151    			tp_dev.sta&=0XE0;	//清除点有效标记	
000170  4608              MOV      r0,r1
000172  f8900020          LDRB     r0,[r0,#0x20]  ; tp_dev
000176  f00000e0          AND      r0,r0,#0xe0
00017a  f8810020          STRB     r0,[r1,#0x20]
                  |L3.382|
;;;152    		}	 
;;;153    	} 	
;;;154    	if(t>240)t=10;//重新从10开始计数
00017e  4804              LDR      r0,|L3.400|
000180  7800              LDRB     r0,[r0,#0]  ; t
000182  28f0              CMP      r0,#0xf0
000184  dd02              BLE      |L3.396|
000186  200a              MOVS     r0,#0xa
000188  4901              LDR      r1,|L3.400|
00018a  7008              STRB     r0,[r1,#0]
                  |L3.396|
;;;155    	return res;
00018c  4630              MOV      r0,r6
;;;156    }
00018e  bd7c              POP      {r2-r6,pc}
;;;157     
                          ENDP

                  |L3.400|
                          DCD      t
                  |L3.404|
                          DCD      tp_dev
                  |L3.408|
                          DCD      FT5206_TPX_TBL

                          AREA ||i.FT5206_WR_Reg||, CODE, READONLY, ALIGN=1

                  FT5206_WR_Reg PROC
;;;19     //返回值:0,成功;1,失败.
;;;20     u8 FT5206_WR_Reg(u16 reg,u8 *buf,u8 len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;21     {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;22     	u8 i;
;;;23     	u8 ret=0;
00000a  f04f0800          MOV      r8,#0
;;;24     	CT_IIC_Start();	 
00000e  f7fffffe          BL       CT_IIC_Start
;;;25     	CT_IIC_Send_Byte(FT_CMD_WR);	//发送写命令 	 
000012  2070              MOVS     r0,#0x70
000014  f7fffffe          BL       CT_IIC_Send_Byte
;;;26     	CT_IIC_Wait_Ack(); 	 										  		   
000018  f7fffffe          BL       CT_IIC_Wait_Ack
;;;27     	CT_IIC_Send_Byte(reg&0XFF);   	//发送低8位地址
00001c  b2e8              UXTB     r0,r5
00001e  f7fffffe          BL       CT_IIC_Send_Byte
;;;28     	CT_IIC_Wait_Ack();  
000022  f7fffffe          BL       CT_IIC_Wait_Ack
;;;29     	for(i=0;i<len;i++)
000026  2400              MOVS     r4,#0
000028  e00b              B        |L4.66|
                  |L4.42|
;;;30     	{	   
;;;31         	CT_IIC_Send_Byte(buf[i]);  	//发数据
00002a  5d30              LDRB     r0,[r6,r4]
00002c  f7fffffe          BL       CT_IIC_Send_Byte
;;;32     		ret=CT_IIC_Wait_Ack();
000030  f7fffffe          BL       CT_IIC_Wait_Ack
000034  4680              MOV      r8,r0
;;;33     		if(ret)break;  
000036  f1b80f00          CMP      r8,#0
00003a  d000              BEQ      |L4.62|
00003c  e003              B        |L4.70|
                  |L4.62|
00003e  1c60              ADDS     r0,r4,#1              ;29
000040  b2c4              UXTB     r4,r0                 ;29
                  |L4.66|
000042  42bc              CMP      r4,r7                 ;29
000044  dbf1              BLT      |L4.42|
                  |L4.70|
000046  bf00              NOP      
;;;34     	}
;;;35         CT_IIC_Stop();					//产生一个停止条件	    
000048  f7fffffe          BL       CT_IIC_Stop
;;;36     	return ret; 
00004c  4640              MOV      r0,r8
;;;37     }
00004e  e8bd81f0          POP      {r4-r8,pc}
;;;38     //从FT5206读出一次数据
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=1

                  FT5206_TPX_TBL
000000  00030009          DCW      0x0003,0x0009
000004  000f0015          DCW      0x000f,0x0015
000008  001b              DCW      0x001b

                          AREA ||.data||, DATA, ALIGN=0

                  t
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\LCD_Driver\\ft5206.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_ft5206_c_c406f57d____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___8_ft5206_c_c406f57d____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_ft5206_c_c406f57d____REVSH|
#line 128
|__asm___8_ft5206_c_c406f57d____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

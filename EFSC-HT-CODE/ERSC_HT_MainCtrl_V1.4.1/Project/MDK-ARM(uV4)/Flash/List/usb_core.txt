; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\usb_core.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\usb_core.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\FatFS\src -I..\..\User\Mass_Storage\inc -I..\..\User\LCD_Driver -I..\..\User\SYSTEM\sys -I..\..\User\Debugprintf -I..\..\User\LogDebug -I..\..\User\app\inc -I..\..\User\app\src -I..\..\User\bsp\inc -I..\..\User\bsp\src -I.\RTE\_Flash -ID:\Keil_v5\ARM\Packs\ARM\CMSIS\5.5.1\CMSIS\Core\Include -ID:\Keil_v5\ARM\Packs\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=527 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\usb_core.crf ..\..\Libraries\STM32_USB-FS-Device_Driver\src\usb_core.c]
                          THUMB

                          AREA ||i.DataStageIn||, CODE, READONLY, ALIGN=2

                  DataStageIn PROC
;;;512    *******************************************************************************/
;;;513    void DataStageIn(void)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;514    {
;;;515      ENDPOINT_INFO *pEPinfo = &pInformation->Ctrl_Info;
000004  4828              LDR      r0,|L1.168|
000006  6800              LDR      r0,[r0,#0]  ; pInformation
000008  f1000510          ADD      r5,r0,#0x10
;;;516      uint32_t save_wLength = pEPinfo->Usb_wLength;
00000c  882e              LDRH     r6,[r5,#0]
;;;517      uint32_t ControlState = pInformation->ControlState;
00000e  4826              LDR      r0,|L1.168|
000010  6800              LDR      r0,[r0,#0]  ; pInformation
000012  7a07              LDRB     r7,[r0,#8]
;;;518    
;;;519      uint8_t *DataBuffer;
;;;520      uint32_t Length;
;;;521    
;;;522      if ((save_wLength == 0) && (ControlState == LAST_IN_DATA))
000014  b9d6              CBNZ     r6,|L1.76|
000016  2f04              CMP      r7,#4
000018  d118              BNE      |L1.76|
;;;523      {
;;;524        if(Data_Mul_MaxPacketSize == TRUE)
00001a  4824              LDR      r0,|L1.172|
00001c  7800              LDRB     r0,[r0,#0]  ; Data_Mul_MaxPacketSize
00001e  2801              CMP      r0,#1
000020  d10f              BNE      |L1.66|
;;;525        {
;;;526          /* No more data to send and empty packet */
;;;527          Send0LengthData();
000022  2100              MOVS     r1,#0
000024  4822              LDR      r0,|L1.176|
000026  6800              LDR      r0,[r0,#0]
000028  b280              UXTH     r0,r0
00002a  1c80              ADDS     r0,r0,#2
00002c  4a21              LDR      r2,|L1.180|
00002e  f8421010          STR      r1,[r2,r0,LSL #1]
000032  2030              MOVS     r0,#0x30
000034  4920              LDR      r1,|L1.184|
000036  8008              STRH     r0,[r1,#0]
;;;528          ControlState = LAST_IN_DATA;
000038  bf00              NOP      
;;;529          Data_Mul_MaxPacketSize = FALSE;
00003a  2000              MOVS     r0,#0
00003c  491b              LDR      r1,|L1.172|
00003e  7008              STRB     r0,[r1,#0]
000040  e003              B        |L1.74|
                  |L1.66|
;;;530        }
;;;531        else 
;;;532        {
;;;533          /* No more data to send so STALL the TX Status*/
;;;534          ControlState = WAIT_STATUS_OUT;
000042  2707              MOVS     r7,#7
;;;535    
;;;536        #ifdef STM32F10X_CL      
;;;537          PCD_EP_Read (ENDP0, 0, 0);
;;;538        #endif  /* STM32F10X_CL */ 
;;;539        
;;;540        #ifndef STM32F10X_CL 
;;;541          vSetEPTxStatus(EP_TX_STALL);
000044  2010              MOVS     r0,#0x10
000046  491c              LDR      r1,|L1.184|
000048  8008              STRH     r0,[r1,#0]
                  |L1.74|
;;;542        #endif  /* STM32F10X_CL */ 
;;;543        }
;;;544        
;;;545        goto Expect_Status_Out;
00004a  e027              B        |L1.156|
                  |L1.76|
;;;546      }
;;;547    
;;;548      Length = pEPinfo->PacketSize;
00004c  88ac              LDRH     r4,[r5,#4]
;;;549      ControlState = (save_wLength <= Length) ? LAST_IN_DATA : IN_DATA;
00004e  42a6              CMP      r6,r4
000050  d801              BHI      |L1.86|
000052  2004              MOVS     r0,#4
000054  e000              B        |L1.88|
                  |L1.86|
000056  2002              MOVS     r0,#2
                  |L1.88|
000058  4607              MOV      r7,r0
;;;550    
;;;551      if (Length > save_wLength)
00005a  42b4              CMP      r4,r6
00005c  d900              BLS      |L1.96|
;;;552      {
;;;553        Length = save_wLength;
00005e  4634              MOV      r4,r6
                  |L1.96|
;;;554      }
;;;555    
;;;556      DataBuffer = (*pEPinfo->CopyData)(Length);
000060  b2a0              UXTH     r0,r4
000062  68a9              LDR      r1,[r5,#8]
000064  4788              BLX      r1
000066  4680              MOV      r8,r0
;;;557    
;;;558    #ifdef STM32F10X_CL
;;;559      PCD_EP_Write (ENDP0, DataBuffer, Length);
;;;560    #else   
;;;561      UserToPMABufferCopy(DataBuffer, GetEPTxAddr(ENDP0), Length);
000068  2000              MOVS     r0,#0
00006a  f7fffffe          BL       GetEPTxAddr
00006e  4681              MOV      r9,r0
000070  b2a2              UXTH     r2,r4
000072  4649              MOV      r1,r9
000074  4640              MOV      r0,r8
000076  f7fffffe          BL       UserToPMABufferCopy
;;;562    #endif /* STM32F10X_CL */ 
;;;563    
;;;564      SetEPTxCount(ENDP0, Length);
00007a  b2a1              UXTH     r1,r4
00007c  2000              MOVS     r0,#0
00007e  f7fffffe          BL       SetEPTxCount
;;;565    
;;;566      pEPinfo->Usb_wLength -= Length;
000082  8828              LDRH     r0,[r5,#0]
000084  1b00              SUBS     r0,r0,r4
000086  8028              STRH     r0,[r5,#0]
;;;567      pEPinfo->Usb_wOffset += Length;
000088  8868              LDRH     r0,[r5,#2]
00008a  4420              ADD      r0,r0,r4
00008c  8068              STRH     r0,[r5,#2]
;;;568      vSetEPTxStatus(EP_TX_VALID);
00008e  2030              MOVS     r0,#0x30
000090  4909              LDR      r1,|L1.184|
000092  8008              STRH     r0,[r1,#0]
;;;569    
;;;570      USB_StatusOut();/* Expect the host to abort the data IN stage */
000094  0200              LSLS     r0,r0,#8
000096  4909              LDR      r1,|L1.188|
000098  8008              STRH     r0,[r1,#0]
;;;571    
;;;572    Expect_Status_Out:
00009a  bf00              NOP      
                  |L1.156|
;;;573      pInformation->ControlState = ControlState;
00009c  4902              LDR      r1,|L1.168|
00009e  6809              LDR      r1,[r1,#0]  ; pInformation
0000a0  720f              STRB     r7,[r1,#8]
;;;574    }
0000a2  e8bd87f0          POP      {r4-r10,pc}
;;;575    
                          ENDP

0000a6  0000              DCW      0x0000
                  |L1.168|
                          DCD      pInformation
                  |L1.172|
                          DCD      Data_Mul_MaxPacketSize
                  |L1.176|
                          DCD      0x40005c50
                  |L1.180|
                          DCD      0x40006000
                  |L1.184|
                          DCD      SaveTState
                  |L1.188|
                          DCD      SaveRState

                          AREA ||i.DataStageOut||, CODE, READONLY, ALIGN=2

                  DataStageOut PROC
;;;451    *******************************************************************************/
;;;452    void DataStageOut(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;453    {
;;;454      ENDPOINT_INFO *pEPinfo = &pInformation->Ctrl_Info;
000004  4828              LDR      r0,|L2.168|
000006  6800              LDR      r0,[r0,#0]  ; pInformation
000008  f1000410          ADD      r4,r0,#0x10
;;;455      uint32_t save_rLength;
;;;456    
;;;457      save_rLength = pEPinfo->Usb_rLength;
00000c  8826              LDRH     r6,[r4,#0]
;;;458    
;;;459      if (pEPinfo->CopyData && save_rLength)
00000e  68a0              LDR      r0,[r4,#8]
000010  b1c0              CBZ      r0,|L2.68|
000012  b1be              CBZ      r6,|L2.68|
;;;460      {
;;;461        uint8_t *Buffer;
;;;462        uint32_t Length;
;;;463    
;;;464        Length = pEPinfo->PacketSize;
000014  88a5              LDRH     r5,[r4,#4]
;;;465        if (Length > save_rLength)
000016  42b5              CMP      r5,r6
000018  d900              BLS      |L2.28|
;;;466        {
;;;467          Length = save_rLength;
00001a  4635              MOV      r5,r6
                  |L2.28|
;;;468        }
;;;469    
;;;470        Buffer = (*pEPinfo->CopyData)(Length);
00001c  b2a8              UXTH     r0,r5
00001e  68a1              LDR      r1,[r4,#8]
000020  4788              BLX      r1
000022  4607              MOV      r7,r0
;;;471        pEPinfo->Usb_rLength -= Length;
000024  8820              LDRH     r0,[r4,#0]
000026  1b40              SUBS     r0,r0,r5
000028  8020              STRH     r0,[r4,#0]
;;;472        pEPinfo->Usb_rOffset += Length;
00002a  8860              LDRH     r0,[r4,#2]
00002c  4428              ADD      r0,r0,r5
00002e  8060              STRH     r0,[r4,#2]
;;;473    
;;;474      #ifdef STM32F10X_CL  
;;;475        PCD_EP_Read(ENDP0, Buffer, Length); 
;;;476      #else  
;;;477        PMAToUserBufferCopy(Buffer, GetEPRxAddr(ENDP0), Length);
000030  2000              MOVS     r0,#0
000032  f7fffffe          BL       GetEPRxAddr
000036  4680              MOV      r8,r0
000038  b2aa              UXTH     r2,r5
00003a  4641              MOV      r1,r8
00003c  4638              MOV      r0,r7
00003e  f7fffffe          BL       PMAToUserBufferCopy
;;;478      #endif  /* STM32F10X_CL */
;;;479      }
000042  bf00              NOP      
                  |L2.68|
;;;480    
;;;481      if (pEPinfo->Usb_rLength != 0)
000044  8820              LDRH     r0,[r4,#0]
000046  b150              CBZ      r0,|L2.94|
;;;482      {
;;;483        vSetEPRxStatus(EP_RX_VALID);/* re-enable for next data reception */
000048  f44f5040          MOV      r0,#0x3000
00004c  4917              LDR      r1,|L2.172|
00004e  8008              STRH     r0,[r1,#0]
;;;484        SetEPTxCount(ENDP0, 0);
000050  2100              MOVS     r1,#0
000052  4608              MOV      r0,r1
000054  f7fffffe          BL       SetEPTxCount
;;;485        vSetEPTxStatus(EP_TX_VALID);/* Expect the host to abort the data OUT stage */
000058  2030              MOVS     r0,#0x30
00005a  4915              LDR      r1,|L2.176|
00005c  8008              STRH     r0,[r1,#0]
                  |L2.94|
;;;486      }
;;;487      /* Set the next State*/
;;;488      if (pEPinfo->Usb_rLength >= pEPinfo->PacketSize)
00005e  8820              LDRH     r0,[r4,#0]
000060  88a1              LDRH     r1,[r4,#4]
000062  4288              CMP      r0,r1
000064  db04              BLT      |L2.112|
;;;489      {
;;;490        pInformation->ControlState = OUT_DATA;
000066  2003              MOVS     r0,#3
000068  490f              LDR      r1,|L2.168|
00006a  6809              LDR      r1,[r1,#0]  ; pInformation
00006c  7208              STRB     r0,[r1,#8]
00006e  e018              B        |L2.162|
                  |L2.112|
;;;491      }
;;;492      else
;;;493      {
;;;494        if (pEPinfo->Usb_rLength > 0)
000070  8820              LDRH     r0,[r4,#0]
000072  2800              CMP      r0,#0
000074  dd04              BLE      |L2.128|
;;;495        {
;;;496          pInformation->ControlState = LAST_OUT_DATA;
000076  2005              MOVS     r0,#5
000078  490b              LDR      r1,|L2.168|
00007a  6809              LDR      r1,[r1,#0]  ; pInformation
00007c  7208              STRB     r0,[r1,#8]
00007e  e010              B        |L2.162|
                  |L2.128|
;;;497        }
;;;498        else if (pEPinfo->Usb_rLength == 0)
000080  8820              LDRH     r0,[r4,#0]
000082  b970              CBNZ     r0,|L2.162|
;;;499        {
;;;500          pInformation->ControlState = WAIT_STATUS_IN;
000084  2006              MOVS     r0,#6
000086  4908              LDR      r1,|L2.168|
000088  6809              LDR      r1,[r1,#0]  ; pInformation
00008a  7208              STRB     r0,[r1,#8]
;;;501          USB_StatusIn();
00008c  2100              MOVS     r1,#0
00008e  4809              LDR      r0,|L2.180|
000090  6800              LDR      r0,[r0,#0]
000092  b280              UXTH     r0,r0
000094  1c80              ADDS     r0,r0,#2
000096  4a08              LDR      r2,|L2.184|
000098  f8421010          STR      r1,[r2,r0,LSL #1]
00009c  2030              MOVS     r0,#0x30
00009e  4904              LDR      r1,|L2.176|
0000a0  8008              STRH     r0,[r1,#0]
                  |L2.162|
;;;502        }
;;;503      }
;;;504    }
0000a2  e8bd81f0          POP      {r4-r8,pc}
;;;505    
                          ENDP

0000a6  0000              DCW      0x0000
                  |L2.168|
                          DCD      pInformation
                  |L2.172|
                          DCD      SaveRState
                  |L2.176|
                          DCD      SaveTState
                  |L2.180|
                          DCD      0x40005c50
                  |L2.184|
                          DCD      0x40006000

                          AREA ||i.Data_Setup0||, CODE, READONLY, ALIGN=2

                  Data_Setup0 PROC
;;;709    *******************************************************************************/
;;;710    void Data_Setup0(void)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;711    {
;;;712      uint8_t *(*CopyRoutine)(uint16_t);
;;;713      RESULT Result;
;;;714      uint32_t Request_No = pInformation->USBbRequest;
000004  489b              LDR      r0,|L3.628|
000006  6800              LDR      r0,[r0,#0]  ; pInformation
000008  7845              LDRB     r5,[r0,#1]
;;;715    
;;;716      uint32_t Related_Endpoint, Reserved;
;;;717      uint32_t wOffset, Status;
;;;718    
;;;719    
;;;720    
;;;721      CopyRoutine = NULL;
00000a  2700              MOVS     r7,#0
;;;722      wOffset = 0;
00000c  46ba              MOV      r10,r7
;;;723    
;;;724      /*GET DESCRIPTOR*/
;;;725      if (Request_No == GET_DESCRIPTOR)
00000e  2d06              CMP      r5,#6
000010  d11b              BNE      |L3.74|
;;;726      {
;;;727        if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
000012  4898              LDR      r0,|L3.628|
000014  6800              LDR      r0,[r0,#0]  ; pInformation
000016  7800              LDRB     r0,[r0,#0]
000018  f000007f          AND      r0,r0,#0x7f
00001c  2800              CMP      r0,#0
00001e  d113              BNE      |L3.72|
;;;728        {
;;;729          uint8_t wValue1 = pInformation->USBwValue1;
000020  4994              LDR      r1,|L3.628|
000022  6809              LDR      r1,[r1,#0]  ; pInformation
000024  7888              LDRB     r0,[r1,#2]
;;;730          if (wValue1 == DEVICE_DESCRIPTOR)
000026  2801              CMP      r0,#1
000028  d103              BNE      |L3.50|
;;;731          {
;;;732            CopyRoutine = pProperty->GetDeviceDescriptor;
00002a  4993              LDR      r1,|L3.632|
00002c  6809              LDR      r1,[r1,#0]  ; pProperty
00002e  69cf              LDR      r7,[r1,#0x1c]
000030  e00a              B        |L3.72|
                  |L3.50|
;;;733          }
;;;734          else if (wValue1 == CONFIG_DESCRIPTOR)
000032  2802              CMP      r0,#2
000034  d103              BNE      |L3.62|
;;;735          {
;;;736            CopyRoutine = pProperty->GetConfigDescriptor;
000036  4990              LDR      r1,|L3.632|
000038  6809              LDR      r1,[r1,#0]  ; pProperty
00003a  6a0f              LDR      r7,[r1,#0x20]
00003c  e004              B        |L3.72|
                  |L3.62|
;;;737          }
;;;738          else if (wValue1 == STRING_DESCRIPTOR)
00003e  2803              CMP      r0,#3
000040  d102              BNE      |L3.72|
;;;739          {
;;;740            CopyRoutine = pProperty->GetStringDescriptor;
000042  498d              LDR      r1,|L3.632|
000044  6809              LDR      r1,[r1,#0]  ; pProperty
000046  6a4f              LDR      r7,[r1,#0x24]
                  |L3.72|
;;;741          }  /* End of GET_DESCRIPTOR */
;;;742        }
000048  e094              B        |L3.372|
                  |L3.74|
;;;743      }
;;;744    
;;;745      /*GET STATUS*/
;;;746      else if ((Request_No == GET_STATUS) && (pInformation->USBwValue == 0)
00004a  2d00              CMP      r5,#0
00004c  d164              BNE      |L3.280|
00004e  4889              LDR      r0,|L3.628|
000050  6800              LDR      r0,[r0,#0]  ; pInformation
000052  8840              LDRH     r0,[r0,#2]
000054  2800              CMP      r0,#0
000056  d15f              BNE      |L3.280|
;;;747               && (pInformation->USBwLength == 0x0002)
000058  4886              LDR      r0,|L3.628|
00005a  6800              LDR      r0,[r0,#0]  ; pInformation
00005c  88c0              LDRH     r0,[r0,#6]
00005e  2802              CMP      r0,#2
000060  d15a              BNE      |L3.280|
;;;748               && (pInformation->USBwIndex1 == 0))
000062  4884              LDR      r0,|L3.628|
000064  6800              LDR      r0,[r0,#0]  ; pInformation
000066  7900              LDRB     r0,[r0,#4]
000068  2800              CMP      r0,#0
00006a  d155              BNE      |L3.280|
;;;749      {
;;;750        /* GET STATUS for Device*/
;;;751        if ((Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
00006c  4881              LDR      r0,|L3.628|
00006e  6800              LDR      r0,[r0,#0]  ; pInformation
000070  7800              LDRB     r0,[r0,#0]
000072  f000007f          AND      r0,r0,#0x7f
000076  b928              CBNZ     r0,|L3.132|
;;;752            && (pInformation->USBwIndex == 0))
000078  487e              LDR      r0,|L3.628|
00007a  6800              LDR      r0,[r0,#0]  ; pInformation
00007c  8880              LDRH     r0,[r0,#4]
00007e  b908              CBNZ     r0,|L3.132|
;;;753        {
;;;754          CopyRoutine = Standard_GetStatus;
000080  4f7e              LDR      r7,|L3.636|
000082  e077              B        |L3.372|
                  |L3.132|
;;;755        }
;;;756    
;;;757        /* GET STATUS for Interface*/
;;;758        else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
000084  487b              LDR      r0,|L3.628|
000086  6800              LDR      r0,[r0,#0]  ; pInformation
000088  7800              LDRB     r0,[r0,#0]
00008a  f000007f          AND      r0,r0,#0x7f
00008e  2801              CMP      r0,#1
000090  d110              BNE      |L3.180|
;;;759        {
;;;760          if (((*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, 0) == USB_SUCCESS)
000092  4978              LDR      r1,|L3.628|
000094  6809              LDR      r1,[r1,#0]  ; pInformation
000096  7948              LDRB     r0,[r1,#5]
000098  4977              LDR      r1,|L3.632|
00009a  6809              LDR      r1,[r1,#0]  ; pProperty
00009c  698a              LDR      r2,[r1,#0x18]
00009e  2100              MOVS     r1,#0
0000a0  4790              BLX      r2
0000a2  2800              CMP      r0,#0
0000a4  d166              BNE      |L3.372|
;;;761              && (pInformation->Current_Configuration != 0))
0000a6  4873              LDR      r0,|L3.628|
0000a8  6800              LDR      r0,[r0,#0]  ; pInformation
0000aa  7a80              LDRB     r0,[r0,#0xa]
0000ac  2800              CMP      r0,#0
0000ae  d061              BEQ      |L3.372|
;;;762          {
;;;763            CopyRoutine = Standard_GetStatus;
0000b0  4f72              LDR      r7,|L3.636|
0000b2  e05f              B        |L3.372|
                  |L3.180|
;;;764          }
;;;765        }
;;;766    
;;;767        /* GET STATUS for EndPoint*/
;;;768        else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
0000b4  486f              LDR      r0,|L3.628|
0000b6  6800              LDR      r0,[r0,#0]  ; pInformation
0000b8  7800              LDRB     r0,[r0,#0]
0000ba  f000007f          AND      r0,r0,#0x7f
0000be  2802              CMP      r0,#2
0000c0  d158              BNE      |L3.372|
;;;769        {
;;;770          Related_Endpoint = (pInformation->USBwIndex0 & 0x0f);
0000c2  486c              LDR      r0,|L3.628|
0000c4  6800              LDR      r0,[r0,#0]  ; pInformation
0000c6  7940              LDRB     r0,[r0,#5]
0000c8  f000060f          AND      r6,r0,#0xf
;;;771          Reserved = pInformation->USBwIndex0 & 0x70;
0000cc  4869              LDR      r0,|L3.628|
0000ce  6800              LDR      r0,[r0,#0]  ; pInformation
0000d0  7940              LDRB     r0,[r0,#5]
0000d2  f0000970          AND      r9,r0,#0x70
;;;772    
;;;773          if (ValBit(pInformation->USBwIndex0, 7))
0000d6  4867              LDR      r0,|L3.628|
0000d8  6800              LDR      r0,[r0,#0]  ; pInformation
0000da  7940              LDRB     r0,[r0,#5]
0000dc  f0000080          AND      r0,r0,#0x80
0000e0  b138              CBZ      r0,|L3.242|
;;;774          {
;;;775            /*Get Status of endpoint & stall the request if the related_ENdpoint
;;;776            is Disabled*/
;;;777            Status = _GetEPTxStatus(Related_Endpoint);
0000e2  4967              LDR      r1,|L3.640|
0000e4  eb010086          ADD      r0,r1,r6,LSL #2
0000e8  f8d00c00          LDR      r0,[r0,#0xc00]
0000ec  f0000830          AND      r8,r0,#0x30
0000f0  e006              B        |L3.256|
                  |L3.242|
;;;778          }
;;;779          else
;;;780          {
;;;781            Status = _GetEPRxStatus(Related_Endpoint);
0000f2  4963              LDR      r1,|L3.640|
0000f4  eb010086          ADD      r0,r1,r6,LSL #2
0000f8  f8d00c00          LDR      r0,[r0,#0xc00]
0000fc  f4005840          AND      r8,r0,#0x3000
                  |L3.256|
;;;782          }
;;;783    
;;;784          if ((Related_Endpoint < Device_Table.Total_Endpoint) && (Reserved == 0)
000100  4860              LDR      r0,|L3.644|
000102  7800              LDRB     r0,[r0,#0]  ; Device_Table
000104  42b0              CMP      r0,r6
000106  d935              BLS      |L3.372|
000108  f1b90f00          CMP      r9,#0
00010c  d132              BNE      |L3.372|
;;;785              && (Status != 0))
00010e  f1b80f00          CMP      r8,#0
000112  d02f              BEQ      |L3.372|
;;;786          {
;;;787            CopyRoutine = Standard_GetStatus;
000114  4f59              LDR      r7,|L3.636|
000116  e02d              B        |L3.372|
                  |L3.280|
;;;788          }
;;;789        }
;;;790    
;;;791      }
;;;792    
;;;793      /*GET CONFIGURATION*/
;;;794      else if (Request_No == GET_CONFIGURATION)
000118  2d08              CMP      r5,#8
00011a  d107              BNE      |L3.300|
;;;795      {
;;;796        if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
00011c  4855              LDR      r0,|L3.628|
00011e  6800              LDR      r0,[r0,#0]  ; pInformation
000120  7800              LDRB     r0,[r0,#0]
000122  f000007f          AND      r0,r0,#0x7f
000126  bb28              CBNZ     r0,|L3.372|
;;;797        {
;;;798          CopyRoutine = Standard_GetConfiguration;
000128  4f57              LDR      r7,|L3.648|
00012a  e023              B        |L3.372|
                  |L3.300|
;;;799        }
;;;800      }
;;;801      /*GET INTERFACE*/
;;;802      else if (Request_No == GET_INTERFACE)
00012c  2d0a              CMP      r5,#0xa
00012e  d121              BNE      |L3.372|
;;;803      {
;;;804        if ((Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
000130  4850              LDR      r0,|L3.628|
000132  6800              LDR      r0,[r0,#0]  ; pInformation
000134  7800              LDRB     r0,[r0,#0]
000136  f000007f          AND      r0,r0,#0x7f
00013a  2801              CMP      r0,#1
00013c  d11a              BNE      |L3.372|
;;;805            && (pInformation->Current_Configuration != 0) && (pInformation->USBwValue == 0)
00013e  484d              LDR      r0,|L3.628|
000140  6800              LDR      r0,[r0,#0]  ; pInformation
000142  7a80              LDRB     r0,[r0,#0xa]
000144  b1b0              CBZ      r0,|L3.372|
000146  484b              LDR      r0,|L3.628|
000148  6800              LDR      r0,[r0,#0]  ; pInformation
00014a  8840              LDRH     r0,[r0,#2]
00014c  b990              CBNZ     r0,|L3.372|
;;;806            && (pInformation->USBwIndex1 == 0) && (pInformation->USBwLength == 0x0001)
00014e  4849              LDR      r0,|L3.628|
000150  6800              LDR      r0,[r0,#0]  ; pInformation
000152  7900              LDRB     r0,[r0,#4]
000154  b970              CBNZ     r0,|L3.372|
000156  4847              LDR      r0,|L3.628|
000158  6800              LDR      r0,[r0,#0]  ; pInformation
00015a  88c0              LDRH     r0,[r0,#6]
00015c  2801              CMP      r0,#1
00015e  d109              BNE      |L3.372|
;;;807            && ((*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, 0) == USB_SUCCESS))
000160  4944              LDR      r1,|L3.628|
000162  6809              LDR      r1,[r1,#0]  ; pInformation
000164  7948              LDRB     r0,[r1,#5]
000166  4944              LDR      r1,|L3.632|
000168  6809              LDR      r1,[r1,#0]  ; pProperty
00016a  698a              LDR      r2,[r1,#0x18]
00016c  2100              MOVS     r1,#0
00016e  4790              BLX      r2
000170  b900              CBNZ     r0,|L3.372|
;;;808        {
;;;809          CopyRoutine = Standard_GetInterface;
000172  4f46              LDR      r7,|L3.652|
                  |L3.372|
;;;810        }
;;;811    
;;;812      }
;;;813      
;;;814      if (CopyRoutine)
000174  b157              CBZ      r7,|L3.396|
;;;815      {
;;;816        pInformation->Ctrl_Info.Usb_wOffset = wOffset;
000176  483f              LDR      r0,|L3.628|
000178  6800              LDR      r0,[r0,#0]  ; pInformation
00017a  f8a0a012          STRH     r10,[r0,#0x12]
;;;817        pInformation->Ctrl_Info.CopyData = CopyRoutine;
00017e  483d              LDR      r0,|L3.628|
000180  6800              LDR      r0,[r0,#0]  ; pInformation
000182  6187              STR      r7,[r0,#0x18]
;;;818        /* sb in the original the cast to word was directly */
;;;819        /* now the cast is made step by step */
;;;820        (*CopyRoutine)(0);
000184  2000              MOVS     r0,#0
000186  47b8              BLX      r7
;;;821        Result = USB_SUCCESS;
000188  2400              MOVS     r4,#0
00018a  e00f              B        |L3.428|
                  |L3.396|
;;;822      }
;;;823      else
;;;824      {
;;;825        Result = (*pProperty->Class_Data_Setup)(pInformation->USBbRequest);
00018c  4a39              LDR      r2,|L3.628|
00018e  6812              LDR      r2,[r2,#0]  ; pInformation
000190  7850              LDRB     r0,[r2,#1]
000192  4a39              LDR      r2,|L3.632|
000194  6812              LDR      r2,[r2,#0]  ; pProperty
000196  6911              LDR      r1,[r2,#0x10]
000198  4788              BLX      r1
00019a  4604              MOV      r4,r0
;;;826        if (Result == USB_NOT_READY)
00019c  2c03              CMP      r4,#3
00019e  d105              BNE      |L3.428|
;;;827        {
;;;828          pInformation->ControlState = PAUSE;
0001a0  2009              MOVS     r0,#9
0001a2  4934              LDR      r1,|L3.628|
0001a4  6809              LDR      r1,[r1,#0]  ; pInformation
0001a6  7208              STRB     r0,[r1,#8]
                  |L3.424|
;;;829          return;
;;;830        }
;;;831      }
;;;832    
;;;833      if (pInformation->Ctrl_Info.Usb_wLength == 0xFFFF)
;;;834      {
;;;835        /* Data is not ready, wait it */
;;;836        pInformation->ControlState = PAUSE;
;;;837        return;
;;;838      }
;;;839      if ((Result == USB_UNSUPPORT) || (pInformation->Ctrl_Info.Usb_wLength == 0))
;;;840      {
;;;841        /* Unsupported request */
;;;842        pInformation->ControlState = STALLED;
;;;843        return;
;;;844      }
;;;845    
;;;846    
;;;847      if (ValBit(pInformation->USBbmRequestType, 7))
;;;848      {
;;;849        /* Device ==> Host */
;;;850        __IO uint32_t wLength = pInformation->USBwLength;
;;;851         
;;;852        /* Restrict the data length to be the one host asks for */
;;;853        if (pInformation->Ctrl_Info.Usb_wLength > wLength)
;;;854        {
;;;855          pInformation->Ctrl_Info.Usb_wLength = wLength;
;;;856        }
;;;857        
;;;858        else if (pInformation->Ctrl_Info.Usb_wLength < pInformation->USBwLength)
;;;859        {
;;;860          if (pInformation->Ctrl_Info.Usb_wLength < pProperty->MaxPacketSize)
;;;861          {
;;;862            Data_Mul_MaxPacketSize = FALSE;
;;;863          }
;;;864          else if ((pInformation->Ctrl_Info.Usb_wLength % pProperty->MaxPacketSize) == 0)
;;;865          {
;;;866            Data_Mul_MaxPacketSize = TRUE;
;;;867          }
;;;868        }   
;;;869    
;;;870        pInformation->Ctrl_Info.PacketSize = pProperty->MaxPacketSize;
;;;871        DataStageIn();
;;;872      }
;;;873      else
;;;874      {
;;;875        pInformation->ControlState = OUT_DATA;
;;;876        vSetEPRxStatus(EP_RX_VALID); /* enable for next data reception */
;;;877      }
;;;878    
;;;879      return;
;;;880    }
0001a8  e8bd8ff8          POP      {r3-r11,pc}
                  |L3.428|
0001ac  4831              LDR      r0,|L3.628|
0001ae  6800              LDR      r0,[r0,#0]            ;833  ; pInformation
0001b0  8a00              LDRH     r0,[r0,#0x10]         ;833
0001b2  f64f71ff          MOV      r1,#0xffff            ;833
0001b6  4288              CMP      r0,r1                 ;833
0001b8  d104              BNE      |L3.452|
0001ba  2009              MOVS     r0,#9                 ;836
0001bc  492d              LDR      r1,|L3.628|
0001be  6809              LDR      r1,[r1,#0]            ;836  ; pInformation
0001c0  7208              STRB     r0,[r1,#8]            ;836
0001c2  e7f1              B        |L3.424|
                  |L3.452|
0001c4  2c02              CMP      r4,#2                 ;839
0001c6  d003              BEQ      |L3.464|
0001c8  482a              LDR      r0,|L3.628|
0001ca  6800              LDR      r0,[r0,#0]            ;839  ; pInformation
0001cc  8a00              LDRH     r0,[r0,#0x10]         ;839
0001ce  b920              CBNZ     r0,|L3.474|
                  |L3.464|
0001d0  2008              MOVS     r0,#8                 ;842
0001d2  4928              LDR      r1,|L3.628|
0001d4  6809              LDR      r1,[r1,#0]            ;842  ; pInformation
0001d6  7208              STRB     r0,[r1,#8]            ;842
0001d8  e7e6              B        |L3.424|
                  |L3.474|
0001da  4826              LDR      r0,|L3.628|
0001dc  6800              LDR      r0,[r0,#0]            ;847  ; pInformation
0001de  7800              LDRB     r0,[r0,#0]            ;847
0001e0  f0000080          AND      r0,r0,#0x80           ;847
0001e4  b3e0              CBZ      r0,|L3.608|
0001e6  4823              LDR      r0,|L3.628|
0001e8  6800              LDR      r0,[r0,#0]            ;850  ; pInformation
0001ea  88c0              LDRH     r0,[r0,#6]            ;850
0001ec  9000              STR      r0,[sp,#0]            ;850
0001ee  4821              LDR      r0,|L3.628|
0001f0  6800              LDR      r0,[r0,#0]            ;853  ; pInformation
0001f2  8a00              LDRH     r0,[r0,#0x10]         ;853
0001f4  9900              LDR      r1,[sp,#0]            ;853
0001f6  4288              CMP      r0,r1                 ;853
0001f8  d904              BLS      |L3.516|
0001fa  491e              LDR      r1,|L3.628|
0001fc  9800              LDR      r0,[sp,#0]            ;855
0001fe  6809              LDR      r1,[r1,#0]            ;855  ; pInformation
000200  8208              STRH     r0,[r1,#0x10]         ;855
000202  e023              B        |L3.588|
                  |L3.516|
000204  481b              LDR      r0,|L3.628|
000206  6800              LDR      r0,[r0,#0]            ;858  ; pInformation
000208  8a00              LDRH     r0,[r0,#0x10]         ;858
00020a  491a              LDR      r1,|L3.628|
00020c  6809              LDR      r1,[r1,#0]            ;858  ; pInformation
00020e  88c9              LDRH     r1,[r1,#6]            ;858
000210  4288              CMP      r0,r1                 ;858
000212  da1b              BGE      |L3.588|
000214  4817              LDR      r0,|L3.628|
000216  6800              LDR      r0,[r0,#0]            ;860  ; pInformation
000218  8a00              LDRH     r0,[r0,#0x10]         ;860
00021a  4917              LDR      r1,|L3.632|
00021c  6809              LDR      r1,[r1,#0]            ;860  ; pProperty
00021e  f891102c          LDRB     r1,[r1,#0x2c]         ;860
000222  4288              CMP      r0,r1                 ;860
000224  da03              BGE      |L3.558|
000226  2000              MOVS     r0,#0                 ;862
000228  4919              LDR      r1,|L3.656|
00022a  7008              STRB     r0,[r1,#0]            ;862
00022c  e00e              B        |L3.588|
                  |L3.558|
00022e  4811              LDR      r0,|L3.628|
000230  6800              LDR      r0,[r0,#0]            ;864  ; pInformation
000232  8a00              LDRH     r0,[r0,#0x10]         ;864
000234  4910              LDR      r1,|L3.632|
000236  6809              LDR      r1,[r1,#0]            ;864  ; pProperty
000238  f891102c          LDRB     r1,[r1,#0x2c]         ;864
00023c  fb90f2f1          SDIV     r2,r0,r1              ;864
000240  fb010012          MLS      r0,r1,r2,r0           ;864
000244  b910              CBNZ     r0,|L3.588|
000246  2001              MOVS     r0,#1                 ;866
000248  4911              LDR      r1,|L3.656|
00024a  7008              STRB     r0,[r1,#0]            ;866
                  |L3.588|
00024c  480a              LDR      r0,|L3.632|
00024e  6800              LDR      r0,[r0,#0]            ;870  ; pProperty
000250  f890102c          LDRB     r1,[r0,#0x2c]         ;870
000254  4807              LDR      r0,|L3.628|
000256  6800              LDR      r0,[r0,#0]            ;870  ; pInformation
000258  8281              STRH     r1,[r0,#0x14]         ;870
00025a  f7fffffe          BL       DataStageIn
00025e  e007              B        |L3.624|
                  |L3.608|
000260  e7ff              B        |L3.610|
                  |L3.610|
000262  2003              MOVS     r0,#3                 ;875
000264  4903              LDR      r1,|L3.628|
000266  6809              LDR      r1,[r1,#0]            ;875  ; pInformation
000268  7208              STRB     r0,[r1,#8]            ;875
00026a  0300              LSLS     r0,r0,#12             ;876
00026c  4909              LDR      r1,|L3.660|
00026e  8008              STRH     r0,[r1,#0]            ;876
                  |L3.624|
000270  bf00              NOP                            ;879
000272  e799              B        |L3.424|
;;;881    
                          ENDP

                  |L3.628|
                          DCD      pInformation
                  |L3.632|
                          DCD      pProperty
                  |L3.636|
                          DCD      Standard_GetStatus
                  |L3.640|
                          DCD      0x40005000
                  |L3.644|
                          DCD      Device_Table
                  |L3.648|
                          DCD      Standard_GetConfiguration
                  |L3.652|
                          DCD      Standard_GetInterface
                  |L3.656|
                          DCD      Data_Mul_MaxPacketSize
                  |L3.660|
                          DCD      SaveRState

                          AREA ||i.In0_Process||, CODE, READONLY, ALIGN=2

                  In0_Process PROC
;;;942    *******************************************************************************/
;;;943    uint8_t In0_Process(void)
000000  b510              PUSH     {r4,lr}
;;;944    {
;;;945      uint32_t ControlState = pInformation->ControlState;
000002  4818              LDR      r0,|L4.100|
000004  6800              LDR      r0,[r0,#0]  ; pInformation
000006  7a04              LDRB     r4,[r0,#8]
;;;946    
;;;947      if ((ControlState == IN_DATA) || (ControlState == LAST_IN_DATA))
000008  2c02              CMP      r4,#2
00000a  d001              BEQ      |L4.16|
00000c  2c04              CMP      r4,#4
00000e  d105              BNE      |L4.28|
                  |L4.16|
;;;948      {
;;;949        DataStageIn();
000010  f7fffffe          BL       DataStageIn
;;;950        /* ControlState may be changed outside the function */
;;;951        ControlState = pInformation->ControlState;
000014  4813              LDR      r0,|L4.100|
000016  6800              LDR      r0,[r0,#0]  ; pInformation
000018  7a04              LDRB     r4,[r0,#8]
00001a  e01c              B        |L4.86|
                  |L4.28|
;;;952      }
;;;953    
;;;954      else if (ControlState == WAIT_STATUS_IN)
00001c  2c06              CMP      r4,#6
00001e  d119              BNE      |L4.84|
;;;955      {
;;;956        if ((pInformation->USBbRequest == SET_ADDRESS) &&
000020  4810              LDR      r0,|L4.100|
000022  6800              LDR      r0,[r0,#0]  ; pInformation
000024  7840              LDRB     r0,[r0,#1]
000026  2805              CMP      r0,#5
000028  d10e              BNE      |L4.72|
;;;957            (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT)))
00002a  480e              LDR      r0,|L4.100|
00002c  6800              LDR      r0,[r0,#0]  ; pInformation
00002e  7800              LDRB     r0,[r0,#0]
000030  f000007f          AND      r0,r0,#0x7f
000034  b940              CBNZ     r0,|L4.72|
;;;958        {
;;;959          SetDeviceAddress(pInformation->USBwValue0);
000036  490b              LDR      r1,|L4.100|
000038  6809              LDR      r1,[r1,#0]  ; pInformation
00003a  78c8              LDRB     r0,[r1,#3]
00003c  f7fffffe          BL       SetDeviceAddress
;;;960          pUser_Standard_Requests->User_SetDeviceAddress();
000040  4909              LDR      r1,|L4.104|
000042  6809              LDR      r1,[r1,#0]  ; pUser_Standard_Requests
000044  6a08              LDR      r0,[r1,#0x20]
000046  4780              BLX      r0
                  |L4.72|
;;;961        }
;;;962        (*pProperty->Process_Status_IN)();
000048  4908              LDR      r1,|L4.108|
00004a  6809              LDR      r1,[r1,#0]  ; pProperty
00004c  6888              LDR      r0,[r1,#8]
00004e  4780              BLX      r0
;;;963        ControlState = STALLED;
000050  2408              MOVS     r4,#8
000052  e000              B        |L4.86|
                  |L4.84|
;;;964      }
;;;965    
;;;966      else
;;;967      {
;;;968        ControlState = STALLED;
000054  2408              MOVS     r4,#8
                  |L4.86|
;;;969      }
;;;970    
;;;971      pInformation->ControlState = ControlState;
000056  4903              LDR      r1,|L4.100|
000058  6809              LDR      r1,[r1,#0]  ; pInformation
00005a  720c              STRB     r4,[r1,#8]
;;;972    
;;;973      return Post0_Process();
00005c  f7fffffe          BL       Post0_Process
;;;974    }
000060  bd10              POP      {r4,pc}
;;;975    
                          ENDP

000062  0000              DCW      0x0000
                  |L4.100|
                          DCD      pInformation
                  |L4.104|
                          DCD      pUser_Standard_Requests
                  |L4.108|
                          DCD      pProperty

                          AREA ||i.NOP_Process||, CODE, READONLY, ALIGN=1

                  NOP_Process PROC
;;;1093   *******************************************************************************/
;;;1094   void NOP_Process(void)
000000  4770              BX       lr
;;;1095   {
;;;1096   }
;;;1097   
                          ENDP


                          AREA ||i.NoData_Setup0||, CODE, READONLY, ALIGN=2

                  NoData_Setup0 PROC
;;;582    *******************************************************************************/
;;;583    void NoData_Setup0(void)
000000  b570              PUSH     {r4-r6,lr}
;;;584    {
;;;585      RESULT Result = USB_UNSUPPORT;
000002  2602              MOVS     r6,#2
;;;586      uint32_t RequestNo = pInformation->USBbRequest;
000004  4847              LDR      r0,|L6.292|
000006  6800              LDR      r0,[r0,#0]  ; pInformation
000008  7844              LDRB     r4,[r0,#1]
;;;587      uint32_t ControlState;
;;;588    
;;;589      if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
00000a  4846              LDR      r0,|L6.292|
00000c  6800              LDR      r0,[r0,#0]  ; pInformation
00000e  7800              LDRB     r0,[r0,#0]
000010  f000007f          AND      r0,r0,#0x7f
000014  2800              CMP      r0,#0
000016  d144              BNE      |L6.162|
;;;590      {
;;;591        /* Device Request*/
;;;592        /* SET_CONFIGURATION*/
;;;593        if (RequestNo == SET_CONFIGURATION)
000018  2c09              CMP      r4,#9
00001a  d103              BNE      |L6.36|
;;;594        {
;;;595          Result = Standard_SetConfiguration();
00001c  f7fffffe          BL       Standard_SetConfiguration
000020  4606              MOV      r6,r0
000022  e05f              B        |L6.228|
                  |L6.36|
;;;596        }
;;;597    
;;;598        /*SET ADDRESS*/
;;;599        else if (RequestNo == SET_ADDRESS)
000024  2c05              CMP      r4,#5
000026  d114              BNE      |L6.82|
;;;600        {
;;;601          if ((pInformation->USBwValue0 > 127) || (pInformation->USBwValue1 != 0)
000028  483e              LDR      r0,|L6.292|
00002a  6800              LDR      r0,[r0,#0]  ; pInformation
00002c  78c0              LDRB     r0,[r0,#3]
00002e  287f              CMP      r0,#0x7f
000030  dc0b              BGT      |L6.74|
000032  483c              LDR      r0,|L6.292|
000034  6800              LDR      r0,[r0,#0]  ; pInformation
000036  7880              LDRB     r0,[r0,#2]
000038  b938              CBNZ     r0,|L6.74|
;;;602              || (pInformation->USBwIndex != 0)
00003a  483a              LDR      r0,|L6.292|
00003c  6800              LDR      r0,[r0,#0]  ; pInformation
00003e  8880              LDRH     r0,[r0,#4]
000040  b918              CBNZ     r0,|L6.74|
;;;603              || (pInformation->Current_Configuration != 0))
000042  4838              LDR      r0,|L6.292|
000044  6800              LDR      r0,[r0,#0]  ; pInformation
000046  7a80              LDRB     r0,[r0,#0xa]
000048  b108              CBZ      r0,|L6.78|
                  |L6.74|
;;;604            /* Device Address should be 127 or less*/
;;;605          {
;;;606            ControlState = STALLED;
00004a  2508              MOVS     r5,#8
;;;607            goto exit_NoData_Setup0;
00004c  e065              B        |L6.282|
                  |L6.78|
;;;608          }
;;;609          else
;;;610          {
;;;611            Result = USB_SUCCESS;
00004e  2600              MOVS     r6,#0
000050  e048              B        |L6.228|
                  |L6.82|
;;;612    
;;;613          #ifdef STM32F10X_CL
;;;614             SetDeviceAddress(pInformation->USBwValue0);
;;;615          #endif  /* STM32F10X_CL */
;;;616          }
;;;617        }
;;;618        /*SET FEATURE for Device*/
;;;619        else if (RequestNo == SET_FEATURE)
000052  2c03              CMP      r4,#3
000054  d10e              BNE      |L6.116|
;;;620        {
;;;621          if ((pInformation->USBwValue0 == DEVICE_REMOTE_WAKEUP) \
000056  4833              LDR      r0,|L6.292|
000058  6800              LDR      r0,[r0,#0]  ; pInformation
00005a  78c0              LDRB     r0,[r0,#3]
00005c  2801              CMP      r0,#1
00005e  d107              BNE      |L6.112|
;;;622              && (pInformation->USBwIndex == 0))
000060  4830              LDR      r0,|L6.292|
000062  6800              LDR      r0,[r0,#0]  ; pInformation
000064  8880              LDRH     r0,[r0,#4]
000066  b918              CBNZ     r0,|L6.112|
;;;623          {
;;;624            Result = Standard_SetDeviceFeature();
000068  f7fffffe          BL       Standard_SetDeviceFeature
00006c  4606              MOV      r6,r0
00006e  e039              B        |L6.228|
                  |L6.112|
;;;625          }
;;;626          else
;;;627          {
;;;628            Result = USB_UNSUPPORT;
000070  2602              MOVS     r6,#2
000072  e037              B        |L6.228|
                  |L6.116|
;;;629          }
;;;630        }
;;;631        /*Clear FEATURE for Device */
;;;632        else if (RequestNo == CLEAR_FEATURE)
000074  2c01              CMP      r4,#1
000076  d135              BNE      |L6.228|
;;;633        {
;;;634          if (pInformation->USBwValue0 == DEVICE_REMOTE_WAKEUP
000078  482a              LDR      r0,|L6.292|
00007a  6800              LDR      r0,[r0,#0]  ; pInformation
00007c  78c0              LDRB     r0,[r0,#3]
00007e  2801              CMP      r0,#1
000080  d10d              BNE      |L6.158|
;;;635              && pInformation->USBwIndex == 0
000082  4828              LDR      r0,|L6.292|
000084  6800              LDR      r0,[r0,#0]  ; pInformation
000086  8880              LDRH     r0,[r0,#4]
000088  b948              CBNZ     r0,|L6.158|
;;;636              && ValBit(pInformation->Current_Feature, 5))
00008a  4826              LDR      r0,|L6.292|
00008c  6800              LDR      r0,[r0,#0]  ; pInformation
00008e  7a40              LDRB     r0,[r0,#9]
000090  f0000020          AND      r0,r0,#0x20
000094  b118              CBZ      r0,|L6.158|
;;;637          {
;;;638            Result = Standard_ClearFeature();
000096  f7fffffe          BL       Standard_ClearFeature
00009a  4606              MOV      r6,r0
00009c  e022              B        |L6.228|
                  |L6.158|
;;;639          }
;;;640          else
;;;641          {
;;;642            Result = USB_UNSUPPORT;
00009e  2602              MOVS     r6,#2
0000a0  e020              B        |L6.228|
                  |L6.162|
;;;643          }
;;;644        }
;;;645    
;;;646      }
;;;647    
;;;648      /* Interface Request*/
;;;649      else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
0000a2  4820              LDR      r0,|L6.292|
0000a4  6800              LDR      r0,[r0,#0]  ; pInformation
0000a6  7800              LDRB     r0,[r0,#0]
0000a8  f000007f          AND      r0,r0,#0x7f
0000ac  2801              CMP      r0,#1
0000ae  d105              BNE      |L6.188|
;;;650      {
;;;651        /*SET INTERFACE*/
;;;652        if (RequestNo == SET_INTERFACE)
0000b0  2c0b              CMP      r4,#0xb
0000b2  d117              BNE      |L6.228|
;;;653        {
;;;654          Result = Standard_SetInterface();
0000b4  f7fffffe          BL       Standard_SetInterface
0000b8  4606              MOV      r6,r0
0000ba  e013              B        |L6.228|
                  |L6.188|
;;;655        }
;;;656      }
;;;657    
;;;658      /* EndPoint Request*/
;;;659      else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
0000bc  4819              LDR      r0,|L6.292|
0000be  6800              LDR      r0,[r0,#0]  ; pInformation
0000c0  7800              LDRB     r0,[r0,#0]
0000c2  f000007f          AND      r0,r0,#0x7f
0000c6  2802              CMP      r0,#2
0000c8  d10b              BNE      |L6.226|
;;;660      {
;;;661        /*CLEAR FEATURE for EndPoint*/
;;;662        if (RequestNo == CLEAR_FEATURE)
0000ca  2c01              CMP      r4,#1
0000cc  d103              BNE      |L6.214|
;;;663        {
;;;664          Result = Standard_ClearFeature();
0000ce  f7fffffe          BL       Standard_ClearFeature
0000d2  4606              MOV      r6,r0
0000d4  e006              B        |L6.228|
                  |L6.214|
;;;665        }
;;;666        /* SET FEATURE for EndPoint*/
;;;667        else if (RequestNo == SET_FEATURE)
0000d6  2c03              CMP      r4,#3
0000d8  d104              BNE      |L6.228|
;;;668        {
;;;669          Result = Standard_SetEndPointFeature();
0000da  f7fffffe          BL       Standard_SetEndPointFeature
0000de  4606              MOV      r6,r0
0000e0  e000              B        |L6.228|
                  |L6.226|
;;;670        }
;;;671      }
;;;672      else
;;;673      {
;;;674        Result = USB_UNSUPPORT;
0000e2  2602              MOVS     r6,#2
                  |L6.228|
;;;675      }
;;;676    
;;;677    
;;;678      if (Result != USB_SUCCESS)
0000e4  b14e              CBZ      r6,|L6.250|
;;;679      {
;;;680        Result = (*pProperty->Class_NoData_Setup)(RequestNo);
0000e6  b2e0              UXTB     r0,r4
0000e8  4a0f              LDR      r2,|L6.296|
0000ea  6812              LDR      r2,[r2,#0]  ; pProperty
0000ec  6951              LDR      r1,[r2,#0x14]
0000ee  4788              BLX      r1
0000f0  4606              MOV      r6,r0
;;;681        if (Result == USB_NOT_READY)
0000f2  2e03              CMP      r6,#3
0000f4  d101              BNE      |L6.250|
;;;682        {
;;;683          ControlState = PAUSE;
0000f6  2509              MOVS     r5,#9
;;;684          goto exit_NoData_Setup0;
0000f8  e00f              B        |L6.282|
                  |L6.250|
;;;685        }
;;;686      }
;;;687    
;;;688      if (Result != USB_SUCCESS)
0000fa  b10e              CBZ      r6,|L6.256|
;;;689      {
;;;690        ControlState = STALLED;
0000fc  2508              MOVS     r5,#8
;;;691        goto exit_NoData_Setup0;
0000fe  e00c              B        |L6.282|
                  |L6.256|
;;;692      }
;;;693    
;;;694      ControlState = WAIT_STATUS_IN;/* After no data stage SETUP */
000100  2506              MOVS     r5,#6
;;;695    
;;;696      USB_StatusIn();
000102  2100              MOVS     r1,#0
000104  4809              LDR      r0,|L6.300|
000106  6800              LDR      r0,[r0,#0]
000108  b280              UXTH     r0,r0
00010a  1c80              ADDS     r0,r0,#2
00010c  4a08              LDR      r2,|L6.304|
00010e  f8421010          STR      r1,[r2,r0,LSL #1]
000112  2030              MOVS     r0,#0x30
000114  4907              LDR      r1,|L6.308|
000116  8008              STRH     r0,[r1,#0]
;;;697    
;;;698    exit_NoData_Setup0:
000118  bf00              NOP      
                  |L6.282|
;;;699      pInformation->ControlState = ControlState;
00011a  4902              LDR      r1,|L6.292|
00011c  6809              LDR      r1,[r1,#0]  ; pInformation
00011e  720d              STRB     r5,[r1,#8]
;;;700      return;
;;;701    }
000120  bd70              POP      {r4-r6,pc}
;;;702    
                          ENDP

000122  0000              DCW      0x0000
                  |L6.292|
                          DCD      pInformation
                  |L6.296|
                          DCD      pProperty
                  |L6.300|
                          DCD      0x40005c50
                  |L6.304|
                          DCD      0x40006000
                  |L6.308|
                          DCD      SaveTState

                          AREA ||i.Out0_Process||, CODE, READONLY, ALIGN=2

                  Out0_Process PROC
;;;982    *******************************************************************************/
;;;983    uint8_t Out0_Process(void)
000000  b510              PUSH     {r4,lr}
;;;984    {
;;;985      uint32_t ControlState = pInformation->ControlState;
000002  4811              LDR      r0,|L7.72|
000004  6800              LDR      r0,[r0,#0]  ; pInformation
000006  7a04              LDRB     r4,[r0,#8]
;;;986    
;;;987      if ((ControlState == IN_DATA) || (ControlState == LAST_IN_DATA))
000008  2c02              CMP      r4,#2
00000a  d001              BEQ      |L7.16|
00000c  2c04              CMP      r4,#4
00000e  d101              BNE      |L7.20|
                  |L7.16|
;;;988      {
;;;989        /* host aborts the transfer before finish */
;;;990        ControlState = STALLED;
000010  2408              MOVS     r4,#8
000012  e012              B        |L7.58|
                  |L7.20|
;;;991      }
;;;992      else if ((ControlState == OUT_DATA) || (ControlState == LAST_OUT_DATA))
000014  2c03              CMP      r4,#3
000016  d001              BEQ      |L7.28|
000018  2c05              CMP      r4,#5
00001a  d105              BNE      |L7.40|
                  |L7.28|
;;;993      {
;;;994        DataStageOut();
00001c  f7fffffe          BL       DataStageOut
;;;995        ControlState = pInformation->ControlState; /* may be changed outside the function */
000020  4809              LDR      r0,|L7.72|
000022  6800              LDR      r0,[r0,#0]  ; pInformation
000024  7a04              LDRB     r4,[r0,#8]
000026  e008              B        |L7.58|
                  |L7.40|
;;;996      }
;;;997    
;;;998      else if (ControlState == WAIT_STATUS_OUT)
000028  2c07              CMP      r4,#7
00002a  d105              BNE      |L7.56|
;;;999      {
;;;1000       (*pProperty->Process_Status_OUT)();
00002c  4907              LDR      r1,|L7.76|
00002e  6809              LDR      r1,[r1,#0]  ; pProperty
000030  68c8              LDR      r0,[r1,#0xc]
000032  4780              BLX      r0
;;;1001     #ifndef STM32F10X_CL
;;;1002       ControlState = STALLED;
000034  2408              MOVS     r4,#8
000036  e000              B        |L7.58|
                  |L7.56|
;;;1003     #endif /* STM32F10X_CL */
;;;1004     }
;;;1005   
;;;1006   
;;;1007     /* Unexpect state, STALL the endpoint */
;;;1008     else
;;;1009     {
;;;1010       ControlState = STALLED;
000038  2408              MOVS     r4,#8
                  |L7.58|
;;;1011     }
;;;1012   
;;;1013     pInformation->ControlState = ControlState;
00003a  4903              LDR      r1,|L7.72|
00003c  6809              LDR      r1,[r1,#0]  ; pInformation
00003e  720c              STRB     r4,[r1,#8]
;;;1014   
;;;1015     return Post0_Process();
000040  f7fffffe          BL       Post0_Process
;;;1016   }
000044  bd10              POP      {r4,pc}
;;;1017   
                          ENDP

000046  0000              DCW      0x0000
                  |L7.72|
                          DCD      pInformation
                  |L7.76|
                          DCD      pProperty

                          AREA ||i.Post0_Process||, CODE, READONLY, ALIGN=2

                  Post0_Process PROC
;;;1025   *******************************************************************************/
;;;1026   uint8_t Post0_Process(void)
000000  b510              PUSH     {r4,lr}
;;;1027   {
;;;1028   #ifdef STM32F10X_CL  
;;;1029     USB_OTG_EP *ep;
;;;1030   #endif /* STM32F10X_CL */
;;;1031         
;;;1032     SetEPRxCount(ENDP0, Device_Property.MaxPacketSize);
000002  480d              LDR      r0,|L8.56|
000004  f890102c          LDRB     r1,[r0,#0x2c]  ; Device_Property
000008  2000              MOVS     r0,#0
00000a  f7fffffe          BL       SetEPRxCount
;;;1033   
;;;1034     if (pInformation->ControlState == STALLED)
00000e  480b              LDR      r0,|L8.60|
000010  6800              LDR      r0,[r0,#0]  ; pInformation
000012  7a00              LDRB     r0,[r0,#8]
000014  2808              CMP      r0,#8
000016  d105              BNE      |L8.36|
;;;1035     {
;;;1036       vSetEPRxStatus(EP_RX_STALL);
000018  0240              LSLS     r0,r0,#9
00001a  4909              LDR      r1,|L8.64|
00001c  8008              STRH     r0,[r1,#0]
;;;1037       vSetEPTxStatus(EP_TX_STALL);
00001e  2010              MOVS     r0,#0x10
000020  4908              LDR      r1,|L8.68|
000022  8008              STRH     r0,[r1,#0]
                  |L8.36|
;;;1038     }
;;;1039   
;;;1040   #ifdef STM32F10X_CL
;;;1041     else if ((pInformation->ControlState == OUT_DATA) ||
;;;1042         (pInformation->ControlState == WAIT_STATUS_OUT))
;;;1043     {
;;;1044       ep = PCD_GetInEP(0);
;;;1045       ep->is_in = 0;
;;;1046       OTGD_FS_EP0StartXfer(ep);
;;;1047       
;;;1048       vSetEPTxStatus(EP_TX_VALID);
;;;1049     }
;;;1050     
;;;1051     else if ((pInformation->ControlState == IN_DATA) || 
;;;1052         (pInformation->ControlState == WAIT_STATUS_IN))
;;;1053     {
;;;1054       ep = PCD_GetInEP(0);
;;;1055       ep->is_in = 1;
;;;1056       OTGD_FS_EP0StartXfer(ep);    
;;;1057     }  
;;;1058   #endif /* STM32F10X_CL */
;;;1059   
;;;1060     return (pInformation->ControlState == PAUSE);
000024  4805              LDR      r0,|L8.60|
000026  6800              LDR      r0,[r0,#0]  ; pInformation
000028  7a00              LDRB     r0,[r0,#8]
00002a  2809              CMP      r0,#9
00002c  d101              BNE      |L8.50|
00002e  2001              MOVS     r0,#1
                  |L8.48|
;;;1061   }
000030  bd10              POP      {r4,pc}
                  |L8.50|
000032  2000              MOVS     r0,#0                 ;1060
000034  e7fc              B        |L8.48|
;;;1062   
                          ENDP

000036  0000              DCW      0x0000
                  |L8.56|
                          DCD      Device_Property
                  |L8.60|
                          DCD      pInformation
                  |L8.64|
                          DCD      SaveRState
                  |L8.68|
                          DCD      SaveTState

                          AREA ||i.SetDeviceAddress||, CODE, READONLY, ALIGN=2

                  SetDeviceAddress PROC
;;;1069   *******************************************************************************/
;;;1070   void SetDeviceAddress(uint8_t Val)
000000  b530              PUSH     {r4,r5,lr}
;;;1071   {
000002  4601              MOV      r1,r0
;;;1072   #ifdef STM32F10X_CL 
;;;1073     PCD_EP_SetAddress ((uint8_t)Val);
;;;1074   #else 
;;;1075     uint32_t i;
;;;1076     uint32_t nEP = Device_Table.Total_Endpoint;
000004  4b0f              LDR      r3,|L9.68|
000006  781a              LDRB     r2,[r3,#0]  ; Device_Table
;;;1077   
;;;1078     /* set address in every used endpoint */
;;;1079     for (i = 0; i < nEP; i++)
000008  2000              MOVS     r0,#0
00000a  e014              B        |L9.54|
                  |L9.12|
;;;1080     {
;;;1081       _SetEPAddress((uint8_t)i, (uint8_t)i);
00000c  0603              LSLS     r3,r0,#24
00000e  4c0e              LDR      r4,|L9.72|
000010  eb045393          ADD      r3,r4,r3,LSR #22
000014  f8d33c00          LDR      r3,[r3,#0xc00]
000018  f648748f          MOV      r4,#0x8f8f
00001c  4023              ANDS     r3,r3,r4
00001e  f2480480          MOV      r4,#0x8080
000022  4323              ORRS     r3,r3,r4
000024  b2c4              UXTB     r4,r0
000026  4323              ORRS     r3,r3,r4
000028  0604              LSLS     r4,r0,#24
00002a  4d07              LDR      r5,|L9.72|
00002c  eb055494          ADD      r4,r5,r4,LSR #22
000030  f8c43c00          STR      r3,[r4,#0xc00]
000034  1c40              ADDS     r0,r0,#1              ;1079
                  |L9.54|
000036  4290              CMP      r0,r2                 ;1079
000038  d3e8              BCC      |L9.12|
;;;1082     } /* for */
;;;1083     _SetDADDR(Val | DADDR_EF); /* set device address and enable function */
00003a  f0410380          ORR      r3,r1,#0x80
00003e  4c03              LDR      r4,|L9.76|
000040  6023              STR      r3,[r4,#0]
;;;1084   #endif  /* STM32F10X_CL */  
;;;1085   }
000042  bd30              POP      {r4,r5,pc}
;;;1086   
                          ENDP

                  |L9.68|
                          DCD      Device_Table
                  |L9.72|
                          DCD      0x40005000
                  |L9.76|
                          DCD      0x40005c4c

                          AREA ||i.Setup0_Process||, CODE, READONLY, ALIGN=2

                  Setup0_Process PROC
;;;888    *******************************************************************************/
;;;889    uint8_t Setup0_Process(void)
000000  b538              PUSH     {r3-r5,lr}
;;;890    {
;;;891    
;;;892      union
;;;893      {
;;;894        uint8_t* b;
;;;895        uint16_t* w;
;;;896      } pBuf;
;;;897    
;;;898    #ifdef STM32F10X_CL
;;;899      USB_OTG_EP *ep;
;;;900      uint16_t offset = 0;
;;;901     
;;;902      ep = PCD_GetOutEP(ENDP0);
;;;903      pBuf.b = ep->xfer_buff;
;;;904    #else  
;;;905      uint16_t offset = 1;
000002  2401              MOVS     r4,#1
;;;906      
;;;907      pBuf.b = PMAAddr + (uint8_t *)(_GetEPRxAddr(ENDP0) * 2); /* *2 for 32 bits addr */
000004  4829              LDR      r0,|L10.172|
000006  6800              LDR      r0,[r0,#0]
000008  b280              UXTH     r0,r0
00000a  1d00              ADDS     r0,r0,#4
00000c  4928              LDR      r1,|L10.176|
00000e  f8310010          LDRH     r0,[r1,r0,LSL #1]
000012  b280              UXTH     r0,r0
000014  eb010040          ADD      r0,r1,r0,LSL #1
000018  9000              STR      r0,[sp,#0]
;;;908    #endif /* STM32F10X_CL */
;;;909    
;;;910      if (pInformation->ControlState != PAUSE)
00001a  4826              LDR      r0,|L10.180|
00001c  6800              LDR      r0,[r0,#0]  ; pInformation
00001e  7a00              LDRB     r0,[r0,#8]
000020  2809              CMP      r0,#9
000022  d032              BEQ      |L10.138|
;;;911      {
;;;912        pInformation->USBbmRequestType = *pBuf.b++; /* bmRequestType */
000024  9800              LDR      r0,[sp,#0]
000026  7800              LDRB     r0,[r0,#0]
000028  4922              LDR      r1,|L10.180|
00002a  6809              LDR      r1,[r1,#0]  ; pInformation
00002c  7008              STRB     r0,[r1,#0]
00002e  9800              LDR      r0,[sp,#0]
000030  1c40              ADDS     r0,r0,#1
000032  9000              STR      r0,[sp,#0]
;;;913        pInformation->USBbRequest = *pBuf.b++; /* bRequest */
000034  9800              LDR      r0,[sp,#0]
000036  7800              LDRB     r0,[r0,#0]
000038  491e              LDR      r1,|L10.180|
00003a  6809              LDR      r1,[r1,#0]  ; pInformation
00003c  7048              STRB     r0,[r1,#1]
00003e  9800              LDR      r0,[sp,#0]
000040  1c40              ADDS     r0,r0,#1
000042  9000              STR      r0,[sp,#0]
;;;914        pBuf.w += offset;  /* word not accessed because of 32 bits addressing */
000044  9800              LDR      r0,[sp,#0]
000046  eb000044          ADD      r0,r0,r4,LSL #1
00004a  9000              STR      r0,[sp,#0]
;;;915        pInformation->USBwValue = ByteSwap(*pBuf.w++); /* wValue */
00004c  9900              LDR      r1,[sp,#0]
00004e  f8310b02          LDRH     r0,[r1],#2
000052  9100              STR      r1,[sp,#0]
000054  f7fffffe          BL       ByteSwap
000058  4916              LDR      r1,|L10.180|
00005a  6809              LDR      r1,[r1,#0]  ; pInformation
00005c  8048              STRH     r0,[r1,#2]
;;;916        pBuf.w += offset;  /* word not accessed because of 32 bits addressing */
00005e  9800              LDR      r0,[sp,#0]
000060  eb000044          ADD      r0,r0,r4,LSL #1
000064  9000              STR      r0,[sp,#0]
;;;917        pInformation->USBwIndex  = ByteSwap(*pBuf.w++); /* wIndex */
000066  9900              LDR      r1,[sp,#0]
000068  f8310b02          LDRH     r0,[r1],#2
00006c  9100              STR      r1,[sp,#0]
00006e  f7fffffe          BL       ByteSwap
000072  4910              LDR      r1,|L10.180|
000074  6809              LDR      r1,[r1,#0]  ; pInformation
000076  8088              STRH     r0,[r1,#4]
;;;918        pBuf.w += offset;  /* word not accessed because of 32 bits addressing */
000078  9800              LDR      r0,[sp,#0]
00007a  eb000044          ADD      r0,r0,r4,LSL #1
00007e  9000              STR      r0,[sp,#0]
;;;919        pInformation->USBwLength = *pBuf.w; /* wLength */
000080  9800              LDR      r0,[sp,#0]
000082  8800              LDRH     r0,[r0,#0]
000084  490b              LDR      r1,|L10.180|
000086  6809              LDR      r1,[r1,#0]  ; pInformation
000088  80c8              STRH     r0,[r1,#6]
                  |L10.138|
;;;920      }
;;;921    
;;;922      pInformation->ControlState = SETTING_UP;
00008a  2001              MOVS     r0,#1
00008c  4909              LDR      r1,|L10.180|
00008e  6809              LDR      r1,[r1,#0]  ; pInformation
000090  7208              STRB     r0,[r1,#8]
;;;923      if (pInformation->USBwLength == 0)
000092  4808              LDR      r0,|L10.180|
000094  6800              LDR      r0,[r0,#0]  ; pInformation
000096  88c0              LDRH     r0,[r0,#6]
000098  b910              CBNZ     r0,|L10.160|
;;;924      {
;;;925        /* Setup with no data stage */
;;;926        NoData_Setup0();
00009a  f7fffffe          BL       NoData_Setup0
00009e  e001              B        |L10.164|
                  |L10.160|
;;;927      }
;;;928      else
;;;929      {
;;;930        /* Setup with data stage */
;;;931        Data_Setup0();
0000a0  f7fffffe          BL       Data_Setup0
                  |L10.164|
;;;932      }
;;;933      return Post0_Process();
0000a4  f7fffffe          BL       Post0_Process
;;;934    }
0000a8  bd38              POP      {r3-r5,pc}
;;;935    
                          ENDP

0000aa  0000              DCW      0x0000
                  |L10.172|
                          DCD      0x40005c50
                  |L10.176|
                          DCD      0x40006000
                  |L10.180|
                          DCD      pInformation

                          AREA ||i.Standard_ClearFeature||, CODE, READONLY, ALIGN=2

                  Standard_ClearFeature PROC
;;;257    *******************************************************************************/
;;;258    RESULT Standard_ClearFeature(void)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;259    {
;;;260      uint32_t     Type_Rec = Type_Recipient;
000004  4854              LDR      r0,|L11.344|
000006  6800              LDR      r0,[r0,#0]  ; pInformation
000008  7800              LDRB     r0,[r0,#0]
00000a  f000087f          AND      r8,r0,#0x7f
;;;261      uint32_t     Status;
;;;262    
;;;263    
;;;264      if (Type_Rec == (STANDARD_REQUEST | DEVICE_RECIPIENT))
00000e  f1b80f00          CMP      r8,#0
000012  d10a              BNE      |L11.42|
;;;265      {/*Device Clear Feature*/
;;;266        ClrBit(pInformation->Current_Feature, 5);
000014  4850              LDR      r0,|L11.344|
000016  6800              LDR      r0,[r0,#0]  ; pInformation
000018  7a40              LDRB     r0,[r0,#9]
00001a  f00000df          AND      r0,r0,#0xdf
00001e  494e              LDR      r1,|L11.344|
000020  6809              LDR      r1,[r1,#0]  ; pInformation
000022  7248              STRB     r0,[r1,#9]
;;;267        return USB_SUCCESS;
000024  2000              MOVS     r0,#0
                  |L11.38|
;;;268      }
;;;269      else if (Type_Rec == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
;;;270      {/*EndPoint Clear Feature*/
;;;271        DEVICE* pDev;
;;;272        uint32_t Related_Endpoint;
;;;273        uint32_t wIndex0;
;;;274        uint32_t rEP;
;;;275    
;;;276        if ((pInformation->USBwValue != ENDPOINT_STALL)
;;;277            || (pInformation->USBwIndex1 != 0))
;;;278        {
;;;279          return USB_UNSUPPORT;
;;;280        }
;;;281    
;;;282        pDev = &Device_Table;
;;;283        wIndex0 = pInformation->USBwIndex0;
;;;284        rEP = wIndex0 & ~0x80;
;;;285        Related_Endpoint = ENDP0 + rEP;
;;;286    
;;;287        if (ValBit(pInformation->USBwIndex0, 7))
;;;288        {
;;;289          /*Get Status of endpoint & stall the request if the related_ENdpoint
;;;290          is Disabled*/
;;;291          Status = _GetEPTxStatus(Related_Endpoint);
;;;292        }
;;;293        else
;;;294        {
;;;295          Status = _GetEPRxStatus(Related_Endpoint);
;;;296        }
;;;297    
;;;298        if ((rEP >= pDev->Total_Endpoint) || (Status == 0)
;;;299            || (pInformation->Current_Configuration == 0))
;;;300        {
;;;301          return USB_UNSUPPORT;
;;;302        }
;;;303    
;;;304    
;;;305        if (wIndex0 & 0x80)
;;;306        {
;;;307          /* IN endpoint */
;;;308          if (_GetTxStallStatus(Related_Endpoint ))
;;;309          {
;;;310          #ifndef STM32F10X_CL
;;;311            ClearDTOG_TX(Related_Endpoint);
;;;312          #endif /* STM32F10X_CL */
;;;313            SetEPTxStatus(Related_Endpoint, EP_TX_VALID);
;;;314          }
;;;315        }
;;;316        else
;;;317        {
;;;318          /* OUT endpoint */
;;;319          if (_GetRxStallStatus(Related_Endpoint))
;;;320          {
;;;321            if (Related_Endpoint == ENDP0)
;;;322            {
;;;323              /* After clear the STALL, enable the default endpoint receiver */
;;;324              SetEPRxCount(Related_Endpoint, Device_Property.MaxPacketSize);
;;;325              _SetEPRxStatus(Related_Endpoint, EP_RX_VALID);
;;;326            }
;;;327            else
;;;328            {
;;;329            #ifndef STM32F10X_CL
;;;330              ClearDTOG_RX(Related_Endpoint);
;;;331            #endif /* STM32F10X_CL */
;;;332              _SetEPRxStatus(Related_Endpoint, EP_RX_VALID);
;;;333            }
;;;334          }
;;;335        }
;;;336        pUser_Standard_Requests->User_ClearFeature();
;;;337        return USB_SUCCESS;
;;;338      }
;;;339    
;;;340      return USB_UNSUPPORT;
;;;341    }
000026  e8bd87f0          POP      {r4-r10,pc}
                  |L11.42|
00002a  f1b80f02          CMP      r8,#2                 ;269
00002e  d17c              BNE      |L11.298|
000030  4849              LDR      r0,|L11.344|
000032  6800              LDR      r0,[r0,#0]            ;276  ; pInformation
000034  8840              LDRH     r0,[r0,#2]            ;276
000036  b918              CBNZ     r0,|L11.64|
000038  4847              LDR      r0,|L11.344|
00003a  6800              LDR      r0,[r0,#0]            ;277  ; pInformation
00003c  7900              LDRB     r0,[r0,#4]            ;277
00003e  b108              CBZ      r0,|L11.68|
                  |L11.64|
000040  2002              MOVS     r0,#2                 ;279
000042  e7f0              B        |L11.38|
                  |L11.68|
000044  f8df9114          LDR      r9,|L11.348|
000048  4843              LDR      r0,|L11.344|
00004a  6800              LDR      r0,[r0,#0]            ;283  ; pInformation
00004c  7947              LDRB     r7,[r0,#5]            ;283
00004e  f0270580          BIC      r5,r7,#0x80           ;284
000052  462c              MOV      r4,r5                 ;285
000054  4840              LDR      r0,|L11.344|
000056  6800              LDR      r0,[r0,#0]            ;287  ; pInformation
000058  7940              LDRB     r0,[r0,#5]            ;287
00005a  f0000080          AND      r0,r0,#0x80           ;287
00005e  b138              CBZ      r0,|L11.112|
000060  493f              LDR      r1,|L11.352|
000062  eb010084          ADD      r0,r1,r4,LSL #2       ;291
000066  f8d00c00          LDR      r0,[r0,#0xc00]        ;291
00006a  f0000630          AND      r6,r0,#0x30           ;291
00006e  e006              B        |L11.126|
                  |L11.112|
000070  493b              LDR      r1,|L11.352|
000072  eb010084          ADD      r0,r1,r4,LSL #2       ;295
000076  f8d00c00          LDR      r0,[r0,#0xc00]        ;295
00007a  f4005640          AND      r6,r0,#0x3000         ;295
                  |L11.126|
00007e  f8990000          LDRB     r0,[r9,#0]            ;298
000082  42a8              CMP      r0,r5                 ;298
000084  d904              BLS      |L11.144|
000086  b11e              CBZ      r6,|L11.144|
000088  4833              LDR      r0,|L11.344|
00008a  6800              LDR      r0,[r0,#0]            ;299  ; pInformation
00008c  7a80              LDRB     r0,[r0,#0xa]          ;299
00008e  b908              CBNZ     r0,|L11.148|
                  |L11.144|
000090  2002              MOVS     r0,#2                 ;301
000092  e7c8              B        |L11.38|
                  |L11.148|
000094  f0070080          AND      r0,r7,#0x80           ;305
000098  b180              CBZ      r0,|L11.188|
00009a  4931              LDR      r1,|L11.352|
00009c  eb010084          ADD      r0,r1,r4,LSL #2       ;308
0000a0  f8d00c00          LDR      r0,[r0,#0xc00]        ;308
0000a4  f0000030          AND      r0,r0,#0x30           ;308
0000a8  2810              CMP      r0,#0x10              ;308
0000aa  d14b              BNE      |L11.324|
0000ac  b2e0              UXTB     r0,r4                 ;311
0000ae  f7fffffe          BL       ClearDTOG_TX
0000b2  b2e0              UXTB     r0,r4                 ;313
0000b4  2130              MOVS     r1,#0x30              ;313
0000b6  f7fffffe          BL       SetEPTxStatus
0000ba  e043              B        |L11.324|
                  |L11.188|
0000bc  4928              LDR      r1,|L11.352|
0000be  eb010084          ADD      r0,r1,r4,LSL #2       ;319
0000c2  f8d00c00          LDR      r0,[r0,#0xc00]        ;319
0000c6  f4005040          AND      r0,r0,#0x3000         ;319
0000ca  f5b05f80          CMP      r0,#0x1000            ;319
0000ce  d139              BNE      |L11.324|
0000d0  b9e4              CBNZ     r4,|L11.268|
0000d2  4a24              LDR      r2,|L11.356|
0000d4  f892102c          LDRB     r1,[r2,#0x2c]         ;324  ; Device_Property
0000d8  b2e0              UXTB     r0,r4                 ;324
0000da  f7fffffe          BL       SetEPRxCount
0000de  4a20              LDR      r2,|L11.352|
0000e0  eb020184          ADD      r1,r2,r4,LSL #2       ;325
0000e4  f8d11c00          LDR      r1,[r1,#0xc00]        ;325
0000e8  f64b728f          MOV      r2,#0xbf8f            ;325
0000ec  ea010002          AND      r0,r1,r2              ;325
0000f0  f4805080          EOR      r0,r0,#0x1000         ;325
0000f4  f4805000          EOR      r0,r0,#0x2000         ;325
0000f8  f4404100          ORR      r1,r0,#0x8000         ;325
0000fc  f0410180          ORR      r1,r1,#0x80           ;325
000100  4b17              LDR      r3,|L11.352|
000102  eb030284          ADD      r2,r3,r4,LSL #2       ;325
000106  f8c21c00          STR      r1,[r2,#0xc00]        ;325
00010a  e01b              B        |L11.324|
                  |L11.268|
00010c  b2e0              UXTB     r0,r4                 ;330
00010e  f7fffffe          BL       ClearDTOG_RX
000112  4a13              LDR      r2,|L11.352|
000114  eb020184          ADD      r1,r2,r4,LSL #2       ;332
000118  f8d11c00          LDR      r1,[r1,#0xc00]        ;332
00011c  f64b728f          MOV      r2,#0xbf8f            ;332
000120  ea010002          AND      r0,r1,r2              ;332
000124  f4805080          EOR      r0,r0,#0x1000         ;332
000128  e000              B        |L11.300|
                  |L11.298|
00012a  e011              B        |L11.336|
                  |L11.300|
00012c  f4805000          EOR      r0,r0,#0x2000         ;332
000130  f4404100          ORR      r1,r0,#0x8000         ;332
000134  f0410180          ORR      r1,r1,#0x80           ;332
000138  4b09              LDR      r3,|L11.352|
00013a  eb030284          ADD      r2,r3,r4,LSL #2       ;332
00013e  f8c21c00          STR      r1,[r2,#0xc00]        ;332
000142  bf00              NOP                            ;332
                  |L11.324|
000144  4908              LDR      r1,|L11.360|
000146  6809              LDR      r1,[r1,#0]            ;336  ; pUser_Standard_Requests
000148  6948              LDR      r0,[r1,#0x14]         ;336
00014a  4780              BLX      r0                    ;336
00014c  2000              MOVS     r0,#0                 ;337
00014e  e76a              B        |L11.38|
                  |L11.336|
000150  bf00              NOP                            ;338
000152  2002              MOVS     r0,#2                 ;340
000154  e767              B        |L11.38|
;;;342    
                          ENDP

000156  0000              DCW      0x0000
                  |L11.344|
                          DCD      pInformation
                  |L11.348|
                          DCD      Device_Table
                  |L11.352|
                          DCD      0x40005000
                  |L11.356|
                          DCD      Device_Property
                  |L11.360|
                          DCD      pUser_Standard_Requests

                          AREA ||i.Standard_GetConfiguration||, CODE, READONLY, ALIGN=2

                  Standard_GetConfiguration PROC
;;;73     *******************************************************************************/
;;;74     uint8_t *Standard_GetConfiguration(uint16_t Length)
000000  b510              PUSH     {r4,lr}
;;;75     {
000002  4604              MOV      r4,r0
;;;76       if (Length == 0)
000004  b92c              CBNZ     r4,|L12.18|
;;;77       {
;;;78         pInformation->Ctrl_Info.Usb_wLength =
000006  2001              MOVS     r0,#1
000008  4906              LDR      r1,|L12.36|
00000a  6809              LDR      r1,[r1,#0]  ; pInformation
00000c  8208              STRH     r0,[r1,#0x10]
;;;79           sizeof(pInformation->Current_Configuration);
;;;80         return 0;
00000e  2000              MOVS     r0,#0
                  |L12.16|
;;;81       }
;;;82       pUser_Standard_Requests->User_GetConfiguration();
;;;83       return (uint8_t *)&pInformation->Current_Configuration;
;;;84     }
000010  bd10              POP      {r4,pc}
                  |L12.18|
000012  4905              LDR      r1,|L12.40|
000014  6809              LDR      r1,[r1,#0]            ;82  ; pUser_Standard_Requests
000016  6808              LDR      r0,[r1,#0]            ;82
000018  4780              BLX      r0                    ;82
00001a  4802              LDR      r0,|L12.36|
00001c  6800              LDR      r0,[r0,#0]            ;83  ; pInformation
00001e  300a              ADDS     r0,r0,#0xa            ;83
000020  e7f6              B        |L12.16|
;;;85     
                          ENDP

000022  0000              DCW      0x0000
                  |L12.36|
                          DCD      pInformation
                  |L12.40|
                          DCD      pUser_Standard_Requests

                          AREA ||i.Standard_GetDescriptorData||, CODE, READONLY, ALIGN=2

                  Standard_GetDescriptorData PROC
;;;430    *******************************************************************************/
;;;431    uint8_t *Standard_GetDescriptorData(uint16_t Length, ONE_DESCRIPTOR *pDesc)
000000  b510              PUSH     {r4,lr}
;;;432    {
000002  4602              MOV      r2,r0
;;;433      uint32_t  wOffset;
;;;434    
;;;435      wOffset = pInformation->Ctrl_Info.Usb_wOffset;
000004  4806              LDR      r0,|L13.32|
000006  6800              LDR      r0,[r0,#0]  ; pInformation
000008  8a43              LDRH     r3,[r0,#0x12]
;;;436      if (Length == 0)
00000a  b932              CBNZ     r2,|L13.26|
;;;437      {
;;;438        pInformation->Ctrl_Info.Usb_wLength = pDesc->Descriptor_Size - wOffset;
00000c  8888              LDRH     r0,[r1,#4]
00000e  1ac0              SUBS     r0,r0,r3
000010  4c03              LDR      r4,|L13.32|
000012  6824              LDR      r4,[r4,#0]  ; pInformation
000014  8220              STRH     r0,[r4,#0x10]
;;;439        return 0;
000016  2000              MOVS     r0,#0
                  |L13.24|
;;;440      }
;;;441    
;;;442      return pDesc->Descriptor + wOffset;
;;;443    }
000018  bd10              POP      {r4,pc}
                  |L13.26|
00001a  6808              LDR      r0,[r1,#0]            ;442
00001c  4418              ADD      r0,r0,r3              ;442
00001e  e7fb              B        |L13.24|
;;;444    
                          ENDP

                  |L13.32|
                          DCD      pInformation

                          AREA ||i.Standard_GetInterface||, CODE, READONLY, ALIGN=2

                  Standard_GetInterface PROC
;;;119    *******************************************************************************/
;;;120    uint8_t *Standard_GetInterface(uint16_t Length)
000000  b510              PUSH     {r4,lr}
;;;121    {
000002  4604              MOV      r4,r0
;;;122      if (Length == 0)
000004  b92c              CBNZ     r4,|L14.18|
;;;123      {
;;;124        pInformation->Ctrl_Info.Usb_wLength =
000006  2001              MOVS     r0,#1
000008  4906              LDR      r1,|L14.36|
00000a  6809              LDR      r1,[r1,#0]  ; pInformation
00000c  8208              STRH     r0,[r1,#0x10]
;;;125          sizeof(pInformation->Current_AlternateSetting);
;;;126        return 0;
00000e  2000              MOVS     r0,#0
                  |L14.16|
;;;127      }
;;;128      pUser_Standard_Requests->User_GetInterface();
;;;129      return (uint8_t *)&pInformation->Current_AlternateSetting;
;;;130    }
000010  bd10              POP      {r4,pc}
                  |L14.18|
000012  4905              LDR      r1,|L14.40|
000014  6809              LDR      r1,[r1,#0]            ;128  ; pUser_Standard_Requests
000016  6888              LDR      r0,[r1,#8]            ;128
000018  4780              BLX      r0                    ;128
00001a  4802              LDR      r0,|L14.36|
00001c  6800              LDR      r0,[r0,#0]            ;129  ; pInformation
00001e  300c              ADDS     r0,r0,#0xc            ;129
000020  e7f6              B        |L14.16|
;;;131    
                          ENDP

000022  0000              DCW      0x0000
                  |L14.36|
                          DCD      pInformation
                  |L14.40|
                          DCD      pUser_Standard_Requests

                          AREA ||i.Standard_GetStatus||, CODE, READONLY, ALIGN=2

                  Standard_GetStatus PROC
;;;175    *******************************************************************************/
;;;176    uint8_t *Standard_GetStatus(uint16_t Length)
000000  b510              PUSH     {r4,lr}
;;;177    {
000002  4604              MOV      r4,r0
;;;178      if (Length == 0)
000004  b92c              CBNZ     r4,|L15.18|
;;;179      {
;;;180        pInformation->Ctrl_Info.Usb_wLength = 2;
000006  2002              MOVS     r0,#2
000008  4939              LDR      r1,|L15.240|
00000a  6809              LDR      r1,[r1,#0]  ; pInformation
00000c  8208              STRH     r0,[r1,#0x10]
;;;181        return 0;
00000e  2000              MOVS     r0,#0
                  |L15.16|
;;;182      }
;;;183    
;;;184      /* Reset Status Information */
;;;185      StatusInfo.w = 0;
;;;186    
;;;187      if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
;;;188      {
;;;189        /*Get Device Status */
;;;190        uint8_t Feature = pInformation->Current_Feature;
;;;191    
;;;192        /* Remote Wakeup enabled */
;;;193        if (ValBit(Feature, 5))
;;;194        {
;;;195          SetBit(StatusInfo0, 1);
;;;196        }
;;;197        else
;;;198        {
;;;199          ClrBit(StatusInfo0, 1);
;;;200        }      
;;;201    
;;;202        /* Bus-powered */
;;;203        if (ValBit(Feature, 6))
;;;204        {
;;;205          SetBit(StatusInfo0, 0);
;;;206        }
;;;207        else /* Self-powered */
;;;208        {
;;;209          ClrBit(StatusInfo0, 0);
;;;210        }
;;;211      }
;;;212      /*Interface Status*/
;;;213      else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
;;;214      {
;;;215        return (uint8_t *)&StatusInfo;
;;;216      }
;;;217      /*Get EndPoint Status*/
;;;218      else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
;;;219      {
;;;220        uint8_t Related_Endpoint;
;;;221        uint8_t wIndex0 = pInformation->USBwIndex0;
;;;222    
;;;223        Related_Endpoint = (wIndex0 & 0x0f);
;;;224        if (ValBit(wIndex0, 7))
;;;225        {
;;;226          /* IN endpoint */
;;;227          if (_GetTxStallStatus(Related_Endpoint))
;;;228          {
;;;229            SetBit(StatusInfo0, 0); /* IN Endpoint stalled */
;;;230          }
;;;231        }
;;;232        else
;;;233        {
;;;234          /* OUT endpoint */
;;;235          if (_GetRxStallStatus(Related_Endpoint))
;;;236          {
;;;237            SetBit(StatusInfo0, 0); /* OUT Endpoint stalled */
;;;238          }
;;;239        }
;;;240    
;;;241      }
;;;242      else
;;;243      {
;;;244        return NULL;
;;;245      }
;;;246      pUser_Standard_Requests->User_GetStatus();
;;;247      return (uint8_t *)&StatusInfo;
;;;248    }
000010  bd10              POP      {r4,pc}
                  |L15.18|
000012  2000              MOVS     r0,#0                 ;185
000014  4937              LDR      r1,|L15.244|
000016  8008              STRH     r0,[r1,#0]            ;185
000018  4835              LDR      r0,|L15.240|
00001a  6800              LDR      r0,[r0,#0]            ;187  ; pInformation
00001c  7800              LDRB     r0,[r0,#0]            ;187
00001e  f000007f          AND      r0,r0,#0x7f           ;187
000022  bb18              CBNZ     r0,|L15.108|
000024  4932              LDR      r1,|L15.240|
000026  6809              LDR      r1,[r1,#0]            ;190  ; pInformation
000028  7a48              LDRB     r0,[r1,#9]            ;190
00002a  f0000120          AND      r1,r0,#0x20           ;193
00002e  b131              CBZ      r1,|L15.62|
000030  4930              LDR      r1,|L15.244|
000032  7809              LDRB     r1,[r1,#0]            ;195  ; StatusInfo
000034  f0410102          ORR      r1,r1,#2              ;195
000038  4a2e              LDR      r2,|L15.244|
00003a  7011              STRB     r1,[r2,#0]            ;195
00003c  e005              B        |L15.74|
                  |L15.62|
00003e  492d              LDR      r1,|L15.244|
000040  7809              LDRB     r1,[r1,#0]            ;199  ; StatusInfo
000042  f00101fd          AND      r1,r1,#0xfd           ;199
000046  4a2b              LDR      r2,|L15.244|
000048  7011              STRB     r1,[r2,#0]            ;199
                  |L15.74|
00004a  f0000140          AND      r1,r0,#0x40           ;203
00004e  b131              CBZ      r1,|L15.94|
000050  4928              LDR      r1,|L15.244|
000052  7809              LDRB     r1,[r1,#0]            ;205  ; StatusInfo
000054  f0410101          ORR      r1,r1,#1              ;205
000058  4a26              LDR      r2,|L15.244|
00005a  7011              STRB     r1,[r2,#0]            ;205
00005c  e005              B        |L15.106|
                  |L15.94|
00005e  4925              LDR      r1,|L15.244|
000060  7809              LDRB     r1,[r1,#0]            ;209  ; StatusInfo
000062  f00101fe          AND      r1,r1,#0xfe           ;209
000066  4a23              LDR      r2,|L15.244|
000068  7011              STRB     r1,[r2,#0]            ;209
                  |L15.106|
00006a  e03a              B        |L15.226|
                  |L15.108|
00006c  4820              LDR      r0,|L15.240|
00006e  6800              LDR      r0,[r0,#0]            ;213  ; pInformation
000070  7800              LDRB     r0,[r0,#0]            ;213
000072  f000007f          AND      r0,r0,#0x7f           ;213
000076  2801              CMP      r0,#1                 ;213
000078  d101              BNE      |L15.126|
00007a  481e              LDR      r0,|L15.244|
00007c  e7c8              B        |L15.16|
                  |L15.126|
00007e  481c              LDR      r0,|L15.240|
000080  6800              LDR      r0,[r0,#0]            ;218  ; pInformation
000082  7800              LDRB     r0,[r0,#0]            ;218
000084  f000007f          AND      r0,r0,#0x7f           ;218
000088  2802              CMP      r0,#2                 ;218
00008a  d128              BNE      |L15.222|
00008c  4a18              LDR      r2,|L15.240|
00008e  6812              LDR      r2,[r2,#0]            ;221  ; pInformation
000090  7951              LDRB     r1,[r2,#5]            ;221
000092  f001000f          AND      r0,r1,#0xf            ;223
000096  f0010280          AND      r2,r1,#0x80           ;224
00009a  b17a              CBZ      r2,|L15.188|
00009c  4b16              LDR      r3,|L15.248|
00009e  eb030280          ADD      r2,r3,r0,LSL #2       ;227
0000a2  f8d22c00          LDR      r2,[r2,#0xc00]        ;227
0000a6  f0020230          AND      r2,r2,#0x30           ;227
0000aa  2a10              CMP      r2,#0x10              ;227
0000ac  d116              BNE      |L15.220|
0000ae  4a11              LDR      r2,|L15.244|
0000b0  7812              LDRB     r2,[r2,#0]            ;229  ; StatusInfo
0000b2  f0420201          ORR      r2,r2,#1              ;229
0000b6  4b0f              LDR      r3,|L15.244|
0000b8  701a              STRB     r2,[r3,#0]            ;229
0000ba  e00f              B        |L15.220|
                  |L15.188|
0000bc  4b0e              LDR      r3,|L15.248|
0000be  eb030280          ADD      r2,r3,r0,LSL #2       ;235
0000c2  f8d22c00          LDR      r2,[r2,#0xc00]        ;235
0000c6  f4025240          AND      r2,r2,#0x3000         ;235
0000ca  f5b25f80          CMP      r2,#0x1000            ;235
0000ce  d105              BNE      |L15.220|
0000d0  4a08              LDR      r2,|L15.244|
0000d2  7812              LDRB     r2,[r2,#0]            ;237  ; StatusInfo
0000d4  f0420201          ORR      r2,r2,#1              ;237
0000d8  4b06              LDR      r3,|L15.244|
0000da  701a              STRB     r2,[r3,#0]            ;237
                  |L15.220|
0000dc  e001              B        |L15.226|
                  |L15.222|
0000de  2000              MOVS     r0,#0                 ;244
0000e0  e796              B        |L15.16|
                  |L15.226|
0000e2  4906              LDR      r1,|L15.252|
0000e4  6809              LDR      r1,[r1,#0]            ;246  ; pUser_Standard_Requests
0000e6  6908              LDR      r0,[r1,#0x10]         ;246
0000e8  4780              BLX      r0                    ;246
0000ea  4802              LDR      r0,|L15.244|
0000ec  e790              B        |L15.16|
;;;249    
                          ENDP

0000ee  0000              DCW      0x0000
                  |L15.240|
                          DCD      pInformation
                  |L15.244|
                          DCD      StatusInfo
                  |L15.248|
                          DCD      0x40005000
                  |L15.252|
                          DCD      pUser_Standard_Requests

                          AREA ||i.Standard_SetConfiguration||, CODE, READONLY, ALIGN=2

                  Standard_SetConfiguration PROC
;;;94     *******************************************************************************/
;;;95     RESULT Standard_SetConfiguration(void)
000000  b510              PUSH     {r4,lr}
;;;96     {
;;;97     
;;;98       if ((pInformation->USBwValue0 <=
000002  480e              LDR      r0,|L16.60|
000004  6800              LDR      r0,[r0,#0]  ; pInformation
000006  78c0              LDRB     r0,[r0,#3]
000008  490d              LDR      r1,|L16.64|
00000a  7849              LDRB     r1,[r1,#1]  ; Device_Table
00000c  4288              CMP      r0,r1
00000e  dc13              BGT      |L16.56|
;;;99           Device_Table.Total_Configuration) && (pInformation->USBwValue1 == 0)
000010  480a              LDR      r0,|L16.60|
000012  6800              LDR      r0,[r0,#0]  ; pInformation
000014  7880              LDRB     r0,[r0,#2]
000016  b978              CBNZ     r0,|L16.56|
;;;100          && (pInformation->USBwIndex == 0)) /*call Back usb spec 2.0*/
000018  4808              LDR      r0,|L16.60|
00001a  6800              LDR      r0,[r0,#0]  ; pInformation
00001c  8880              LDRH     r0,[r0,#4]
00001e  b958              CBNZ     r0,|L16.56|
;;;101      {
;;;102        pInformation->Current_Configuration = pInformation->USBwValue0;
000020  4806              LDR      r0,|L16.60|
000022  6800              LDR      r0,[r0,#0]  ; pInformation
000024  78c0              LDRB     r0,[r0,#3]
000026  4905              LDR      r1,|L16.60|
000028  6809              LDR      r1,[r1,#0]  ; pInformation
00002a  7288              STRB     r0,[r1,#0xa]
;;;103        pUser_Standard_Requests->User_SetConfiguration();
00002c  4905              LDR      r1,|L16.68|
00002e  6809              LDR      r1,[r1,#0]  ; pUser_Standard_Requests
000030  6848              LDR      r0,[r1,#4]
000032  4780              BLX      r0
;;;104        return USB_SUCCESS;
000034  2000              MOVS     r0,#0
                  |L16.54|
;;;105      }
;;;106      else
;;;107      {
;;;108        return USB_UNSUPPORT;
;;;109      }
;;;110    }
000036  bd10              POP      {r4,pc}
                  |L16.56|
000038  2002              MOVS     r0,#2                 ;108
00003a  e7fc              B        |L16.54|
;;;111    
                          ENDP

                  |L16.60|
                          DCD      pInformation
                  |L16.64|
                          DCD      Device_Table
                  |L16.68|
                          DCD      pUser_Standard_Requests

                          AREA ||i.Standard_SetDeviceFeature||, CODE, READONLY, ALIGN=2

                  Standard_SetDeviceFeature PROC
;;;404    *******************************************************************************/
;;;405    RESULT Standard_SetDeviceFeature(void)
000000  b510              PUSH     {r4,lr}
;;;406    {
;;;407      SetBit(pInformation->Current_Feature, 5);
000002  4807              LDR      r0,|L17.32|
000004  6800              LDR      r0,[r0,#0]  ; pInformation
000006  7a40              LDRB     r0,[r0,#9]
000008  f0400020          ORR      r0,r0,#0x20
00000c  4904              LDR      r1,|L17.32|
00000e  6809              LDR      r1,[r1,#0]  ; pInformation
000010  7248              STRB     r0,[r1,#9]
;;;408      pUser_Standard_Requests->User_SetDeviceFeature();
000012  4904              LDR      r1,|L17.36|
000014  6809              LDR      r1,[r1,#0]  ; pUser_Standard_Requests
000016  69c8              LDR      r0,[r1,#0x1c]
000018  4780              BLX      r0
;;;409      return USB_SUCCESS;
00001a  2000              MOVS     r0,#0
;;;410    }
00001c  bd10              POP      {r4,pc}
;;;411    
                          ENDP

00001e  0000              DCW      0x0000
                  |L17.32|
                          DCD      pInformation
                  |L17.36|
                          DCD      pUser_Standard_Requests

                          AREA ||i.Standard_SetEndPointFeature||, CODE, READONLY, ALIGN=2

                  Standard_SetEndPointFeature PROC
;;;350    *******************************************************************************/
;;;351    RESULT Standard_SetEndPointFeature(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;352    {
;;;353      uint32_t    wIndex0;
;;;354      uint32_t    Related_Endpoint;
;;;355      uint32_t    rEP;
;;;356      uint32_t    Status;
;;;357    
;;;358      wIndex0 = pInformation->USBwIndex0;
000004  482e              LDR      r0,|L18.192|
000006  6800              LDR      r0,[r0,#0]  ; pInformation
000008  7946              LDRB     r6,[r0,#5]
;;;359      rEP = wIndex0 & ~0x80;
00000a  f0260780          BIC      r7,r6,#0x80
;;;360      Related_Endpoint = ENDP0 + rEP;
00000e  463c              MOV      r4,r7
;;;361    
;;;362      if (ValBit(pInformation->USBwIndex0, 7))
000010  482b              LDR      r0,|L18.192|
000012  6800              LDR      r0,[r0,#0]  ; pInformation
000014  7940              LDRB     r0,[r0,#5]
000016  f0000080          AND      r0,r0,#0x80
00001a  b138              CBZ      r0,|L18.44|
;;;363      {
;;;364        /* get Status of endpoint & stall the request if the related_ENdpoint
;;;365        is Disabled*/
;;;366        Status = _GetEPTxStatus(Related_Endpoint);
00001c  4929              LDR      r1,|L18.196|
00001e  eb010084          ADD      r0,r1,r4,LSL #2
000022  f8d00c00          LDR      r0,[r0,#0xc00]
000026  f0000530          AND      r5,r0,#0x30
00002a  e006              B        |L18.58|
                  |L18.44|
;;;367      }
;;;368      else
;;;369      {
;;;370        Status = _GetEPRxStatus(Related_Endpoint);
00002c  4925              LDR      r1,|L18.196|
00002e  eb010084          ADD      r0,r1,r4,LSL #2
000032  f8d00c00          LDR      r0,[r0,#0xc00]
000036  f4005540          AND      r5,r0,#0x3000
                  |L18.58|
;;;371      }
;;;372    
;;;373      if (Related_Endpoint >= Device_Table.Total_Endpoint
00003a  4823              LDR      r0,|L18.200|
00003c  7800              LDRB     r0,[r0,#0]  ; Device_Table
00003e  42a0              CMP      r0,r4
000040  d908              BLS      |L18.84|
;;;374          || pInformation->USBwValue != 0 || Status == 0
000042  481f              LDR      r0,|L18.192|
000044  6800              LDR      r0,[r0,#0]  ; pInformation
000046  8840              LDRH     r0,[r0,#2]
000048  b920              CBNZ     r0,|L18.84|
00004a  b11d              CBZ      r5,|L18.84|
;;;375          || pInformation->Current_Configuration == 0)
00004c  481c              LDR      r0,|L18.192|
00004e  6800              LDR      r0,[r0,#0]  ; pInformation
000050  7a80              LDRB     r0,[r0,#0xa]
000052  b910              CBNZ     r0,|L18.90|
                  |L18.84|
;;;376      {
;;;377        return USB_UNSUPPORT;
000054  2002              MOVS     r0,#2
                  |L18.86|
;;;378      }
;;;379      else
;;;380      {
;;;381        if (wIndex0 & 0x80)
;;;382        {
;;;383          /* IN endpoint */
;;;384          _SetEPTxStatus(Related_Endpoint, EP_TX_STALL);
;;;385        }
;;;386    
;;;387        else
;;;388        {
;;;389          /* OUT endpoint */
;;;390          _SetEPRxStatus(Related_Endpoint, EP_RX_STALL);
;;;391        }
;;;392      }
;;;393      pUser_Standard_Requests->User_SetEndPointFeature();
;;;394      return USB_SUCCESS;
;;;395    }
000056  e8bd81f0          POP      {r4-r8,pc}
                  |L18.90|
00005a  f0060080          AND      r0,r6,#0x80           ;381
00005e  b1a0              CBZ      r0,|L18.138|
000060  4a18              LDR      r2,|L18.196|
000062  eb020184          ADD      r1,r2,r4,LSL #2       ;384
000066  f8d11c00          LDR      r1,[r1,#0xc00]        ;384
00006a  f64872bf          MOV      r2,#0x8fbf            ;384
00006e  ea010002          AND      r0,r1,r2              ;384
000072  f0800010          EOR      r0,r0,#0x10           ;384
000076  f4404100          ORR      r1,r0,#0x8000         ;384
00007a  f0410180          ORR      r1,r1,#0x80           ;384
00007e  4b11              LDR      r3,|L18.196|
000080  eb030284          ADD      r2,r3,r4,LSL #2       ;384
000084  f8c21c00          STR      r1,[r2,#0xc00]        ;384
000088  e014              B        |L18.180|
                  |L18.138|
00008a  4a0e              LDR      r2,|L18.196|
00008c  eb020184          ADD      r1,r2,r4,LSL #2       ;390
000090  f8d11c00          LDR      r1,[r1,#0xc00]        ;390
000094  f64b728f          MOV      r2,#0xbf8f            ;390
000098  ea010002          AND      r0,r1,r2              ;390
00009c  f4805080          EOR      r0,r0,#0x1000         ;390
0000a0  f4404100          ORR      r1,r0,#0x8000         ;390
0000a4  f0410180          ORR      r1,r1,#0x80           ;390
0000a8  4b06              LDR      r3,|L18.196|
0000aa  eb030284          ADD      r2,r3,r4,LSL #2       ;390
0000ae  f8c21c00          STR      r1,[r2,#0xc00]        ;390
0000b2  bf00              NOP                            ;390
                  |L18.180|
0000b4  4905              LDR      r1,|L18.204|
0000b6  6809              LDR      r1,[r1,#0]            ;393  ; pUser_Standard_Requests
0000b8  6988              LDR      r0,[r1,#0x18]         ;393
0000ba  4780              BLX      r0                    ;393
0000bc  2000              MOVS     r0,#0                 ;394
0000be  e7ca              B        |L18.86|
;;;396    
                          ENDP

                  |L18.192|
                          DCD      pInformation
                  |L18.196|
                          DCD      0x40005000
                  |L18.200|
                          DCD      Device_Table
                  |L18.204|
                          DCD      pUser_Standard_Requests

                          AREA ||i.Standard_SetInterface||, CODE, READONLY, ALIGN=2

                  Standard_SetInterface PROC
;;;140    *******************************************************************************/
;;;141    RESULT Standard_SetInterface(void)
000000  b510              PUSH     {r4,lr}
;;;142    {
;;;143      RESULT Re;
;;;144      /*Test if the specified Interface and Alternate Setting are supported by
;;;145        the application Firmware*/
;;;146      Re = (*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, pInformation->USBwValue0);
000002  4b17              LDR      r3,|L19.96|
000004  681b              LDR      r3,[r3,#0]  ; pInformation
000006  78d9              LDRB     r1,[r3,#3]
000008  4b15              LDR      r3,|L19.96|
00000a  681b              LDR      r3,[r3,#0]  ; pInformation
00000c  7958              LDRB     r0,[r3,#5]
00000e  4b15              LDR      r3,|L19.100|
000010  681b              LDR      r3,[r3,#0]  ; pProperty
000012  699a              LDR      r2,[r3,#0x18]
000014  4790              BLX      r2
000016  4604              MOV      r4,r0
;;;147    
;;;148      if (pInformation->Current_Configuration != 0)
000018  4811              LDR      r0,|L19.96|
00001a  6800              LDR      r0,[r0,#0]  ; pInformation
00001c  7a80              LDRB     r0,[r0,#0xa]
00001e  b1e8              CBZ      r0,|L19.92|
;;;149      {
;;;150        if ((Re != USB_SUCCESS) || (pInformation->USBwIndex1 != 0)
000020  b93c              CBNZ     r4,|L19.50|
000022  480f              LDR      r0,|L19.96|
000024  6800              LDR      r0,[r0,#0]  ; pInformation
000026  7900              LDRB     r0,[r0,#4]
000028  b918              CBNZ     r0,|L19.50|
;;;151            || (pInformation->USBwValue1 != 0))
00002a  480d              LDR      r0,|L19.96|
00002c  6800              LDR      r0,[r0,#0]  ; pInformation
00002e  7880              LDRB     r0,[r0,#2]
000030  b108              CBZ      r0,|L19.54|
                  |L19.50|
;;;152        {
;;;153          return  USB_UNSUPPORT;
000032  2002              MOVS     r0,#2
                  |L19.52|
;;;154        }
;;;155        else if (Re == USB_SUCCESS)
;;;156        {
;;;157          pUser_Standard_Requests->User_SetInterface();
;;;158          pInformation->Current_Interface = pInformation->USBwIndex0;
;;;159          pInformation->Current_AlternateSetting = pInformation->USBwValue0;
;;;160          return USB_SUCCESS;
;;;161        }
;;;162    
;;;163      }
;;;164    
;;;165      return USB_UNSUPPORT;
;;;166    }
000034  bd10              POP      {r4,pc}
                  |L19.54|
000036  b98c              CBNZ     r4,|L19.92|
000038  490b              LDR      r1,|L19.104|
00003a  6809              LDR      r1,[r1,#0]            ;157  ; pUser_Standard_Requests
00003c  68c8              LDR      r0,[r1,#0xc]          ;157
00003e  4780              BLX      r0                    ;157
000040  4807              LDR      r0,|L19.96|
000042  6800              LDR      r0,[r0,#0]            ;158  ; pInformation
000044  7940              LDRB     r0,[r0,#5]            ;158
000046  4906              LDR      r1,|L19.96|
000048  6809              LDR      r1,[r1,#0]            ;158  ; pInformation
00004a  72c8              STRB     r0,[r1,#0xb]          ;158
00004c  4804              LDR      r0,|L19.96|
00004e  6800              LDR      r0,[r0,#0]            ;159  ; pInformation
000050  78c0              LDRB     r0,[r0,#3]            ;159
000052  4903              LDR      r1,|L19.96|
000054  6809              LDR      r1,[r1,#0]            ;159  ; pInformation
000056  7308              STRB     r0,[r1,#0xc]          ;159
000058  2000              MOVS     r0,#0                 ;160
00005a  e7eb              B        |L19.52|
                  |L19.92|
00005c  2002              MOVS     r0,#2                 ;165
00005e  e7e9              B        |L19.52|
;;;167    
                          ENDP

                  |L19.96|
                          DCD      pInformation
                  |L19.100|
                          DCD      pProperty
                  |L19.104|
                          DCD      pUser_Standard_Requests

                          AREA ||.data||, DATA, ALIGN=1

                  StatusInfo
000000  0000              DCB      0x00,0x00
                  Data_Mul_MaxPacketSize
000002  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\Libraries\\STM32_USB-FS-Device_Driver\\src\\usb_core.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_usb_core_c_0b05b142____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___10_usb_core_c_0b05b142____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_usb_core_c_0b05b142____REVSH|
#line 128
|__asm___10_usb_core_c_0b05b142____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
